// @generated by protobuf-ts 2.4.0 with parameter long_type_string,client_grpc1,generate_dependencies,// @generated from protobuf file "indykite/identity/v1beta1/identity_management_api.proto" (package "indykite.identity.v1beta1", syntax proto3),// tslint:disable
//
// Copyright (c) 2020-2022 IndyKite
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { OAuth2TokenResponse } from "./model";
import { Invitation } from "./model";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { BoolValue } from "../../../google/protobuf/wrappers";
import { Value } from "../../objects/v1beta1/struct";
import { WriteResult } from "./document";
import { Write } from "./document";
import { Document } from "./document";
import { DocumentMask } from "./document";
import { BatchOperationResult } from "./attributes";
import { PropertyBatchOperation } from "./attributes";
import { DigitalEntity } from "./model";
import { PropertyMask } from "./attributes";
import { Property } from "./attributes";
import { MapValue } from "../../objects/v1beta1/struct";
import { DigitalTwin } from "./model";
import { IdentityTokenInfo } from "./model";
/**
 * @generated from protobuf message indykite.identity.v1beta1.TokenIntrospectRequest
 */
export interface TokenIntrospectRequest {
    /**
     * @generated from protobuf field: bytes tenant_id = 1;
     */
    tenantId: Uint8Array;
    /**
     * The string value of the token. For access tokens, this
     * is the "access_token" value returned from the token endpoint
     * defined in OAuth 2.0. For refresh tokens, this is the "refresh_token"
     * value returned.
     *
     * @generated from protobuf field: string token = 2;
     */
    token: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.TokenIntrospectResponse
 */
export interface TokenIntrospectResponse {
    /**
     * @generated from protobuf field: bool active = 1;
     */
    active: boolean;
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.IdentityTokenInfo token_info = 2;
     */
    tokenInfo?: IdentityTokenInfo;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.StartForgottenPasswordFlowRequest
 */
export interface StartForgottenPasswordFlowRequest {
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.DigitalTwin digital_twin = 1;
     */
    digitalTwin?: DigitalTwin;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.StartForgottenPasswordFlowResponse
 */
export interface StartForgottenPasswordFlowResponse {
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * @generated from protobuf oneof: uid
     */
    uid: {
        oneofKind: "token";
        /**
         * @generated from protobuf field: string token = 1;
         */
        token: string;
    } | {
        oneofKind: "digitalTwin";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.DigitalTwin digital_twin = 2;
         */
        digitalTwin: DigitalTwin;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: string password = 3;
     */
    password: string;
    /**
     * @generated from protobuf field: bool ignore_policy = 4;
     */
    ignorePolicy: boolean;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.ChangePasswordResponse
 */
export interface ChangePasswordResponse {
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.Error error = 1;
     */
    error?: Error;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.StartDigitalTwinEmailVerificationRequest
 */
export interface StartDigitalTwinEmailVerificationRequest {
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.DigitalTwin digital_twin = 1;
     */
    digitalTwin?: DigitalTwin;
    /**
     * @generated from protobuf field: string email = 2;
     */
    email: string;
    /**
     * @generated from protobuf field: indykite.objects.v1beta1.MapValue attributes = 7;
     */
    attributes?: MapValue;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.StartDigitalTwinEmailVerificationResponse
 */
export interface StartDigitalTwinEmailVerificationResponse {
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.VerifyDigitalTwinEmailRequest
 */
export interface VerifyDigitalTwinEmailRequest {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.VerifyDigitalTwinEmailResponse
 */
export interface VerifyDigitalTwinEmailResponse {
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.DigitalTwin digital_twin = 1;
     */
    digitalTwin?: DigitalTwin;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.SelfServiceTerminateSessionRequest
 */
export interface SelfServiceTerminateSessionRequest {
    /**
     * @generated from protobuf field: string refresh_token = 1;
     */
    refreshToken: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.SelfServiceTerminateSessionResponse
 */
export interface SelfServiceTerminateSessionResponse {
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.DigitalTwinIdentifier
 */
export interface DigitalTwinIdentifier {
    /**
     * @generated from protobuf oneof: filter
     */
    filter: {
        oneofKind: "digitalTwin";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.DigitalTwin digital_twin = 1;
         */
        digitalTwin: DigitalTwin;
    } | {
        oneofKind: "property";
        /**
         * Property + tenantId not yet supported
         *
         * @generated from protobuf field: indykite.identity.v1beta1.Property property = 2;
         */
        property: Property;
    } | {
        oneofKind: "accessToken";
        /**
         * @generated from protobuf field: string access_token = 3;
         */
        accessToken: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.GetDigitalTwinRequest
 */
export interface GetDigitalTwinRequest {
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.DigitalTwinIdentifier id = 1;
     */
    id?: DigitalTwinIdentifier;
    /**
     * Properties defines the list of requested properties to get.
     *
     * @generated from protobuf field: repeated indykite.identity.v1beta1.PropertyMask properties = 2;
     */
    properties: PropertyMask[];
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.GetDigitalTwinResponse
 */
export interface GetDigitalTwinResponse {
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.DigitalEntity digital_twin = 1;
     */
    digitalTwin?: DigitalEntity;
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.IdentityTokenInfo token_info = 2;
     */
    tokenInfo?: IdentityTokenInfo;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.ListDigitalTwinsRequest
 */
export interface ListDigitalTwinsRequest {
    /**
     * @generated from protobuf field: bytes tenant_id = 1;
     */
    tenantId: Uint8Array;
    /**
     * CollectionId, relative to `parent`, to list.
     * Required.
     *
     * @generated from protobuf field: string collection_id = 2;
     */
    collectionId: string;
    /**
     * PageSize is the maximum number of documents to return.
     *
     * @generated from protobuf field: int32 page_size = 3;
     */
    pageSize: number;
    /**
     * PageToken is the `next_page_token` value returned from a previous List request.
     *
     * @generated from protobuf field: string page_token = 4;
     */
    pageToken: string;
    /**
     * OrderBy to sort results by. For example: `priority desc, name`.
     *
     * @generated from protobuf field: string order_by = 5;
     */
    orderBy: string;
    /**
     * Properties contains the requested property values.
     *
     * @generated from protobuf field: repeated indykite.identity.v1beta1.Property properties = 6;
     */
    properties: Property[];
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.ListDigitalTwinsResponse
 */
export interface ListDigitalTwinsResponse {
    /**
     * @generated from protobuf field: repeated indykite.identity.v1beta1.DigitalEntity digital_twin = 1;
     */
    digitalTwin: DigitalEntity[];
    /**
     * NextPageToken is `page_token` value for the next ListDocumentsRequest.
     *
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.PatchDigitalTwinRequest
 */
export interface PatchDigitalTwinRequest {
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.DigitalTwinIdentifier id = 1;
     */
    id?: DigitalTwinIdentifier;
    /**
     * @generated from protobuf field: repeated indykite.identity.v1beta1.PropertyBatchOperation operations = 2;
     */
    operations: PropertyBatchOperation[];
    /**
     * AdminToken must be set when id contains only the DigitalTwin.
     *
     * @generated from protobuf field: string admin_token = 3;
     */
    adminToken: string;
    /**
     * ForceDelete must be set to true to delete primary property
     *
     * @generated from protobuf field: bool force_delete = 4;
     */
    forceDelete: boolean;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.PatchDigitalTwinResponse
 */
export interface PatchDigitalTwinResponse {
    /**
     * @generated from protobuf field: repeated indykite.identity.v1beta1.BatchOperationResult result = 1;
     */
    result: BatchOperationResult[];
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.DeleteDigitalTwinRequest
 */
export interface DeleteDigitalTwinRequest {
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.DigitalTwinIdentifier id = 1;
     */
    id?: DigitalTwinIdentifier;
    /**
     * AdminToken must be set when id contains only the DigitalTwin.
     *
     * @generated from protobuf field: string admin_token = 2;
     */
    adminToken: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.DeleteDigitalTwinResponse
 */
export interface DeleteDigitalTwinResponse {
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.DigitalTwin digital_twin = 1;
     */
    digitalTwin?: DigitalTwin;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.GetDocumentRequest
 */
export interface GetDocumentRequest {
    /**
     * Name of the document resource.
     * Format: `databases/{application_id}/documents/{document_path}`.
     * Format: `databases/{application_id}/documents/plans/free`.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mask is the fields to return. If not set, returns all fields.
     *
     * @generated from protobuf field: indykite.identity.v1beta1.DocumentMask mask = 2;
     */
    mask?: DocumentMask;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.GetDocumentResponse
 */
export interface GetDocumentResponse {
    /**
     * Document is the result of the get.
     *
     * @generated from protobuf field: indykite.identity.v1beta1.Document document = 1;
     */
    document?: Document;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.BatchGetDocumentsRequest
 */
export interface BatchGetDocumentsRequest {
    /**
     * Database is the name of the database.
     * Format: `databases/{application_id}`.
     *
     * @generated from protobuf field: string database = 1;
     */
    database: string;
    /**
     * Documents is the names of the documents to retrieve.
     * Format: `databases/{application_id}/documents/{document_path}`.
     *
     * @generated from protobuf field: repeated string documents = 2;
     */
    documents: string[];
    /**
     * Mask is the fields to return. If not set, returns all fields.
     *
     * @generated from protobuf field: indykite.identity.v1beta1.DocumentMask mask = 3;
     */
    mask?: DocumentMask;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.BatchGetDocumentsResponse
 */
export interface BatchGetDocumentsResponse {
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "found";
        /**
         * A document that was requested.
         *
         * @generated from protobuf field: indykite.identity.v1beta1.Document found = 1;
         */
        found: Document;
    } | {
        oneofKind: "missing";
        /**
         * Missing is a document name that was requested but does not exist.
         * Format: `databases/{application_id}/documents/{document_path}`.
         *
         * @generated from protobuf field: string missing = 2;
         */
        missing: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.ListDocumentsRequest
 */
export interface ListDocumentsRequest {
    /**
     * Parent resource name to resolve the collection.
     * Format: `databases/{application_id}/documents/{document_path}`.
     * Required.
     *
     * @generated from protobuf field: string parent = 1;
     */
    parent: string;
    /**
     * CollectionId, relative to `parent`, to list.
     * Required.
     *
     * @generated from protobuf field: string collection_id = 2;
     */
    collectionId: string;
    /**
     * PageSize is the maximum number of documents to return.
     *
     * @generated from protobuf field: int32 page_size = 3;
     */
    pageSize: number;
    /**
     * PageToken is the `next_page_token` value returned from a previous List request.
     *
     * @generated from protobuf field: string page_token = 4;
     */
    pageToken: string;
    /**
     * OrderBy to sort results by. For example: `priority desc, name`.
     *
     * @generated from protobuf field: string order_by = 6;
     */
    orderBy: string;
    /**
     * Mask is the fields to return. If not set, returns all fields.
     *
     * @generated from protobuf field: indykite.identity.v1beta1.DocumentMask mask = 7;
     */
    mask?: DocumentMask;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.ListDocumentsResponse
 */
export interface ListDocumentsResponse {
    /**
     * The Documents found.
     *
     * @generated from protobuf field: repeated indykite.identity.v1beta1.Document documents = 1;
     */
    documents: Document[];
    /**
     * NextPageToken is `page_token` value for the next ListDocumentsRequest.
     *
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.MutateDocumentsRequest
 */
export interface MutateDocumentsRequest {
    /**
     * The database name.
     * Format: `databases/{application_id}`.
     * Required.
     *
     * @generated from protobuf field: string database = 1;
     */
    database: string;
    /**
     * The writes to apply.
     *
     * @generated from protobuf field: repeated indykite.identity.v1beta1.Write writes = 2;
     */
    writes: Write[];
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.MutateDocumentsResponse
 */
export interface MutateDocumentsResponse {
    /**
     * WriteResults is the result of applying the writes.
     *
     * This i-th write result corresponds to the i-th write in the
     * request.
     *
     * @generated from protobuf field: repeated indykite.identity.v1beta1.WriteResult write_results = 1;
     */
    writeResults: WriteResult[];
}
/**
 * RunQueryRequest ... NOT YET SUPPORTED!
 *
 * @generated from protobuf message indykite.identity.v1beta1.RunQueryRequest
 */
export interface RunQueryRequest {
    /**
     * Parent resource name to resolve the collection.
     * Format: `databases/{application_id}/documents/{document_path}`.
     * Required.
     *
     * @generated from protobuf field: string parent = 1;
     */
    parent: string;
    /**
     * @generated from protobuf oneof: query_type
     */
    queryType: {
        oneofKind: "structuredQuery";
        /**
         * A structured query.
         *
         * @generated from protobuf field: indykite.objects.v1beta1.Value structured_query = 2;
         */
        structuredQuery: Value;
    } | {
        oneofKind: undefined;
    };
}
/**
 * RunQueryResponse ... NOT YET SUPPORTED!
 *
 * @generated from protobuf message indykite.identity.v1beta1.RunQueryResponse
 */
export interface RunQueryResponse {
    /**
     * A query result.
     *
     * @generated from protobuf field: indykite.identity.v1beta1.Document document = 1;
     */
    document?: Document;
    /**
     * SkippedResults is the number of results that have been skipped due to an offset between
     * the last response and the current response.
     *
     * @generated from protobuf field: int32 skipped_results = 4;
     */
    skippedResults: number;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.GetPasswordCredentialRequest
 */
export interface GetPasswordCredentialRequest {
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.DigitalTwin digital_twin = 1;
     */
    digitalTwin?: DigitalTwin;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.GetPasswordCredentialResponse
 */
export interface GetPasswordCredentialResponse {
}
/**
 * UpdatePasswordCredentialRequest used to change the Password Credential meta-data.
 *
 * @generated from protobuf message indykite.identity.v1beta1.UpdatePasswordCredentialRequest
 */
export interface UpdatePasswordCredentialRequest {
    /**
     * The username used to login.
     * google.protobuf.StringValue login = 1;
     *
     * @generated from protobuf field: repeated bytes login_properties = 1;
     */
    loginProperties: Uint8Array[];
    /**
     * @generated from protobuf field: google.protobuf.BoolValue must_change = 2;
     */
    mustChange?: BoolValue;
    /**
     * @generated from protobuf field: google.protobuf.BoolValue locked = 5;
     */
    locked?: BoolValue;
    /**
     * @generated from protobuf oneof: primary
     */
    primary: {
        oneofKind: "email";
        /**
         * @generated from protobuf field: string email = 3;
         */
        email: string;
    } | {
        oneofKind: "mobile";
        /**
         * @generated from protobuf field: string mobile = 4;
         */
        mobile: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.UpdatePasswordCredentialResponse
 */
export interface UpdatePasswordCredentialResponse {
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.Error
 */
export interface Error {
    /**
     * Invalid Authorization
     * Password Policy Violation
     * Password Can't be changed
     * Unknown UID
     * UID has no Password Credential
     *
     * @generated from protobuf field: string code = 1;
     */
    code: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.SelfServiceChangePasswordRequest
 */
export interface SelfServiceChangePasswordRequest {
    /**
     * @generated from protobuf field: string password = 1;
     */
    password: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.SelfServiceChangePasswordResponse
 */
export interface SelfServiceChangePasswordResponse {
    /**
     * @generated from protobuf field: bool success = 1;
     */
    success: boolean;
    /**
     * @generated from protobuf field: string error = 2;
     */
    error: string; // Password policy violation
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.CreateInvitationRequest
 */
export interface CreateInvitationRequest {
    /**
     * TenantId specify under which tenant the user is invited
     *
     * @generated from protobuf field: bytes tenant_id = 1;
     */
    tenantId: Uint8Array;
    /**
     * ReferenceId is unique external reference identifier to correlate the lifecycle events with.
     * Must be unique withing the whole application
     *
     * @generated from protobuf field: string reference_id = 2;
     */
    referenceId: string;
    /**
     * InviteAtTime can be empty to send invitation immediately.
     * Or can specify time in the future to postpone sending invitation message.
     *
     * @generated from protobuf field: google.protobuf.Timestamp invite_at_time = 3;
     */
    inviteAtTime?: Timestamp;
    /**
     * ExpireTime can be empty and default lifetime is used. Or you can specify own expiration time of invitation.
     *
     * @generated from protobuf field: google.protobuf.Timestamp expire_time = 4;
     */
    expireTime?: Timestamp;
    /**
     * Attributes passed into message sender
     *
     * @generated from protobuf field: indykite.objects.v1beta1.MapValue message_attributes = 5;
     */
    messageAttributes?: MapValue;
    /**
     * @generated from protobuf oneof: invitee
     */
    invitee: {
        oneofKind: "email";
        /**
         * Email address where invitation message will be sent.
         *
         * @generated from protobuf field: string email = 6;
         */
        email: string;
    } | {
        oneofKind: "mobile";
        /**
         * Mobile number where sms will be sent.
         *
         * @generated from protobuf field: string mobile = 7;
         */
        mobile: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.CreateInvitationResponse
 */
export interface CreateInvitationResponse {
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.CheckInvitationStateRequest
 */
export interface CheckInvitationStateRequest {
    /**
     * @generated from protobuf oneof: identifier
     */
    identifier: {
        oneofKind: "referenceId";
        /**
         * ReferenceId is unique external reference identifier to correlate the lifecycle events with.
         *
         * @generated from protobuf field: string reference_id = 1;
         */
        referenceId: string;
    } | {
        oneofKind: "invitationToken";
        /**
         * InvitationToken is a unique token used in invitation URL.
         *
         * @generated from protobuf field: string invitation_token = 2;
         */
        invitationToken: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.CheckInvitationStateResponse
 */
export interface CheckInvitationStateResponse {
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.Invitation invitation = 1;
     */
    invitation?: Invitation;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.ResendInvitationRequest
 */
export interface ResendInvitationRequest {
    /**
     * ReferenceId is unique external reference identifier to correlate the lifecycle events with.
     *
     * @generated from protobuf field: string reference_id = 1;
     */
    referenceId: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.ResendInvitationResponse
 */
export interface ResendInvitationResponse {
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.CancelInvitationRequest
 */
export interface CancelInvitationRequest {
    /**
     * ReferenceId is unique external reference identifier to correlate the lifecycle events with.
     *
     * @generated from protobuf field: string reference_id = 1;
     */
    referenceId: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.CancelInvitationResponse
 */
export interface CancelInvitationResponse {
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.CheckConsentChallengeRequest
 */
export interface CheckConsentChallengeRequest {
    /**
     * @generated from protobuf field: string challenge = 1;
     */
    challenge: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.CheckConsentChallengeResponse
 */
export interface CheckConsentChallengeResponse {
    /**
     * @generated from protobuf field: string client_id = 1;
     */
    clientId: string;
    /**
     * @generated from protobuf field: bytes app_space_id = 2;
     */
    appSpaceId: Uint8Array;
    /**
     * @generated from protobuf field: repeated indykite.identity.v1beta1.AudienceItem audiences = 3;
     */
    audiences: AudienceItem[];
    /**
     * @generated from protobuf field: repeated indykite.identity.v1beta1.ScopeItem scopes = 4;
     */
    scopes: ScopeItem[];
    /**
     * ACR represents the Authentication AuthorizationContext Class Reference value for this authentication session. You can use it
     * to express that, for example, a user authenticated using two factor authentication.
     *
     * @generated from protobuf field: repeated string acrs = 5;
     */
    acrs: string[];
    /**
     * RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which
     * initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but
     * might come in handy if you want to deal with additional request parameters.
     *
     * @generated from protobuf field: string request_url = 6;
     */
    requestUrl: string;
    /**
     * Skip, if true, implies that the client has requested the same scopes from the same user previously.
     * If true, you must not ask the user to grant the requested scopes. You must however either allow or deny the
     * consent request using the usual API call.
     *
     * @generated from protobuf field: bool skip = 7;
     */
    skip: boolean;
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.DigitalTwin digital_twin = 8;
     */
    digitalTwin?: DigitalTwin;
    /**
     * SubjectIdentifier is pairwise identifier as the sub claims in the token
     *
     * @generated from protobuf field: string subject_identifier = 9;
     */
    subjectIdentifier: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp authenticated_at = 10;
     */
    authenticatedAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp requested_at = 11;
     */
    requestedAt?: Timestamp;
    /**
     * Context is an optional object which can hold arbitrary data. The data will be made available when fetching the
     * consent request under the "context" field. This is useful in scenarios where login and consent endpoints share
     * data.
     *
     * @generated from protobuf field: indykite.objects.v1beta1.MapValue context = 12;
     */
    context?: MapValue;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.ScopeItem
 */
export interface ScopeItem {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string display_name = 2;
     */
    displayName: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * @generated from protobuf field: bool required = 4;
     */
    required: boolean;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.AudienceItem
 */
export interface AudienceItem {
    /**
     * @generated from protobuf field: string user_support_email_address = 1;
     */
    userSupportEmailAddress: string;
    /**
     * @generated from protobuf field: string client_id = 2;
     */
    clientId: string;
    /**
     * @generated from protobuf field: string display_name = 3;
     */
    displayName: string;
    /**
     * @generated from protobuf field: string description = 4;
     */
    description: string;
    /**
     * @generated from protobuf field: string logo_url = 5;
     */
    logoUrl: string;
    /**
     * @generated from protobuf field: string homepage_url = 6;
     */
    homepageUrl: string;
    /**
     * @generated from protobuf field: string privacy_policy_url = 7;
     */
    privacyPolicyUrl: string;
    /**
     * @generated from protobuf field: string tos_url = 8;
     */
    tosUrl: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.CreateConsentVerifierRequest
 */
export interface CreateConsentVerifierRequest {
    /**
     * @generated from protobuf field: string challenge = 1;
     */
    challenge: string;
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "approval";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.ConsentApproval approval = 2;
         */
        approval: ConsentApproval;
    } | {
        oneofKind: "denial";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.DenialResponse denial = 3;
         */
        denial: DenialResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.CreateConsentVerifierResponse
 */
export interface CreateConsentVerifierResponse {
    /**
     * @generated from protobuf field: string verifier = 1;
     */
    verifier: string;
    /**
     * @generated from protobuf field: string authorization_endpoint = 2;
     */
    authorizationEndpoint: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.ConsentApproval
 */
export interface ConsentApproval {
    /**
     * GrantScopes sets the scope the user authorized the client to use. Should be a subset of `requested_scope`.
     *
     * @generated from protobuf field: repeated string grant_scopes = 1;
     */
    grantScopes: string[];
    /**
     * GrantedAudiences sets the audience the user authorized the client to use. Should be a subset of `audiences`.
     *
     * @generated from protobuf field: repeated string granted_audiences = 2;
     */
    grantedAudiences: string[];
    /**
     * Session allows you to set (optional) session data for access and ID tokens.
     *
     * @generated from protobuf field: indykite.identity.v1beta1.ConsentRequestSessionData session = 3;
     */
    session?: ConsentRequestSessionData;
    /**
     * Remember, if set to true, tells ORY Hydra to remember this consent authorization and reuse it if the same
     * client asks the same user for the same, or a subset of, scope.
     *
     * @generated from protobuf field: bool remember = 4;
     */
    remember: boolean;
    /**
     * RememberFor sets how long the consent authorization should be remembered for in seconds. If set to `0`, the
     * authorization will be remembered indefinitely.
     *
     * @generated from protobuf field: int64 remember_for = 5;
     */
    rememberFor: string;
}
/**
 * Used to pass session data to a consent request.
 *
 * @generated from protobuf message indykite.identity.v1beta1.ConsentRequestSessionData
 */
export interface ConsentRequestSessionData {
    /**
     * AccessToken sets session data for the access and refresh token, as well as any future tokens issued by the
     * refresh grant. Keep in mind that this data will be available to anyone performing OAuth 2.0 Challenge Introspection.
     * If only your services can perform OAuth 2.0 Challenge Introspection, this is usually fine. But if third parties
     * can access that endpoint as well, sensitive data from the session might be exposed to them. Use with care!
     *
     * @generated from protobuf field: indykite.objects.v1beta1.MapValue access_token = 1;
     */
    accessToken?: MapValue;
    /**
     * IDToken sets session data for the OpenID Connect ID token. Keep in mind that the session'id payloads are readable
     * by anyone that has access to the ID Challenge. Use with care!
     *
     * @generated from protobuf field: indykite.objects.v1beta1.MapValue id_token = 2;
     */
    idToken?: MapValue;
    /**
     * @generated from protobuf field: indykite.objects.v1beta1.MapValue userinfo = 3;
     */
    userinfo?: MapValue;
}
/**
 * The request payload used to accept a login or consent request.
 *
 * @generated from protobuf message indykite.identity.v1beta1.DenialResponse
 */
export interface DenialResponse {
    /**
     * The error should follow the OAuth2 error format (e.g. `invalid_request`, `login_required`).
     * See [https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2.1](full specification)
     * Defaults to `access_denied`.
     *
     * @generated from protobuf field: string error = 1;
     */
    error: string;
    /**
     * Description of the error in a human readable format.
     *
     * @generated from protobuf field: string error_description = 2;
     */
    errorDescription: string;
    /**
     * Hint to help resolve the error.
     *
     * @generated from protobuf field: string error_hint = 3;
     */
    errorHint: string;
    /**
     * Represents the HTTP status code of the error (e.g. 401 or 403)
     *
     * Defaults to 403
     *
     * @generated from protobuf field: int64 status_code = 4;
     */
    statusCode: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.GetAccessTokenRequest
 */
export interface GetAccessTokenRequest {
    /**
     * Client Application Identifier. Set by the server from the authenticated client.
     *
     * @generated from protobuf field: string app_id = 1;
     */
    appId: string;
    /**
     * Identity Provider configuration unique id - overrules type + name.
     *
     * @generated from protobuf field: string provider_id = 2;
     */
    providerId: string;
    /**
     * Identity Provider type.
     * id.indykite.jarvis.services.configuration.OAuth2ProviderType provider = 3;
     * Identity Provider configuration  name.
     *
     * @generated from protobuf field: string provider_name = 4;
     */
    providerName: string;
    /**
     * Digital Twin / Subject ID (Optional). If not provided authentication flow triggered.
     *
     * @generated from protobuf field: string subject_id = 5;
     */
    subjectId: string;
    /**
     * Requested scopes
     *
     * @generated from protobuf field: repeated string scopes = 6;
     */
    scopes: string[];
    /**
     * If true a refresh_token is requested and stored so next time authentication is not requested.
     *
     * @generated from protobuf field: bool offline_access = 7;
     */
    offlineAccess: boolean;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.GetAccessTokenResponse
 */
export interface GetAccessTokenResponse {
    /**
     * The active access token
     *
     * @generated from protobuf field: indykite.identity.v1beta1.OAuth2TokenResponse token = 1;
     */
    token?: OAuth2TokenResponse;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.SessionIntrospectRequest
 */
export interface SessionIntrospectRequest {
    /**
     * @generated from protobuf field: bytes tenant_id = 1;
     */
    tenantId: Uint8Array;
    /**
     * The string value of the token. For access tokens, this
     * is the "access_token" value returned from the token endpoint
     * defined in OAuth 2.0. For refresh tokens, this is the "refresh_token"
     * value returned.
     *
     * @generated from protobuf field: string token = 2;
     */
    token: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.SessionIntrospectResponse
 */
export interface SessionIntrospectResponse {
    /**
     * @generated from protobuf field: bool active = 1;
     */
    active: boolean;
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.IdentityTokenInfo token_info = 2;
     */
    tokenInfo?: IdentityTokenInfo;
    /**
     * @generated from protobuf field: repeated string provider_data = 3;
     */
    providerData: string[];
}
/**
 * @generated from protobuf enum indykite.identity.v1beta1.CredentialControl
 */
export enum CredentialControl {
    /**
     * @generated from protobuf enum value: CREDENTIAL_CONTROL_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: CREDENTIAL_CONTROL_DISABLE = 1;
     */
    DISABLE = 1,
    /**
     * @generated from protobuf enum value: CREDENTIAL_CONTROL_ENABLE = 2;
     */
    ENABLE = 2,
    /**
     * @generated from protobuf enum value: CREDENTIAL_CONTROL_LOCKOUT = 3;
     */
    LOCKOUT = 3,
    /**
     * The user can't change the password.
     *
     * @generated from protobuf enum value: CREDENTIAL_CONTROL_PASSWORD_CANT_CHANGE = 4;
     */
    PASSWORD_CANT_CHANGE = 4,
    /**
     * It's a default account type that represents a typical user.
     *
     * @generated from protobuf enum value: CREDENTIAL_CONTROL_NORMAL_ACCOUNT = 5;
     */
    NORMAL_ACCOUNT = 5,
    /**
     * Represents the password, which should never expire on the account.
     *
     * @generated from protobuf enum value: CREDENTIAL_CONTROL_DONT_EXPIRE_PASSWORD = 6;
     */
    DONT_EXPIRE_PASSWORD = 6,
    /**
     * The user's password has expired.
     *
     * CREDENTIAL_CONTROL_ENCRYPTED_TEXT_PASSWORD_ALLOWED = 8;
     *
     * @generated from protobuf enum value: CREDENTIAL_CONTROL_PASSWORD_EXPIRED = 7;
     */
    PASSWORD_EXPIRED = 7
}
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectRequest$Type extends MessageType<TokenIntrospectRequest> {
    constructor() {
        super("indykite.identity.v1beta1.TokenIntrospectRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectRequest>): TokenIntrospectRequest {
        const message = { tenantId: new Uint8Array(0), token: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectRequest): TokenIntrospectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes tenant_id */ 1:
                    message.tenantId = reader.bytes();
                    break;
                case /* string token */ 2:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenIntrospectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes tenant_id = 1; */
        if (message.tenantId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.tenantId);
        /* string token = 2; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.TokenIntrospectRequest
 */
export const TokenIntrospectRequest = new TokenIntrospectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectResponse$Type extends MessageType<TokenIntrospectResponse> {
    constructor() {
        super("indykite.identity.v1beta1.TokenIntrospectResponse", [
            { no: 1, name: "active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "token_info", kind: "message", T: () => IdentityTokenInfo }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectResponse>): TokenIntrospectResponse {
        const message = { active: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectResponse): TokenIntrospectResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool active */ 1:
                    message.active = reader.bool();
                    break;
                case /* indykite.identity.v1beta1.IdentityTokenInfo token_info */ 2:
                    message.tokenInfo = IdentityTokenInfo.internalBinaryRead(reader, reader.uint32(), options, message.tokenInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenIntrospectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool active = 1; */
        if (message.active !== false)
            writer.tag(1, WireType.Varint).bool(message.active);
        /* indykite.identity.v1beta1.IdentityTokenInfo token_info = 2; */
        if (message.tokenInfo)
            IdentityTokenInfo.internalBinaryWrite(message.tokenInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.TokenIntrospectResponse
 */
export const TokenIntrospectResponse = new TokenIntrospectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartForgottenPasswordFlowRequest$Type extends MessageType<StartForgottenPasswordFlowRequest> {
    constructor() {
        super("indykite.identity.v1beta1.StartForgottenPasswordFlowRequest", [
            { no: 1, name: "digital_twin", kind: "message", T: () => DigitalTwin }
        ]);
    }
    create(value?: PartialMessage<StartForgottenPasswordFlowRequest>): StartForgottenPasswordFlowRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartForgottenPasswordFlowRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartForgottenPasswordFlowRequest): StartForgottenPasswordFlowRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.DigitalTwin digital_twin */ 1:
                    message.digitalTwin = DigitalTwin.internalBinaryRead(reader, reader.uint32(), options, message.digitalTwin);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartForgottenPasswordFlowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.DigitalTwin digital_twin = 1; */
        if (message.digitalTwin)
            DigitalTwin.internalBinaryWrite(message.digitalTwin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.StartForgottenPasswordFlowRequest
 */
export const StartForgottenPasswordFlowRequest = new StartForgottenPasswordFlowRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartForgottenPasswordFlowResponse$Type extends MessageType<StartForgottenPasswordFlowResponse> {
    constructor() {
        super("indykite.identity.v1beta1.StartForgottenPasswordFlowResponse", []);
    }
    create(value?: PartialMessage<StartForgottenPasswordFlowResponse>): StartForgottenPasswordFlowResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartForgottenPasswordFlowResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartForgottenPasswordFlowResponse): StartForgottenPasswordFlowResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: StartForgottenPasswordFlowResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.StartForgottenPasswordFlowResponse
 */
export const StartForgottenPasswordFlowResponse = new StartForgottenPasswordFlowResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangePasswordRequest$Type extends MessageType<ChangePasswordRequest> {
    constructor() {
        super("indykite.identity.v1beta1.ChangePasswordRequest", [
            { no: 1, name: "token", kind: "scalar", oneof: "uid", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "digital_twin", kind: "message", oneof: "uid", T: () => DigitalTwin },
            { no: 3, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ignore_policy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ChangePasswordRequest>): ChangePasswordRequest {
        const message = { uid: { oneofKind: undefined }, password: "", ignorePolicy: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangePasswordRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangePasswordRequest): ChangePasswordRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.uid = {
                        oneofKind: "token",
                        token: reader.string()
                    };
                    break;
                case /* indykite.identity.v1beta1.DigitalTwin digital_twin */ 2:
                    message.uid = {
                        oneofKind: "digitalTwin",
                        digitalTwin: DigitalTwin.internalBinaryRead(reader, reader.uint32(), options, (message.uid as any).digitalTwin)
                    };
                    break;
                case /* string password */ 3:
                    message.password = reader.string();
                    break;
                case /* bool ignore_policy */ 4:
                    message.ignorePolicy = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangePasswordRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.uid.oneofKind === "token")
            writer.tag(1, WireType.LengthDelimited).string(message.uid.token);
        /* indykite.identity.v1beta1.DigitalTwin digital_twin = 2; */
        if (message.uid.oneofKind === "digitalTwin")
            DigitalTwin.internalBinaryWrite(message.uid.digitalTwin, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string password = 3; */
        if (message.password !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.password);
        /* bool ignore_policy = 4; */
        if (message.ignorePolicy !== false)
            writer.tag(4, WireType.Varint).bool(message.ignorePolicy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ChangePasswordRequest
 */
export const ChangePasswordRequest = new ChangePasswordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangePasswordResponse$Type extends MessageType<ChangePasswordResponse> {
    constructor() {
        super("indykite.identity.v1beta1.ChangePasswordResponse", [
            { no: 1, name: "error", kind: "message", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<ChangePasswordResponse>): ChangePasswordResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangePasswordResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangePasswordResponse): ChangePasswordResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.Error error */ 1:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangePasswordResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.Error error = 1; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ChangePasswordResponse
 */
export const ChangePasswordResponse = new ChangePasswordResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartDigitalTwinEmailVerificationRequest$Type extends MessageType<StartDigitalTwinEmailVerificationRequest> {
    constructor() {
        super("indykite.identity.v1beta1.StartDigitalTwinEmailVerificationRequest", [
            { no: 1, name: "digital_twin", kind: "message", T: () => DigitalTwin, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { email: true } } } },
            { no: 7, name: "attributes", kind: "message", T: () => MapValue }
        ]);
    }
    create(value?: PartialMessage<StartDigitalTwinEmailVerificationRequest>): StartDigitalTwinEmailVerificationRequest {
        const message = { email: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartDigitalTwinEmailVerificationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartDigitalTwinEmailVerificationRequest): StartDigitalTwinEmailVerificationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.DigitalTwin digital_twin */ 1:
                    message.digitalTwin = DigitalTwin.internalBinaryRead(reader, reader.uint32(), options, message.digitalTwin);
                    break;
                case /* string email */ 2:
                    message.email = reader.string();
                    break;
                case /* indykite.objects.v1beta1.MapValue attributes */ 7:
                    message.attributes = MapValue.internalBinaryRead(reader, reader.uint32(), options, message.attributes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartDigitalTwinEmailVerificationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.DigitalTwin digital_twin = 1; */
        if (message.digitalTwin)
            DigitalTwin.internalBinaryWrite(message.digitalTwin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string email = 2; */
        if (message.email !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.email);
        /* indykite.objects.v1beta1.MapValue attributes = 7; */
        if (message.attributes)
            MapValue.internalBinaryWrite(message.attributes, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.StartDigitalTwinEmailVerificationRequest
 */
export const StartDigitalTwinEmailVerificationRequest = new StartDigitalTwinEmailVerificationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartDigitalTwinEmailVerificationResponse$Type extends MessageType<StartDigitalTwinEmailVerificationResponse> {
    constructor() {
        super("indykite.identity.v1beta1.StartDigitalTwinEmailVerificationResponse", []);
    }
    create(value?: PartialMessage<StartDigitalTwinEmailVerificationResponse>): StartDigitalTwinEmailVerificationResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartDigitalTwinEmailVerificationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartDigitalTwinEmailVerificationResponse): StartDigitalTwinEmailVerificationResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: StartDigitalTwinEmailVerificationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.StartDigitalTwinEmailVerificationResponse
 */
export const StartDigitalTwinEmailVerificationResponse = new StartDigitalTwinEmailVerificationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyDigitalTwinEmailRequest$Type extends MessageType<VerifyDigitalTwinEmailRequest> {
    constructor() {
        super("indykite.identity.v1beta1.VerifyDigitalTwinEmailRequest", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VerifyDigitalTwinEmailRequest>): VerifyDigitalTwinEmailRequest {
        const message = { token: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VerifyDigitalTwinEmailRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyDigitalTwinEmailRequest): VerifyDigitalTwinEmailRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VerifyDigitalTwinEmailRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.VerifyDigitalTwinEmailRequest
 */
export const VerifyDigitalTwinEmailRequest = new VerifyDigitalTwinEmailRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyDigitalTwinEmailResponse$Type extends MessageType<VerifyDigitalTwinEmailResponse> {
    constructor() {
        super("indykite.identity.v1beta1.VerifyDigitalTwinEmailResponse", [
            { no: 1, name: "digital_twin", kind: "message", T: () => DigitalTwin }
        ]);
    }
    create(value?: PartialMessage<VerifyDigitalTwinEmailResponse>): VerifyDigitalTwinEmailResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VerifyDigitalTwinEmailResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyDigitalTwinEmailResponse): VerifyDigitalTwinEmailResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.DigitalTwin digital_twin */ 1:
                    message.digitalTwin = DigitalTwin.internalBinaryRead(reader, reader.uint32(), options, message.digitalTwin);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VerifyDigitalTwinEmailResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.DigitalTwin digital_twin = 1; */
        if (message.digitalTwin)
            DigitalTwin.internalBinaryWrite(message.digitalTwin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.VerifyDigitalTwinEmailResponse
 */
export const VerifyDigitalTwinEmailResponse = new VerifyDigitalTwinEmailResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelfServiceTerminateSessionRequest$Type extends MessageType<SelfServiceTerminateSessionRequest> {
    constructor() {
        super("indykite.identity.v1beta1.SelfServiceTerminateSessionRequest", [
            { no: 1, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SelfServiceTerminateSessionRequest>): SelfServiceTerminateSessionRequest {
        const message = { refreshToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelfServiceTerminateSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelfServiceTerminateSessionRequest): SelfServiceTerminateSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string refresh_token */ 1:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelfServiceTerminateSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string refresh_token = 1; */
        if (message.refreshToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.SelfServiceTerminateSessionRequest
 */
export const SelfServiceTerminateSessionRequest = new SelfServiceTerminateSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelfServiceTerminateSessionResponse$Type extends MessageType<SelfServiceTerminateSessionResponse> {
    constructor() {
        super("indykite.identity.v1beta1.SelfServiceTerminateSessionResponse", []);
    }
    create(value?: PartialMessage<SelfServiceTerminateSessionResponse>): SelfServiceTerminateSessionResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelfServiceTerminateSessionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelfServiceTerminateSessionResponse): SelfServiceTerminateSessionResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SelfServiceTerminateSessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.SelfServiceTerminateSessionResponse
 */
export const SelfServiceTerminateSessionResponse = new SelfServiceTerminateSessionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DigitalTwinIdentifier$Type extends MessageType<DigitalTwinIdentifier> {
    constructor() {
        super("indykite.identity.v1beta1.DigitalTwinIdentifier", [
            { no: 1, name: "digital_twin", kind: "message", oneof: "filter", T: () => DigitalTwin, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "property", kind: "message", oneof: "filter", T: () => Property, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "access_token", kind: "scalar", oneof: "filter", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "20" } } } }
        ]);
    }
    create(value?: PartialMessage<DigitalTwinIdentifier>): DigitalTwinIdentifier {
        const message = { filter: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DigitalTwinIdentifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DigitalTwinIdentifier): DigitalTwinIdentifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.DigitalTwin digital_twin */ 1:
                    message.filter = {
                        oneofKind: "digitalTwin",
                        digitalTwin: DigitalTwin.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).digitalTwin)
                    };
                    break;
                case /* indykite.identity.v1beta1.Property property */ 2:
                    message.filter = {
                        oneofKind: "property",
                        property: Property.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).property)
                    };
                    break;
                case /* string access_token */ 3:
                    message.filter = {
                        oneofKind: "accessToken",
                        accessToken: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DigitalTwinIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.DigitalTwin digital_twin = 1; */
        if (message.filter.oneofKind === "digitalTwin")
            DigitalTwin.internalBinaryWrite(message.filter.digitalTwin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.Property property = 2; */
        if (message.filter.oneofKind === "property")
            Property.internalBinaryWrite(message.filter.property, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string access_token = 3; */
        if (message.filter.oneofKind === "accessToken")
            writer.tag(3, WireType.LengthDelimited).string(message.filter.accessToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.DigitalTwinIdentifier
 */
export const DigitalTwinIdentifier = new DigitalTwinIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDigitalTwinRequest$Type extends MessageType<GetDigitalTwinRequest> {
    constructor() {
        super("indykite.identity.v1beta1.GetDigitalTwinRequest", [
            { no: 1, name: "id", kind: "message", T: () => DigitalTwinIdentifier, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PropertyMask, options: { "validate.rules": { repeated: { items: { message: { required: true } }, ignoreEmpty: true } } } }
        ]);
    }
    create(value?: PartialMessage<GetDigitalTwinRequest>): GetDigitalTwinRequest {
        const message = { properties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDigitalTwinRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDigitalTwinRequest): GetDigitalTwinRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.DigitalTwinIdentifier id */ 1:
                    message.id = DigitalTwinIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* repeated indykite.identity.v1beta1.PropertyMask properties */ 2:
                    message.properties.push(PropertyMask.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDigitalTwinRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.DigitalTwinIdentifier id = 1; */
        if (message.id)
            DigitalTwinIdentifier.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated indykite.identity.v1beta1.PropertyMask properties = 2; */
        for (let i = 0; i < message.properties.length; i++)
            PropertyMask.internalBinaryWrite(message.properties[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.GetDigitalTwinRequest
 */
export const GetDigitalTwinRequest = new GetDigitalTwinRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDigitalTwinResponse$Type extends MessageType<GetDigitalTwinResponse> {
    constructor() {
        super("indykite.identity.v1beta1.GetDigitalTwinResponse", [
            { no: 1, name: "digital_twin", kind: "message", T: () => DigitalEntity },
            { no: 2, name: "token_info", kind: "message", T: () => IdentityTokenInfo }
        ]);
    }
    create(value?: PartialMessage<GetDigitalTwinResponse>): GetDigitalTwinResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDigitalTwinResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDigitalTwinResponse): GetDigitalTwinResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.DigitalEntity digital_twin */ 1:
                    message.digitalTwin = DigitalEntity.internalBinaryRead(reader, reader.uint32(), options, message.digitalTwin);
                    break;
                case /* indykite.identity.v1beta1.IdentityTokenInfo token_info */ 2:
                    message.tokenInfo = IdentityTokenInfo.internalBinaryRead(reader, reader.uint32(), options, message.tokenInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDigitalTwinResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.DigitalEntity digital_twin = 1; */
        if (message.digitalTwin)
            DigitalEntity.internalBinaryWrite(message.digitalTwin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.IdentityTokenInfo token_info = 2; */
        if (message.tokenInfo)
            IdentityTokenInfo.internalBinaryWrite(message.tokenInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.GetDigitalTwinResponse
 */
export const GetDigitalTwinResponse = new GetDigitalTwinResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDigitalTwinsRequest$Type extends MessageType<ListDigitalTwinsRequest> {
    constructor() {
        super("indykite.identity.v1beta1.ListDigitalTwinsRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "validate.rules": { bytes: { len: "16" } } } },
            { no: 2, name: "collection_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "order_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Property }
        ]);
    }
    create(value?: PartialMessage<ListDigitalTwinsRequest>): ListDigitalTwinsRequest {
        const message = { tenantId: new Uint8Array(0), collectionId: "", pageSize: 0, pageToken: "", orderBy: "", properties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListDigitalTwinsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDigitalTwinsRequest): ListDigitalTwinsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes tenant_id */ 1:
                    message.tenantId = reader.bytes();
                    break;
                case /* string collection_id */ 2:
                    message.collectionId = reader.string();
                    break;
                case /* int32 page_size */ 3:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 4:
                    message.pageToken = reader.string();
                    break;
                case /* string order_by */ 5:
                    message.orderBy = reader.string();
                    break;
                case /* repeated indykite.identity.v1beta1.Property properties */ 6:
                    message.properties.push(Property.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDigitalTwinsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes tenant_id = 1; */
        if (message.tenantId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.tenantId);
        /* string collection_id = 2; */
        if (message.collectionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.collectionId);
        /* int32 page_size = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.pageSize);
        /* string page_token = 4; */
        if (message.pageToken !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.pageToken);
        /* string order_by = 5; */
        if (message.orderBy !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.orderBy);
        /* repeated indykite.identity.v1beta1.Property properties = 6; */
        for (let i = 0; i < message.properties.length; i++)
            Property.internalBinaryWrite(message.properties[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ListDigitalTwinsRequest
 */
export const ListDigitalTwinsRequest = new ListDigitalTwinsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDigitalTwinsResponse$Type extends MessageType<ListDigitalTwinsResponse> {
    constructor() {
        super("indykite.identity.v1beta1.ListDigitalTwinsResponse", [
            { no: 1, name: "digital_twin", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DigitalEntity },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListDigitalTwinsResponse>): ListDigitalTwinsResponse {
        const message = { digitalTwin: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListDigitalTwinsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDigitalTwinsResponse): ListDigitalTwinsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated indykite.identity.v1beta1.DigitalEntity digital_twin */ 1:
                    message.digitalTwin.push(DigitalEntity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDigitalTwinsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated indykite.identity.v1beta1.DigitalEntity digital_twin = 1; */
        for (let i = 0; i < message.digitalTwin.length; i++)
            DigitalEntity.internalBinaryWrite(message.digitalTwin[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ListDigitalTwinsResponse
 */
export const ListDigitalTwinsResponse = new ListDigitalTwinsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PatchDigitalTwinRequest$Type extends MessageType<PatchDigitalTwinRequest> {
    constructor() {
        super("indykite.identity.v1beta1.PatchDigitalTwinRequest", [
            { no: 1, name: "id", kind: "message", T: () => DigitalTwinIdentifier, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "operations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PropertyBatchOperation, options: { "validate.rules": { repeated: { minItems: "1", items: { message: { required: true } } } } } },
            { no: 3, name: "admin_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "force_delete", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PatchDigitalTwinRequest>): PatchDigitalTwinRequest {
        const message = { operations: [], adminToken: "", forceDelete: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PatchDigitalTwinRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PatchDigitalTwinRequest): PatchDigitalTwinRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.DigitalTwinIdentifier id */ 1:
                    message.id = DigitalTwinIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* repeated indykite.identity.v1beta1.PropertyBatchOperation operations */ 2:
                    message.operations.push(PropertyBatchOperation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string admin_token */ 3:
                    message.adminToken = reader.string();
                    break;
                case /* bool force_delete */ 4:
                    message.forceDelete = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PatchDigitalTwinRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.DigitalTwinIdentifier id = 1; */
        if (message.id)
            DigitalTwinIdentifier.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated indykite.identity.v1beta1.PropertyBatchOperation operations = 2; */
        for (let i = 0; i < message.operations.length; i++)
            PropertyBatchOperation.internalBinaryWrite(message.operations[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string admin_token = 3; */
        if (message.adminToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.adminToken);
        /* bool force_delete = 4; */
        if (message.forceDelete !== false)
            writer.tag(4, WireType.Varint).bool(message.forceDelete);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.PatchDigitalTwinRequest
 */
export const PatchDigitalTwinRequest = new PatchDigitalTwinRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PatchDigitalTwinResponse$Type extends MessageType<PatchDigitalTwinResponse> {
    constructor() {
        super("indykite.identity.v1beta1.PatchDigitalTwinResponse", [
            { no: 1, name: "result", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BatchOperationResult }
        ]);
    }
    create(value?: PartialMessage<PatchDigitalTwinResponse>): PatchDigitalTwinResponse {
        const message = { result: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PatchDigitalTwinResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PatchDigitalTwinResponse): PatchDigitalTwinResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated indykite.identity.v1beta1.BatchOperationResult result */ 1:
                    message.result.push(BatchOperationResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PatchDigitalTwinResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated indykite.identity.v1beta1.BatchOperationResult result = 1; */
        for (let i = 0; i < message.result.length; i++)
            BatchOperationResult.internalBinaryWrite(message.result[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.PatchDigitalTwinResponse
 */
export const PatchDigitalTwinResponse = new PatchDigitalTwinResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDigitalTwinRequest$Type extends MessageType<DeleteDigitalTwinRequest> {
    constructor() {
        super("indykite.identity.v1beta1.DeleteDigitalTwinRequest", [
            { no: 1, name: "id", kind: "message", T: () => DigitalTwinIdentifier, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "admin_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteDigitalTwinRequest>): DeleteDigitalTwinRequest {
        const message = { adminToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteDigitalTwinRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDigitalTwinRequest): DeleteDigitalTwinRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.DigitalTwinIdentifier id */ 1:
                    message.id = DigitalTwinIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* string admin_token */ 2:
                    message.adminToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteDigitalTwinRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.DigitalTwinIdentifier id = 1; */
        if (message.id)
            DigitalTwinIdentifier.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string admin_token = 2; */
        if (message.adminToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.adminToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.DeleteDigitalTwinRequest
 */
export const DeleteDigitalTwinRequest = new DeleteDigitalTwinRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDigitalTwinResponse$Type extends MessageType<DeleteDigitalTwinResponse> {
    constructor() {
        super("indykite.identity.v1beta1.DeleteDigitalTwinResponse", [
            { no: 1, name: "digital_twin", kind: "message", T: () => DigitalTwin }
        ]);
    }
    create(value?: PartialMessage<DeleteDigitalTwinResponse>): DeleteDigitalTwinResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteDigitalTwinResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDigitalTwinResponse): DeleteDigitalTwinResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.DigitalTwin digital_twin */ 1:
                    message.digitalTwin = DigitalTwin.internalBinaryRead(reader, reader.uint32(), options, message.digitalTwin);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteDigitalTwinResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.DigitalTwin digital_twin = 1; */
        if (message.digitalTwin)
            DigitalTwin.internalBinaryWrite(message.digitalTwin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.DeleteDigitalTwinResponse
 */
export const DeleteDigitalTwinResponse = new DeleteDigitalTwinResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocumentRequest$Type extends MessageType<GetDocumentRequest> {
    constructor() {
        super("indykite.identity.v1beta1.GetDocumentRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "mask", kind: "message", T: () => DocumentMask }
        ]);
    }
    create(value?: PartialMessage<GetDocumentRequest>): GetDocumentRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDocumentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocumentRequest): GetDocumentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* indykite.identity.v1beta1.DocumentMask mask */ 2:
                    message.mask = DocumentMask.internalBinaryRead(reader, reader.uint32(), options, message.mask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocumentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* indykite.identity.v1beta1.DocumentMask mask = 2; */
        if (message.mask)
            DocumentMask.internalBinaryWrite(message.mask, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.GetDocumentRequest
 */
export const GetDocumentRequest = new GetDocumentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocumentResponse$Type extends MessageType<GetDocumentResponse> {
    constructor() {
        super("indykite.identity.v1beta1.GetDocumentResponse", [
            { no: 1, name: "document", kind: "message", T: () => Document }
        ]);
    }
    create(value?: PartialMessage<GetDocumentResponse>): GetDocumentResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDocumentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocumentResponse): GetDocumentResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.Document document */ 1:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocumentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.Document document = 1; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.GetDocumentResponse
 */
export const GetDocumentResponse = new GetDocumentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchGetDocumentsRequest$Type extends MessageType<BatchGetDocumentsRequest> {
    constructor() {
        super("indykite.identity.v1beta1.BatchGetDocumentsRequest", [
            { no: 1, name: "database", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "documents", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "mask", kind: "message", T: () => DocumentMask }
        ]);
    }
    create(value?: PartialMessage<BatchGetDocumentsRequest>): BatchGetDocumentsRequest {
        const message = { database: "", documents: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatchGetDocumentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchGetDocumentsRequest): BatchGetDocumentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string database */ 1:
                    message.database = reader.string();
                    break;
                case /* repeated string documents */ 2:
                    message.documents.push(reader.string());
                    break;
                case /* indykite.identity.v1beta1.DocumentMask mask */ 3:
                    message.mask = DocumentMask.internalBinaryRead(reader, reader.uint32(), options, message.mask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchGetDocumentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string database = 1; */
        if (message.database !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.database);
        /* repeated string documents = 2; */
        for (let i = 0; i < message.documents.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.documents[i]);
        /* indykite.identity.v1beta1.DocumentMask mask = 3; */
        if (message.mask)
            DocumentMask.internalBinaryWrite(message.mask, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.BatchGetDocumentsRequest
 */
export const BatchGetDocumentsRequest = new BatchGetDocumentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchGetDocumentsResponse$Type extends MessageType<BatchGetDocumentsResponse> {
    constructor() {
        super("indykite.identity.v1beta1.BatchGetDocumentsResponse", [
            { no: 1, name: "found", kind: "message", oneof: "result", T: () => Document },
            { no: 2, name: "missing", kind: "scalar", oneof: "result", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BatchGetDocumentsResponse>): BatchGetDocumentsResponse {
        const message = { result: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatchGetDocumentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchGetDocumentsResponse): BatchGetDocumentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.Document found */ 1:
                    message.result = {
                        oneofKind: "found",
                        found: Document.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).found)
                    };
                    break;
                case /* string missing */ 2:
                    message.result = {
                        oneofKind: "missing",
                        missing: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchGetDocumentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.Document found = 1; */
        if (message.result.oneofKind === "found")
            Document.internalBinaryWrite(message.result.found, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string missing = 2; */
        if (message.result.oneofKind === "missing")
            writer.tag(2, WireType.LengthDelimited).string(message.result.missing);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.BatchGetDocumentsResponse
 */
export const BatchGetDocumentsResponse = new BatchGetDocumentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDocumentsRequest$Type extends MessageType<ListDocumentsRequest> {
    constructor() {
        super("indykite.identity.v1beta1.ListDocumentsRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "collection_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "order_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "mask", kind: "message", T: () => DocumentMask }
        ]);
    }
    create(value?: PartialMessage<ListDocumentsRequest>): ListDocumentsRequest {
        const message = { parent: "", collectionId: "", pageSize: 0, pageToken: "", orderBy: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListDocumentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDocumentsRequest): ListDocumentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string collection_id */ 2:
                    message.collectionId = reader.string();
                    break;
                case /* int32 page_size */ 3:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 4:
                    message.pageToken = reader.string();
                    break;
                case /* string order_by */ 6:
                    message.orderBy = reader.string();
                    break;
                case /* indykite.identity.v1beta1.DocumentMask mask */ 7:
                    message.mask = DocumentMask.internalBinaryRead(reader, reader.uint32(), options, message.mask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDocumentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* string collection_id = 2; */
        if (message.collectionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.collectionId);
        /* int32 page_size = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.pageSize);
        /* string page_token = 4; */
        if (message.pageToken !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.pageToken);
        /* string order_by = 6; */
        if (message.orderBy !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.orderBy);
        /* indykite.identity.v1beta1.DocumentMask mask = 7; */
        if (message.mask)
            DocumentMask.internalBinaryWrite(message.mask, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ListDocumentsRequest
 */
export const ListDocumentsRequest = new ListDocumentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDocumentsResponse$Type extends MessageType<ListDocumentsResponse> {
    constructor() {
        super("indykite.identity.v1beta1.ListDocumentsResponse", [
            { no: 1, name: "documents", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Document },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListDocumentsResponse>): ListDocumentsResponse {
        const message = { documents: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListDocumentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDocumentsResponse): ListDocumentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated indykite.identity.v1beta1.Document documents */ 1:
                    message.documents.push(Document.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDocumentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated indykite.identity.v1beta1.Document documents = 1; */
        for (let i = 0; i < message.documents.length; i++)
            Document.internalBinaryWrite(message.documents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ListDocumentsResponse
 */
export const ListDocumentsResponse = new ListDocumentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MutateDocumentsRequest$Type extends MessageType<MutateDocumentsRequest> {
    constructor() {
        super("indykite.identity.v1beta1.MutateDocumentsRequest", [
            { no: 1, name: "database", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "writes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Write }
        ]);
    }
    create(value?: PartialMessage<MutateDocumentsRequest>): MutateDocumentsRequest {
        const message = { database: "", writes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MutateDocumentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MutateDocumentsRequest): MutateDocumentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string database */ 1:
                    message.database = reader.string();
                    break;
                case /* repeated indykite.identity.v1beta1.Write writes */ 2:
                    message.writes.push(Write.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MutateDocumentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string database = 1; */
        if (message.database !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.database);
        /* repeated indykite.identity.v1beta1.Write writes = 2; */
        for (let i = 0; i < message.writes.length; i++)
            Write.internalBinaryWrite(message.writes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.MutateDocumentsRequest
 */
export const MutateDocumentsRequest = new MutateDocumentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MutateDocumentsResponse$Type extends MessageType<MutateDocumentsResponse> {
    constructor() {
        super("indykite.identity.v1beta1.MutateDocumentsResponse", [
            { no: 1, name: "write_results", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WriteResult }
        ]);
    }
    create(value?: PartialMessage<MutateDocumentsResponse>): MutateDocumentsResponse {
        const message = { writeResults: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MutateDocumentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MutateDocumentsResponse): MutateDocumentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated indykite.identity.v1beta1.WriteResult write_results */ 1:
                    message.writeResults.push(WriteResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MutateDocumentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated indykite.identity.v1beta1.WriteResult write_results = 1; */
        for (let i = 0; i < message.writeResults.length; i++)
            WriteResult.internalBinaryWrite(message.writeResults[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.MutateDocumentsResponse
 */
export const MutateDocumentsResponse = new MutateDocumentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunQueryRequest$Type extends MessageType<RunQueryRequest> {
    constructor() {
        super("indykite.identity.v1beta1.RunQueryRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "structured_query", kind: "message", oneof: "queryType", T: () => Value }
        ]);
    }
    create(value?: PartialMessage<RunQueryRequest>): RunQueryRequest {
        const message = { parent: "", queryType: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RunQueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunQueryRequest): RunQueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* indykite.objects.v1beta1.Value structured_query */ 2:
                    message.queryType = {
                        oneofKind: "structuredQuery",
                        structuredQuery: Value.internalBinaryRead(reader, reader.uint32(), options, (message.queryType as any).structuredQuery)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunQueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* indykite.objects.v1beta1.Value structured_query = 2; */
        if (message.queryType.oneofKind === "structuredQuery")
            Value.internalBinaryWrite(message.queryType.structuredQuery, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.RunQueryRequest
 */
export const RunQueryRequest = new RunQueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunQueryResponse$Type extends MessageType<RunQueryResponse> {
    constructor() {
        super("indykite.identity.v1beta1.RunQueryResponse", [
            { no: 1, name: "document", kind: "message", T: () => Document },
            { no: 4, name: "skipped_results", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RunQueryResponse>): RunQueryResponse {
        const message = { skippedResults: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RunQueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunQueryResponse): RunQueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.Document document */ 1:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                case /* int32 skipped_results */ 4:
                    message.skippedResults = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunQueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.Document document = 1; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 skipped_results = 4; */
        if (message.skippedResults !== 0)
            writer.tag(4, WireType.Varint).int32(message.skippedResults);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.RunQueryResponse
 */
export const RunQueryResponse = new RunQueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPasswordCredentialRequest$Type extends MessageType<GetPasswordCredentialRequest> {
    constructor() {
        super("indykite.identity.v1beta1.GetPasswordCredentialRequest", [
            { no: 1, name: "digital_twin", kind: "message", T: () => DigitalTwin }
        ]);
    }
    create(value?: PartialMessage<GetPasswordCredentialRequest>): GetPasswordCredentialRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPasswordCredentialRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPasswordCredentialRequest): GetPasswordCredentialRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.DigitalTwin digital_twin */ 1:
                    message.digitalTwin = DigitalTwin.internalBinaryRead(reader, reader.uint32(), options, message.digitalTwin);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPasswordCredentialRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.DigitalTwin digital_twin = 1; */
        if (message.digitalTwin)
            DigitalTwin.internalBinaryWrite(message.digitalTwin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.GetPasswordCredentialRequest
 */
export const GetPasswordCredentialRequest = new GetPasswordCredentialRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPasswordCredentialResponse$Type extends MessageType<GetPasswordCredentialResponse> {
    constructor() {
        super("indykite.identity.v1beta1.GetPasswordCredentialResponse", []);
    }
    create(value?: PartialMessage<GetPasswordCredentialResponse>): GetPasswordCredentialResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPasswordCredentialResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPasswordCredentialResponse): GetPasswordCredentialResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetPasswordCredentialResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.GetPasswordCredentialResponse
 */
export const GetPasswordCredentialResponse = new GetPasswordCredentialResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePasswordCredentialRequest$Type extends MessageType<UpdatePasswordCredentialRequest> {
    constructor() {
        super("indykite.identity.v1beta1.UpdatePasswordCredentialRequest", [
            { no: 1, name: "login_properties", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "must_change", kind: "message", T: () => BoolValue },
            { no: 5, name: "locked", kind: "message", T: () => BoolValue },
            { no: 3, name: "email", kind: "scalar", oneof: "primary", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "mobile", kind: "scalar", oneof: "primary", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdatePasswordCredentialRequest>): UpdatePasswordCredentialRequest {
        const message = { loginProperties: [], primary: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdatePasswordCredentialRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePasswordCredentialRequest): UpdatePasswordCredentialRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes login_properties */ 1:
                    message.loginProperties.push(reader.bytes());
                    break;
                case /* google.protobuf.BoolValue must_change */ 2:
                    message.mustChange = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.mustChange);
                    break;
                case /* google.protobuf.BoolValue locked */ 5:
                    message.locked = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.locked);
                    break;
                case /* string email */ 3:
                    message.primary = {
                        oneofKind: "email",
                        email: reader.string()
                    };
                    break;
                case /* string mobile */ 4:
                    message.primary = {
                        oneofKind: "mobile",
                        mobile: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePasswordCredentialRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes login_properties = 1; */
        for (let i = 0; i < message.loginProperties.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.loginProperties[i]);
        /* google.protobuf.BoolValue must_change = 2; */
        if (message.mustChange)
            BoolValue.internalBinaryWrite(message.mustChange, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue locked = 5; */
        if (message.locked)
            BoolValue.internalBinaryWrite(message.locked, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string email = 3; */
        if (message.primary.oneofKind === "email")
            writer.tag(3, WireType.LengthDelimited).string(message.primary.email);
        /* string mobile = 4; */
        if (message.primary.oneofKind === "mobile")
            writer.tag(4, WireType.LengthDelimited).string(message.primary.mobile);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.UpdatePasswordCredentialRequest
 */
export const UpdatePasswordCredentialRequest = new UpdatePasswordCredentialRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePasswordCredentialResponse$Type extends MessageType<UpdatePasswordCredentialResponse> {
    constructor() {
        super("indykite.identity.v1beta1.UpdatePasswordCredentialResponse", []);
    }
    create(value?: PartialMessage<UpdatePasswordCredentialResponse>): UpdatePasswordCredentialResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdatePasswordCredentialResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePasswordCredentialResponse): UpdatePasswordCredentialResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdatePasswordCredentialResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.UpdatePasswordCredentialResponse
 */
export const UpdatePasswordCredentialResponse = new UpdatePasswordCredentialResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Error$Type extends MessageType<Error> {
    constructor() {
        super("indykite.identity.v1beta1.Error", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Error>): Error {
        const message = { code: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Error>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Error): Error {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Error, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.Error
 */
export const Error = new Error$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelfServiceChangePasswordRequest$Type extends MessageType<SelfServiceChangePasswordRequest> {
    constructor() {
        super("indykite.identity.v1beta1.SelfServiceChangePasswordRequest", [
            { no: 1, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SelfServiceChangePasswordRequest>): SelfServiceChangePasswordRequest {
        const message = { password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelfServiceChangePasswordRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelfServiceChangePasswordRequest): SelfServiceChangePasswordRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string password */ 1:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelfServiceChangePasswordRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string password = 1; */
        if (message.password !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.SelfServiceChangePasswordRequest
 */
export const SelfServiceChangePasswordRequest = new SelfServiceChangePasswordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelfServiceChangePasswordResponse$Type extends MessageType<SelfServiceChangePasswordResponse> {
    constructor() {
        super("indykite.identity.v1beta1.SelfServiceChangePasswordResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SelfServiceChangePasswordResponse>): SelfServiceChangePasswordResponse {
        const message = { success: false, error: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelfServiceChangePasswordResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelfServiceChangePasswordResponse): SelfServiceChangePasswordResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelfServiceChangePasswordResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.SelfServiceChangePasswordResponse
 */
export const SelfServiceChangePasswordResponse = new SelfServiceChangePasswordResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateInvitationRequest$Type extends MessageType<CreateInvitationRequest> {
    constructor() {
        super("indykite.identity.v1beta1.CreateInvitationRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "validate.rules": { bytes: { len: "16" } } } },
            { no: 2, name: "reference_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "10", maxLen: "100", pattern: "^[A-Za-z0-9-_]{10,100}$" } } } },
            { no: 3, name: "invite_at_time", kind: "message", T: () => Timestamp, options: { "validate.rules": { timestamp: { required: false, gtNow: true } } } },
            { no: 4, name: "expire_time", kind: "message", T: () => Timestamp, options: { "validate.rules": { timestamp: { required: false, gtNow: true } } } },
            { no: 5, name: "message_attributes", kind: "message", T: () => MapValue },
            { no: 6, name: "email", kind: "scalar", oneof: "invitee", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "5", maxLen: "255", email: true } } } },
            { no: 7, name: "mobile", kind: "scalar", oneof: "invitee", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateInvitationRequest>): CreateInvitationRequest {
        const message = { tenantId: new Uint8Array(0), referenceId: "", invitee: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateInvitationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateInvitationRequest): CreateInvitationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes tenant_id */ 1:
                    message.tenantId = reader.bytes();
                    break;
                case /* string reference_id */ 2:
                    message.referenceId = reader.string();
                    break;
                case /* google.protobuf.Timestamp invite_at_time */ 3:
                    message.inviteAtTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.inviteAtTime);
                    break;
                case /* google.protobuf.Timestamp expire_time */ 4:
                    message.expireTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expireTime);
                    break;
                case /* indykite.objects.v1beta1.MapValue message_attributes */ 5:
                    message.messageAttributes = MapValue.internalBinaryRead(reader, reader.uint32(), options, message.messageAttributes);
                    break;
                case /* string email */ 6:
                    message.invitee = {
                        oneofKind: "email",
                        email: reader.string()
                    };
                    break;
                case /* string mobile */ 7:
                    message.invitee = {
                        oneofKind: "mobile",
                        mobile: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateInvitationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes tenant_id = 1; */
        if (message.tenantId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.tenantId);
        /* string reference_id = 2; */
        if (message.referenceId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.referenceId);
        /* google.protobuf.Timestamp invite_at_time = 3; */
        if (message.inviteAtTime)
            Timestamp.internalBinaryWrite(message.inviteAtTime, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp expire_time = 4; */
        if (message.expireTime)
            Timestamp.internalBinaryWrite(message.expireTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* indykite.objects.v1beta1.MapValue message_attributes = 5; */
        if (message.messageAttributes)
            MapValue.internalBinaryWrite(message.messageAttributes, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string email = 6; */
        if (message.invitee.oneofKind === "email")
            writer.tag(6, WireType.LengthDelimited).string(message.invitee.email);
        /* string mobile = 7; */
        if (message.invitee.oneofKind === "mobile")
            writer.tag(7, WireType.LengthDelimited).string(message.invitee.mobile);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.CreateInvitationRequest
 */
export const CreateInvitationRequest = new CreateInvitationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateInvitationResponse$Type extends MessageType<CreateInvitationResponse> {
    constructor() {
        super("indykite.identity.v1beta1.CreateInvitationResponse", []);
    }
    create(value?: PartialMessage<CreateInvitationResponse>): CreateInvitationResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateInvitationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateInvitationResponse): CreateInvitationResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CreateInvitationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.CreateInvitationResponse
 */
export const CreateInvitationResponse = new CreateInvitationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckInvitationStateRequest$Type extends MessageType<CheckInvitationStateRequest> {
    constructor() {
        super("indykite.identity.v1beta1.CheckInvitationStateRequest", [
            { no: 1, name: "reference_id", kind: "scalar", oneof: "identifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "10", maxLen: "100", pattern: "^[A-Za-z0-9-_]{10,100}$" } } } },
            { no: 2, name: "invitation_token", kind: "scalar", oneof: "identifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "10", maxLen: "2048" } } } }
        ]);
    }
    create(value?: PartialMessage<CheckInvitationStateRequest>): CheckInvitationStateRequest {
        const message = { identifier: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckInvitationStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckInvitationStateRequest): CheckInvitationStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reference_id */ 1:
                    message.identifier = {
                        oneofKind: "referenceId",
                        referenceId: reader.string()
                    };
                    break;
                case /* string invitation_token */ 2:
                    message.identifier = {
                        oneofKind: "invitationToken",
                        invitationToken: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckInvitationStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reference_id = 1; */
        if (message.identifier.oneofKind === "referenceId")
            writer.tag(1, WireType.LengthDelimited).string(message.identifier.referenceId);
        /* string invitation_token = 2; */
        if (message.identifier.oneofKind === "invitationToken")
            writer.tag(2, WireType.LengthDelimited).string(message.identifier.invitationToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.CheckInvitationStateRequest
 */
export const CheckInvitationStateRequest = new CheckInvitationStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckInvitationStateResponse$Type extends MessageType<CheckInvitationStateResponse> {
    constructor() {
        super("indykite.identity.v1beta1.CheckInvitationStateResponse", [
            { no: 1, name: "invitation", kind: "message", T: () => Invitation }
        ]);
    }
    create(value?: PartialMessage<CheckInvitationStateResponse>): CheckInvitationStateResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckInvitationStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckInvitationStateResponse): CheckInvitationStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.Invitation invitation */ 1:
                    message.invitation = Invitation.internalBinaryRead(reader, reader.uint32(), options, message.invitation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckInvitationStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.Invitation invitation = 1; */
        if (message.invitation)
            Invitation.internalBinaryWrite(message.invitation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.CheckInvitationStateResponse
 */
export const CheckInvitationStateResponse = new CheckInvitationStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResendInvitationRequest$Type extends MessageType<ResendInvitationRequest> {
    constructor() {
        super("indykite.identity.v1beta1.ResendInvitationRequest", [
            { no: 1, name: "reference_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "10", maxLen: "100", pattern: "^[A-Za-z0-9-_]{10,100}$" } } } }
        ]);
    }
    create(value?: PartialMessage<ResendInvitationRequest>): ResendInvitationRequest {
        const message = { referenceId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResendInvitationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResendInvitationRequest): ResendInvitationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reference_id */ 1:
                    message.referenceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResendInvitationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reference_id = 1; */
        if (message.referenceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.referenceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ResendInvitationRequest
 */
export const ResendInvitationRequest = new ResendInvitationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResendInvitationResponse$Type extends MessageType<ResendInvitationResponse> {
    constructor() {
        super("indykite.identity.v1beta1.ResendInvitationResponse", []);
    }
    create(value?: PartialMessage<ResendInvitationResponse>): ResendInvitationResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResendInvitationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResendInvitationResponse): ResendInvitationResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ResendInvitationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ResendInvitationResponse
 */
export const ResendInvitationResponse = new ResendInvitationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelInvitationRequest$Type extends MessageType<CancelInvitationRequest> {
    constructor() {
        super("indykite.identity.v1beta1.CancelInvitationRequest", [
            { no: 1, name: "reference_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "10", maxLen: "100", pattern: "^[A-Za-z0-9-_]{10,100}$" } } } }
        ]);
    }
    create(value?: PartialMessage<CancelInvitationRequest>): CancelInvitationRequest {
        const message = { referenceId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CancelInvitationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelInvitationRequest): CancelInvitationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reference_id */ 1:
                    message.referenceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelInvitationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reference_id = 1; */
        if (message.referenceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.referenceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.CancelInvitationRequest
 */
export const CancelInvitationRequest = new CancelInvitationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelInvitationResponse$Type extends MessageType<CancelInvitationResponse> {
    constructor() {
        super("indykite.identity.v1beta1.CancelInvitationResponse", []);
    }
    create(value?: PartialMessage<CancelInvitationResponse>): CancelInvitationResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CancelInvitationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelInvitationResponse): CancelInvitationResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CancelInvitationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.CancelInvitationResponse
 */
export const CancelInvitationResponse = new CancelInvitationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckConsentChallengeRequest$Type extends MessageType<CheckConsentChallengeRequest> {
    constructor() {
        super("indykite.identity.v1beta1.CheckConsentChallengeRequest", [
            { no: 1, name: "challenge", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { len: "22" } } } }
        ]);
    }
    create(value?: PartialMessage<CheckConsentChallengeRequest>): CheckConsentChallengeRequest {
        const message = { challenge: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckConsentChallengeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckConsentChallengeRequest): CheckConsentChallengeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string challenge */ 1:
                    message.challenge = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckConsentChallengeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string challenge = 1; */
        if (message.challenge !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.challenge);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.CheckConsentChallengeRequest
 */
export const CheckConsentChallengeRequest = new CheckConsentChallengeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckConsentChallengeResponse$Type extends MessageType<CheckConsentChallengeResponse> {
    constructor() {
        super("indykite.identity.v1beta1.CheckConsentChallengeResponse", [
            { no: 1, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "app_space_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "audiences", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AudienceItem },
            { no: 4, name: "scopes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScopeItem },
            { no: 5, name: "acrs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "request_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "skip", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "digital_twin", kind: "message", T: () => DigitalTwin },
            { no: 9, name: "subject_identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "authenticated_at", kind: "message", T: () => Timestamp },
            { no: 11, name: "requested_at", kind: "message", T: () => Timestamp },
            { no: 12, name: "context", kind: "message", T: () => MapValue }
        ]);
    }
    create(value?: PartialMessage<CheckConsentChallengeResponse>): CheckConsentChallengeResponse {
        const message = { clientId: "", appSpaceId: new Uint8Array(0), audiences: [], scopes: [], acrs: [], requestUrl: "", skip: false, subjectIdentifier: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckConsentChallengeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckConsentChallengeResponse): CheckConsentChallengeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string client_id */ 1:
                    message.clientId = reader.string();
                    break;
                case /* bytes app_space_id */ 2:
                    message.appSpaceId = reader.bytes();
                    break;
                case /* repeated indykite.identity.v1beta1.AudienceItem audiences */ 3:
                    message.audiences.push(AudienceItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated indykite.identity.v1beta1.ScopeItem scopes */ 4:
                    message.scopes.push(ScopeItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string acrs */ 5:
                    message.acrs.push(reader.string());
                    break;
                case /* string request_url */ 6:
                    message.requestUrl = reader.string();
                    break;
                case /* bool skip */ 7:
                    message.skip = reader.bool();
                    break;
                case /* indykite.identity.v1beta1.DigitalTwin digital_twin */ 8:
                    message.digitalTwin = DigitalTwin.internalBinaryRead(reader, reader.uint32(), options, message.digitalTwin);
                    break;
                case /* string subject_identifier */ 9:
                    message.subjectIdentifier = reader.string();
                    break;
                case /* google.protobuf.Timestamp authenticated_at */ 10:
                    message.authenticatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.authenticatedAt);
                    break;
                case /* google.protobuf.Timestamp requested_at */ 11:
                    message.requestedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.requestedAt);
                    break;
                case /* indykite.objects.v1beta1.MapValue context */ 12:
                    message.context = MapValue.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckConsentChallengeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string client_id = 1; */
        if (message.clientId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientId);
        /* bytes app_space_id = 2; */
        if (message.appSpaceId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.appSpaceId);
        /* repeated indykite.identity.v1beta1.AudienceItem audiences = 3; */
        for (let i = 0; i < message.audiences.length; i++)
            AudienceItem.internalBinaryWrite(message.audiences[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated indykite.identity.v1beta1.ScopeItem scopes = 4; */
        for (let i = 0; i < message.scopes.length; i++)
            ScopeItem.internalBinaryWrite(message.scopes[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string acrs = 5; */
        for (let i = 0; i < message.acrs.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.acrs[i]);
        /* string request_url = 6; */
        if (message.requestUrl !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.requestUrl);
        /* bool skip = 7; */
        if (message.skip !== false)
            writer.tag(7, WireType.Varint).bool(message.skip);
        /* indykite.identity.v1beta1.DigitalTwin digital_twin = 8; */
        if (message.digitalTwin)
            DigitalTwin.internalBinaryWrite(message.digitalTwin, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string subject_identifier = 9; */
        if (message.subjectIdentifier !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.subjectIdentifier);
        /* google.protobuf.Timestamp authenticated_at = 10; */
        if (message.authenticatedAt)
            Timestamp.internalBinaryWrite(message.authenticatedAt, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp requested_at = 11; */
        if (message.requestedAt)
            Timestamp.internalBinaryWrite(message.requestedAt, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* indykite.objects.v1beta1.MapValue context = 12; */
        if (message.context)
            MapValue.internalBinaryWrite(message.context, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.CheckConsentChallengeResponse
 */
export const CheckConsentChallengeResponse = new CheckConsentChallengeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopeItem$Type extends MessageType<ScopeItem> {
    constructor() {
        super("indykite.identity.v1beta1.ScopeItem", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ScopeItem>): ScopeItem {
        const message = { name: "", displayName: "", description: "", required: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScopeItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopeItem): ScopeItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string display_name */ 2:
                    message.displayName = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* bool required */ 4:
                    message.required = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopeItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string display_name = 2; */
        if (message.displayName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.displayName);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* bool required = 4; */
        if (message.required !== false)
            writer.tag(4, WireType.Varint).bool(message.required);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ScopeItem
 */
export const ScopeItem = new ScopeItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AudienceItem$Type extends MessageType<AudienceItem> {
    constructor() {
        super("indykite.identity.v1beta1.AudienceItem", [
            { no: 1, name: "user_support_email_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "logo_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "homepage_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "privacy_policy_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "tos_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AudienceItem>): AudienceItem {
        const message = { userSupportEmailAddress: "", clientId: "", displayName: "", description: "", logoUrl: "", homepageUrl: "", privacyPolicyUrl: "", tosUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AudienceItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AudienceItem): AudienceItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_support_email_address */ 1:
                    message.userSupportEmailAddress = reader.string();
                    break;
                case /* string client_id */ 2:
                    message.clientId = reader.string();
                    break;
                case /* string display_name */ 3:
                    message.displayName = reader.string();
                    break;
                case /* string description */ 4:
                    message.description = reader.string();
                    break;
                case /* string logo_url */ 5:
                    message.logoUrl = reader.string();
                    break;
                case /* string homepage_url */ 6:
                    message.homepageUrl = reader.string();
                    break;
                case /* string privacy_policy_url */ 7:
                    message.privacyPolicyUrl = reader.string();
                    break;
                case /* string tos_url */ 8:
                    message.tosUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AudienceItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_support_email_address = 1; */
        if (message.userSupportEmailAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userSupportEmailAddress);
        /* string client_id = 2; */
        if (message.clientId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clientId);
        /* string display_name = 3; */
        if (message.displayName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        /* string description = 4; */
        if (message.description !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* string logo_url = 5; */
        if (message.logoUrl !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.logoUrl);
        /* string homepage_url = 6; */
        if (message.homepageUrl !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.homepageUrl);
        /* string privacy_policy_url = 7; */
        if (message.privacyPolicyUrl !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.privacyPolicyUrl);
        /* string tos_url = 8; */
        if (message.tosUrl !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.tosUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.AudienceItem
 */
export const AudienceItem = new AudienceItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateConsentVerifierRequest$Type extends MessageType<CreateConsentVerifierRequest> {
    constructor() {
        super("indykite.identity.v1beta1.CreateConsentVerifierRequest", [
            { no: 1, name: "challenge", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { len: "22" } } } },
            { no: 2, name: "approval", kind: "message", oneof: "result", T: () => ConsentApproval },
            { no: 3, name: "denial", kind: "message", oneof: "result", T: () => DenialResponse }
        ]);
    }
    create(value?: PartialMessage<CreateConsentVerifierRequest>): CreateConsentVerifierRequest {
        const message = { challenge: "", result: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateConsentVerifierRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateConsentVerifierRequest): CreateConsentVerifierRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string challenge */ 1:
                    message.challenge = reader.string();
                    break;
                case /* indykite.identity.v1beta1.ConsentApproval approval */ 2:
                    message.result = {
                        oneofKind: "approval",
                        approval: ConsentApproval.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).approval)
                    };
                    break;
                case /* indykite.identity.v1beta1.DenialResponse denial */ 3:
                    message.result = {
                        oneofKind: "denial",
                        denial: DenialResponse.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).denial)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateConsentVerifierRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string challenge = 1; */
        if (message.challenge !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.challenge);
        /* indykite.identity.v1beta1.ConsentApproval approval = 2; */
        if (message.result.oneofKind === "approval")
            ConsentApproval.internalBinaryWrite(message.result.approval, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.DenialResponse denial = 3; */
        if (message.result.oneofKind === "denial")
            DenialResponse.internalBinaryWrite(message.result.denial, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.CreateConsentVerifierRequest
 */
export const CreateConsentVerifierRequest = new CreateConsentVerifierRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateConsentVerifierResponse$Type extends MessageType<CreateConsentVerifierResponse> {
    constructor() {
        super("indykite.identity.v1beta1.CreateConsentVerifierResponse", [
            { no: 1, name: "verifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "authorization_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateConsentVerifierResponse>): CreateConsentVerifierResponse {
        const message = { verifier: "", authorizationEndpoint: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateConsentVerifierResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateConsentVerifierResponse): CreateConsentVerifierResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string verifier */ 1:
                    message.verifier = reader.string();
                    break;
                case /* string authorization_endpoint */ 2:
                    message.authorizationEndpoint = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateConsentVerifierResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string verifier = 1; */
        if (message.verifier !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.verifier);
        /* string authorization_endpoint = 2; */
        if (message.authorizationEndpoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.authorizationEndpoint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.CreateConsentVerifierResponse
 */
export const CreateConsentVerifierResponse = new CreateConsentVerifierResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConsentApproval$Type extends MessageType<ConsentApproval> {
    constructor() {
        super("indykite.identity.v1beta1.ConsentApproval", [
            { no: 1, name: "grant_scopes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { minItems: "1", unique: true } } } },
            { no: 2, name: "granted_audiences", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { unique: true } } } },
            { no: 3, name: "session", kind: "message", T: () => ConsentRequestSessionData },
            { no: 4, name: "remember", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "remember_for", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<ConsentApproval>): ConsentApproval {
        const message = { grantScopes: [], grantedAudiences: [], remember: false, rememberFor: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConsentApproval>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsentApproval): ConsentApproval {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string grant_scopes */ 1:
                    message.grantScopes.push(reader.string());
                    break;
                case /* repeated string granted_audiences */ 2:
                    message.grantedAudiences.push(reader.string());
                    break;
                case /* indykite.identity.v1beta1.ConsentRequestSessionData session */ 3:
                    message.session = ConsentRequestSessionData.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* bool remember */ 4:
                    message.remember = reader.bool();
                    break;
                case /* int64 remember_for */ 5:
                    message.rememberFor = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConsentApproval, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string grant_scopes = 1; */
        for (let i = 0; i < message.grantScopes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.grantScopes[i]);
        /* repeated string granted_audiences = 2; */
        for (let i = 0; i < message.grantedAudiences.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.grantedAudiences[i]);
        /* indykite.identity.v1beta1.ConsentRequestSessionData session = 3; */
        if (message.session)
            ConsentRequestSessionData.internalBinaryWrite(message.session, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool remember = 4; */
        if (message.remember !== false)
            writer.tag(4, WireType.Varint).bool(message.remember);
        /* int64 remember_for = 5; */
        if (message.rememberFor !== "0")
            writer.tag(5, WireType.Varint).int64(message.rememberFor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ConsentApproval
 */
export const ConsentApproval = new ConsentApproval$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConsentRequestSessionData$Type extends MessageType<ConsentRequestSessionData> {
    constructor() {
        super("indykite.identity.v1beta1.ConsentRequestSessionData", [
            { no: 1, name: "access_token", kind: "message", T: () => MapValue },
            { no: 2, name: "id_token", kind: "message", T: () => MapValue },
            { no: 3, name: "userinfo", kind: "message", T: () => MapValue }
        ]);
    }
    create(value?: PartialMessage<ConsentRequestSessionData>): ConsentRequestSessionData {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConsentRequestSessionData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsentRequestSessionData): ConsentRequestSessionData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.objects.v1beta1.MapValue access_token */ 1:
                    message.accessToken = MapValue.internalBinaryRead(reader, reader.uint32(), options, message.accessToken);
                    break;
                case /* indykite.objects.v1beta1.MapValue id_token */ 2:
                    message.idToken = MapValue.internalBinaryRead(reader, reader.uint32(), options, message.idToken);
                    break;
                case /* indykite.objects.v1beta1.MapValue userinfo */ 3:
                    message.userinfo = MapValue.internalBinaryRead(reader, reader.uint32(), options, message.userinfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConsentRequestSessionData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.objects.v1beta1.MapValue access_token = 1; */
        if (message.accessToken)
            MapValue.internalBinaryWrite(message.accessToken, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* indykite.objects.v1beta1.MapValue id_token = 2; */
        if (message.idToken)
            MapValue.internalBinaryWrite(message.idToken, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* indykite.objects.v1beta1.MapValue userinfo = 3; */
        if (message.userinfo)
            MapValue.internalBinaryWrite(message.userinfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ConsentRequestSessionData
 */
export const ConsentRequestSessionData = new ConsentRequestSessionData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DenialResponse$Type extends MessageType<DenialResponse> {
    constructor() {
        super("indykite.identity.v1beta1.DenialResponse", [
            { no: 1, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { pattern: "^[ !#-\\[\\]-~]+$", ignoreEmpty: true } } } },
            { no: 2, name: "error_description", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { pattern: "^[ !#-\\[\\]-~]+$", ignoreEmpty: true } } } },
            { no: 3, name: "error_hint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "status_code", kind: "scalar", T: 3 /*ScalarType.INT64*/, options: { "validate.rules": { int64: { in: ["400", "401", "403", "408", "409", "410", "412", "422", "429", "451"], ignoreEmpty: true } } } }
        ]);
    }
    create(value?: PartialMessage<DenialResponse>): DenialResponse {
        const message = { error: "", errorDescription: "", errorHint: "", statusCode: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DenialResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DenialResponse): DenialResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error */ 1:
                    message.error = reader.string();
                    break;
                case /* string error_description */ 2:
                    message.errorDescription = reader.string();
                    break;
                case /* string error_hint */ 3:
                    message.errorHint = reader.string();
                    break;
                case /* int64 status_code */ 4:
                    message.statusCode = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DenialResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error = 1; */
        if (message.error !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.error);
        /* string error_description = 2; */
        if (message.errorDescription !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errorDescription);
        /* string error_hint = 3; */
        if (message.errorHint !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.errorHint);
        /* int64 status_code = 4; */
        if (message.statusCode !== "0")
            writer.tag(4, WireType.Varint).int64(message.statusCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.DenialResponse
 */
export const DenialResponse = new DenialResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccessTokenRequest$Type extends MessageType<GetAccessTokenRequest> {
    constructor() {
        super("indykite.identity.v1beta1.GetAccessTokenRequest", [
            { no: 1, name: "app_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "provider_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "provider_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "subject_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "scopes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "offline_access", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetAccessTokenRequest>): GetAccessTokenRequest {
        const message = { appId: "", providerId: "", providerName: "", subjectId: "", scopes: [], offlineAccess: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAccessTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccessTokenRequest): GetAccessTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string app_id */ 1:
                    message.appId = reader.string();
                    break;
                case /* string provider_id */ 2:
                    message.providerId = reader.string();
                    break;
                case /* string provider_name */ 4:
                    message.providerName = reader.string();
                    break;
                case /* string subject_id */ 5:
                    message.subjectId = reader.string();
                    break;
                case /* repeated string scopes */ 6:
                    message.scopes.push(reader.string());
                    break;
                case /* bool offline_access */ 7:
                    message.offlineAccess = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccessTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string app_id = 1; */
        if (message.appId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.appId);
        /* string provider_id = 2; */
        if (message.providerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.providerId);
        /* string provider_name = 4; */
        if (message.providerName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.providerName);
        /* string subject_id = 5; */
        if (message.subjectId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.subjectId);
        /* repeated string scopes = 6; */
        for (let i = 0; i < message.scopes.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.scopes[i]);
        /* bool offline_access = 7; */
        if (message.offlineAccess !== false)
            writer.tag(7, WireType.Varint).bool(message.offlineAccess);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.GetAccessTokenRequest
 */
export const GetAccessTokenRequest = new GetAccessTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccessTokenResponse$Type extends MessageType<GetAccessTokenResponse> {
    constructor() {
        super("indykite.identity.v1beta1.GetAccessTokenResponse", [
            { no: 1, name: "token", kind: "message", T: () => OAuth2TokenResponse }
        ]);
    }
    create(value?: PartialMessage<GetAccessTokenResponse>): GetAccessTokenResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAccessTokenResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccessTokenResponse): GetAccessTokenResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.OAuth2TokenResponse token */ 1:
                    message.token = OAuth2TokenResponse.internalBinaryRead(reader, reader.uint32(), options, message.token);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccessTokenResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.OAuth2TokenResponse token = 1; */
        if (message.token)
            OAuth2TokenResponse.internalBinaryWrite(message.token, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.GetAccessTokenResponse
 */
export const GetAccessTokenResponse = new GetAccessTokenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionIntrospectRequest$Type extends MessageType<SessionIntrospectRequest> {
    constructor() {
        super("indykite.identity.v1beta1.SessionIntrospectRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SessionIntrospectRequest>): SessionIntrospectRequest {
        const message = { tenantId: new Uint8Array(0), token: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SessionIntrospectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionIntrospectRequest): SessionIntrospectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes tenant_id */ 1:
                    message.tenantId = reader.bytes();
                    break;
                case /* string token */ 2:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionIntrospectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes tenant_id = 1; */
        if (message.tenantId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.tenantId);
        /* string token = 2; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.SessionIntrospectRequest
 */
export const SessionIntrospectRequest = new SessionIntrospectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionIntrospectResponse$Type extends MessageType<SessionIntrospectResponse> {
    constructor() {
        super("indykite.identity.v1beta1.SessionIntrospectResponse", [
            { no: 1, name: "active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "token_info", kind: "message", T: () => IdentityTokenInfo },
            { no: 3, name: "provider_data", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SessionIntrospectResponse>): SessionIntrospectResponse {
        const message = { active: false, providerData: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SessionIntrospectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionIntrospectResponse): SessionIntrospectResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool active */ 1:
                    message.active = reader.bool();
                    break;
                case /* indykite.identity.v1beta1.IdentityTokenInfo token_info */ 2:
                    message.tokenInfo = IdentityTokenInfo.internalBinaryRead(reader, reader.uint32(), options, message.tokenInfo);
                    break;
                case /* repeated string provider_data */ 3:
                    message.providerData.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionIntrospectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool active = 1; */
        if (message.active !== false)
            writer.tag(1, WireType.Varint).bool(message.active);
        /* indykite.identity.v1beta1.IdentityTokenInfo token_info = 2; */
        if (message.tokenInfo)
            IdentityTokenInfo.internalBinaryWrite(message.tokenInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string provider_data = 3; */
        for (let i = 0; i < message.providerData.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.providerData[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.SessionIntrospectResponse
 */
export const SessionIntrospectResponse = new SessionIntrospectResponse$Type();
/**
 * @generated ServiceType for protobuf service indykite.identity.v1beta1.IdentityManagementAPI
 */
export const IdentityManagementAPI = new ServiceType("indykite.identity.v1beta1.IdentityManagementAPI", [
    { name: "TokenIntrospect", options: { "google.api.http": { post: "/identity/token/introspect", body: "*", additionalBindings: [{ get: "/identity/token/introspect/{token}" }] } }, I: TokenIntrospectRequest, O: TokenIntrospectResponse },
    { name: "StartForgottenPasswordFlow", options: {}, I: StartForgottenPasswordFlowRequest, O: StartForgottenPasswordFlowResponse },
    { name: "ChangePassword", options: {}, I: ChangePasswordRequest, O: ChangePasswordResponse },
    { name: "StartDigitalTwinEmailVerification", options: { "google.api.http": { post: "/identity/email/startVerification", body: "*" } }, I: StartDigitalTwinEmailVerificationRequest, O: StartDigitalTwinEmailVerificationResponse },
    { name: "VerifyDigitalTwinEmail", options: { "google.api.http": { post: "/identity/email/verify/{token}", body: "*", additionalBindings: [{ get: "/identity/email/verify/{token}" }] } }, I: VerifyDigitalTwinEmailRequest, O: VerifyDigitalTwinEmailResponse },
    { name: "SelfServiceTerminateSession", options: { "google.api.http": { post: "/identity/self-service/terminate-session", body: "*", additionalBindings: [{ get: "/identity/self-service/terminate-session" }] } }, I: SelfServiceTerminateSessionRequest, O: SelfServiceTerminateSessionResponse },
    { name: "GetDigitalTwin", options: {}, I: GetDigitalTwinRequest, O: GetDigitalTwinResponse },
    { name: "ListDigitalTwins", options: {}, I: ListDigitalTwinsRequest, O: ListDigitalTwinsResponse },
    { name: "PatchDigitalTwin", options: {}, I: PatchDigitalTwinRequest, O: PatchDigitalTwinResponse },
    { name: "DeleteDigitalTwin", options: {}, I: DeleteDigitalTwinRequest, O: DeleteDigitalTwinResponse },
    { name: "GetDocument", options: { "google.api.http": { get: "/identity/document/v1/{name=databases/*/documents/*/**}" } }, I: GetDocumentRequest, O: GetDocumentResponse },
    { name: "BatchGetDocuments", serverStreaming: true, options: { "google.api.http": { post: "/identity/document/v1/{database=databases/*}/documents:batchGet", body: "*" } }, I: BatchGetDocumentsRequest, O: BatchGetDocumentsResponse },
    { name: "ListDocuments", options: { "google.api.http": { get: "/identity/document/v1/{parent=databases/*/documents/*/**}/{collection_id}" } }, I: ListDocumentsRequest, O: ListDocumentsResponse },
    { name: "MutateDocuments", options: { "google.api.http": { post: "/identity/document/v1/{database=databases/*}/documents:mutate", body: "*" } }, I: MutateDocumentsRequest, O: MutateDocumentsResponse },
    { name: "RunQuery", serverStreaming: true, options: { "google.api.http": { post: "/identity/document/v1/{parent=databases/*/documents}:runQuery", body: "*", additionalBindings: [{ post: "/identity/document/v1/{parent=databases/*/documents/*/**}:runQuery", body: "*" }] } }, I: RunQueryRequest, O: RunQueryResponse },
    { name: "CheckConsentChallenge", options: {}, I: CheckConsentChallengeRequest, O: CheckConsentChallengeResponse },
    { name: "CreateConsentVerifier", options: {}, I: CreateConsentVerifierRequest, O: CreateConsentVerifierResponse },
    { name: "CreateInvitation", options: {}, I: CreateInvitationRequest, O: CreateInvitationResponse },
    { name: "CheckInvitationState", options: {}, I: CheckInvitationStateRequest, O: CheckInvitationStateResponse },
    { name: "ResendInvitation", options: {}, I: ResendInvitationRequest, O: ResendInvitationResponse },
    { name: "CancelInvitation", options: {}, I: CancelInvitationRequest, O: CancelInvitationResponse },
    { name: "GetPasswordCredential", options: {}, I: GetPasswordCredentialRequest, O: GetPasswordCredentialResponse },
    { name: "UpdatePasswordCredential", options: {}, I: UpdatePasswordCredentialRequest, O: UpdatePasswordCredentialResponse },
    { name: "GetAccessToken", options: {}, I: GetAccessTokenRequest, O: GetAccessTokenResponse },
    { name: "SessionIntrospect", options: { "google.api.http": { post: "/identity/session/introspect", body: "*" } }, I: SessionIntrospectRequest, O: SessionIntrospectResponse }
]);
