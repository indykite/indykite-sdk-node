// @generated by protobuf-ts 2.4.0 with parameter long_type_string,client_grpc1,generate_dependencies,// @generated from protobuf file "indykite/identity/v1beta1/attributes.proto" (package "indykite.identity.v1beta1", syntax proto3),// tslint:disable
//
// Copyright (c) 2020 IndyKite
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Value } from "../../objects/v1beta1/struct";
import { Timestamp } from "../../../google/protobuf/timestamp";
/**
 * @generated from protobuf message indykite.identity.v1beta1.Schema
 */
export interface Schema {
    /**
     * @generated from protobuf field: map<string, string> context = 4;
     */
    context: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: string schema = 1;
     */
    schema: string;
    /**
     * @generated from protobuf field: string schema_version = 2;
     */
    schemaVersion: string;
    /**
     * @generated from protobuf field: string attribute_name = 3;
     */
    attributeName: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.PropertyDefinition
 */
export interface PropertyDefinition {
    /**
     * http://schema.org/
     *
     * @generated from protobuf field: string context = 1;
     */
    context: string;
    /**
     * Person
     *
     * @generated from protobuf field: string type = 2;
     */
    type: string;
    /**
     * email
     *
     * @generated from protobuf field: string property = 3;
     */
    property: string;
}
/**
 * PropertyConstraint represent a conditions to find the property with expected meta-data.
 *
 * @generated from protobuf message indykite.identity.v1beta1.PropertyConstraint
 */
export interface PropertyConstraint {
    /**
     * Issuers used to limit the source of property.
     *
     * @generated from protobuf field: repeated string issuers = 1;
     */
    issuers: string[];
    /**
     * Subset used to specify which property to return if value is an object.
     *
     * @generated from protobuf field: repeated string subset = 2;
     */
    subset: string[];
    /**
     * Get on primary properties
     *
     * @generated from protobuf field: bool only_primary = 3;
     */
    onlyPrimary: boolean;
}
/**
 * PropertyMask used to define which property to read.
 *
 * @generated from protobuf message indykite.identity.v1beta1.PropertyMask
 */
export interface PropertyMask {
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.PropertyDefinition definition = 1;
     */
    definition?: PropertyDefinition;
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.PropertyConstraint constraint = 2;
     */
    constraint?: PropertyConstraint;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.PropertyMetadata
 */
export interface PropertyMetadata {
    /**
     * Primary is true if this instance of a multi-value property is the default to pick from array at first.
     *
     * @generated from protobuf field: bool primary = 1;
     */
    primary: boolean;
    /**
     * AssuranceLevel shows the level of assurance of the property value.
     *
     * @generated from protobuf field: indykite.identity.v1beta1.AssuranceLevel assurance_level = 2;
     */
    assuranceLevel: AssuranceLevel;
    /**
     * Issuer is the identifier of the source of property value.
     * Must starts with 'app:' or 'asp:' followed by trimmed base64URL UUID
     * or starts with 'raw:' followed by name with minimum length of 3 characters
     *
     * Example: ["raw:indykite.id", "app:aW5keWtpRGWAAAIPAAAAAA"]
     *
     * @generated from protobuf field: string issuer = 3;
     */
    issuer: string;
    /**
     * VerificationTime represent the time when AssuranceLevel was changed for Verifier.
     *
     * @generated from protobuf field: google.protobuf.Timestamp verification_time = 4;
     */
    verificationTime?: Timestamp;
    /**
     * Verifier is the identifier of provider carried out the verification process.
     *
     * Example: ["indykite.id", "aW5keWtpRGWAAAIPAAAAAA"]
     *
     * @generated from protobuf field: string verifier = 5;
     */
    verifier: string;
}
/**
 * Property represents a property stored in database.
 *
 * It contains the ID, Definition, Metadata and Value together.
 *
 * @generated from protobuf message indykite.identity.v1beta1.Property
 */
export interface Property {
    /**
     * Id represents the identifier of this property in hex
     * max value is 7FFFFFFFFFFFFFFF in case of signed in64
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Definition represents the property type definition.
     *
     * @generated from protobuf field: indykite.identity.v1beta1.PropertyDefinition definition = 2;
     */
    definition?: PropertyDefinition;
    /**
     * Meta represent the meta-information of this property.
     * One of Meta or Value must be set
     *
     * @generated from protobuf field: indykite.identity.v1beta1.PropertyMetadata meta = 3;
     */
    meta?: PropertyMetadata;
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "objectValue";
        /**
         * ObjectValue is the actual value of the property.
         *
         * This can have many different types and it can also be encrypted and clear as well.
         *
         * @generated from protobuf field: indykite.objects.v1beta1.Value object_value = 4;
         */
        objectValue: Value;
    } | {
        oneofKind: "referenceValue";
        /**
         * ReferenceValue used to set the value reference to a document.
         *
         * Format: `databases/{application_id}/documents/{document_path}`.
         *
         * @generated from protobuf field: string reference_value = 5;
         */
        referenceValue: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * PropertyBatchOperation represents a single Property value operation.
 *
 * @generated from protobuf message indykite.identity.v1beta1.PropertyBatchOperation
 */
export interface PropertyBatchOperation {
    /**
     * @generated from protobuf oneof: operation
     */
    operation: {
        oneofKind: "add";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.Property add = 1;
         */
        add: Property;
    } | {
        oneofKind: "replace";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.Property replace = 2;
         */
        replace: Property;
    } | {
        oneofKind: "remove";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.Property remove = 3;
         */
        remove: Property;
    } | {
        oneofKind: undefined;
    };
}
/**
 * BatchPropertyOperationResult represents the result of an BatchUpdate call.
 *
 * @generated from protobuf message indykite.identity.v1beta1.BatchOperationResult
 */
export interface BatchOperationResult {
    /**
     * @generated from protobuf field: uint64 index = 4;
     */
    index: string;
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.BatchOperationResultSuccess success = 5;
         */
        success: BatchOperationResultSuccess;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.BatchOperationResultError error = 6;
         */
        error: BatchOperationResultError;
    } | {
        oneofKind: undefined;
    };
}
/**
 * BatchOperationResultSuccess represents the result of an successful BatchOperation call.
 *
 * @generated from protobuf message indykite.identity.v1beta1.BatchOperationResultSuccess
 */
export interface BatchOperationResultSuccess {
    /**
     * @generated from protobuf field: string property_id = 1;
     */
    propertyId: string;
}
/**
 * BatchOperationResultError represents an error encountered while executing a batch operation.
 *
 * @generated from protobuf message indykite.identity.v1beta1.BatchOperationResultError
 */
export interface BatchOperationResultError {
    /**
     * @generated from protobuf field: repeated string message = 1;
     */
    message: string[];
}
/**
 * BatchError represents an error encountered while executing a batch operation.
 *
 * The Index field corresponds to the index of the failed operation in the operations array that was passed
 * to batch operation.
 *
 * @generated from protobuf message indykite.identity.v1beta1.BatchError
 */
export interface BatchError {
    /**
     * @generated from protobuf field: int64 index = 1;
     */
    index: string;
    /**
     * @generated from protobuf field: repeated string message = 2;
     */
    message: string[];
}
/**
 * AssuranceLevel of Identity Proofing Requirements (NIST 800-63)
 *
 * @generated from protobuf enum indykite.identity.v1beta1.AssuranceLevel
 */
export enum AssuranceLevel {
    /**
     * @generated from protobuf enum value: ASSURANCE_LEVEL_INVALID = 0;
     */
    INVALID = 0,
    /**
     * Little or no confidence exists in the asserted identity; usually self-asserted; essentially a persistent identifier
     * ASSURANCE_LEVEL_NONE = 1;
     * Confidence exists that the asserted identity is accurate; used frequently for self service applications
     * if any, are self-asserted or should be treated as self-asserted; there is no proofing process.
     *
     * @generated from protobuf enum value: ASSURANCE_LEVEL_LOW = 1;
     */
    LOW = 1,
    /**
     * High confidence in the asserted identity’s accuracy; used to access restricted data
     * Either remote or in-person identity proofing is required using, at a minimum, the procedures given in SP 800-63A.
     *
     * @generated from protobuf enum value: ASSURANCE_LEVEL_SUBSTANTIAL = 2;
     */
    SUBSTANTIAL = 2,
    /**
     * Very high confidence in the asserted identity’s accuracy; used to access highly restricted data.
     * In-person or supervised-remote identity proofing is required. Identifying attributes must be verified through
     * examination of physical documentation as described in SP 800-63A.
     *
     * @generated from protobuf enum value: ASSURANCE_LEVEL_HIGH = 3;
     */
    HIGH = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Schema$Type extends MessageType<Schema> {
    constructor() {
        super("indykite.identity.v1beta1.Schema", [
            { no: 4, name: "context", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 1, name: "schema", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "schema_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "attribute_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Schema>): Schema {
        const message = { context: {}, schema: "", schemaVersion: "", attributeName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Schema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Schema): Schema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> context */ 4:
                    this.binaryReadMap4(message.context, reader, options);
                    break;
                case /* string schema */ 1:
                    message.schema = reader.string();
                    break;
                case /* string schema_version */ 2:
                    message.schemaVersion = reader.string();
                    break;
                case /* string attribute_name */ 3:
                    message.attributeName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: Schema["context"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Schema["context"] | undefined, val: Schema["context"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.identity.v1beta1.Schema.context");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Schema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> context = 4; */
        for (let k of Object.keys(message.context))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.context[k]).join();
        /* string schema = 1; */
        if (message.schema !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schema);
        /* string schema_version = 2; */
        if (message.schemaVersion !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.schemaVersion);
        /* string attribute_name = 3; */
        if (message.attributeName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.attributeName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.Schema
 */
export const Schema = new Schema$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PropertyDefinition$Type extends MessageType<PropertyDefinition> {
    constructor() {
        super("indykite.identity.v1beta1.PropertyDefinition", [
            { no: 1, name: "context", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { uri: true, ignoreEmpty: true } } } },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "property", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "256", pattern: "^[a-zA-Z_][a-zA-Z0-9_]+$" } } } }
        ]);
    }
    create(value?: PartialMessage<PropertyDefinition>): PropertyDefinition {
        const message = { context: "", type: "", property: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PropertyDefinition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PropertyDefinition): PropertyDefinition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string context */ 1:
                    message.context = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* string property */ 3:
                    message.property = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PropertyDefinition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string context = 1; */
        if (message.context !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.context);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* string property = 3; */
        if (message.property !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.property);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.PropertyDefinition
 */
export const PropertyDefinition = new PropertyDefinition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PropertyConstraint$Type extends MessageType<PropertyConstraint> {
    constructor() {
        super("indykite.identity.v1beta1.PropertyConstraint", [
            { no: 1, name: "issuers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subset", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "only_primary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PropertyConstraint>): PropertyConstraint {
        const message = { issuers: [], subset: [], onlyPrimary: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PropertyConstraint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PropertyConstraint): PropertyConstraint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string issuers */ 1:
                    message.issuers.push(reader.string());
                    break;
                case /* repeated string subset */ 2:
                    message.subset.push(reader.string());
                    break;
                case /* bool only_primary */ 3:
                    message.onlyPrimary = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PropertyConstraint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string issuers = 1; */
        for (let i = 0; i < message.issuers.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.issuers[i]);
        /* repeated string subset = 2; */
        for (let i = 0; i < message.subset.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.subset[i]);
        /* bool only_primary = 3; */
        if (message.onlyPrimary !== false)
            writer.tag(3, WireType.Varint).bool(message.onlyPrimary);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.PropertyConstraint
 */
export const PropertyConstraint = new PropertyConstraint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PropertyMask$Type extends MessageType<PropertyMask> {
    constructor() {
        super("indykite.identity.v1beta1.PropertyMask", [
            { no: 1, name: "definition", kind: "message", T: () => PropertyDefinition, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "constraint", kind: "message", T: () => PropertyConstraint }
        ]);
    }
    create(value?: PartialMessage<PropertyMask>): PropertyMask {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PropertyMask>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PropertyMask): PropertyMask {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.PropertyDefinition definition */ 1:
                    message.definition = PropertyDefinition.internalBinaryRead(reader, reader.uint32(), options, message.definition);
                    break;
                case /* indykite.identity.v1beta1.PropertyConstraint constraint */ 2:
                    message.constraint = PropertyConstraint.internalBinaryRead(reader, reader.uint32(), options, message.constraint);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PropertyMask, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.PropertyDefinition definition = 1; */
        if (message.definition)
            PropertyDefinition.internalBinaryWrite(message.definition, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.PropertyConstraint constraint = 2; */
        if (message.constraint)
            PropertyConstraint.internalBinaryWrite(message.constraint, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.PropertyMask
 */
export const PropertyMask = new PropertyMask$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PropertyMetadata$Type extends MessageType<PropertyMetadata> {
    constructor() {
        super("indykite.identity.v1beta1.PropertyMetadata", [
            { no: 1, name: "primary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "assurance_level", kind: "enum", T: () => ["indykite.identity.v1beta1.AssuranceLevel", AssuranceLevel, "ASSURANCE_LEVEL_"] },
            { no: 3, name: "issuer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "verification_time", kind: "message", T: () => Timestamp },
            { no: 5, name: "verifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PropertyMetadata>): PropertyMetadata {
        const message = { primary: false, assuranceLevel: 0, issuer: "", verifier: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PropertyMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PropertyMetadata): PropertyMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool primary */ 1:
                    message.primary = reader.bool();
                    break;
                case /* indykite.identity.v1beta1.AssuranceLevel assurance_level */ 2:
                    message.assuranceLevel = reader.int32();
                    break;
                case /* string issuer */ 3:
                    message.issuer = reader.string();
                    break;
                case /* google.protobuf.Timestamp verification_time */ 4:
                    message.verificationTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.verificationTime);
                    break;
                case /* string verifier */ 5:
                    message.verifier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PropertyMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool primary = 1; */
        if (message.primary !== false)
            writer.tag(1, WireType.Varint).bool(message.primary);
        /* indykite.identity.v1beta1.AssuranceLevel assurance_level = 2; */
        if (message.assuranceLevel !== 0)
            writer.tag(2, WireType.Varint).int32(message.assuranceLevel);
        /* string issuer = 3; */
        if (message.issuer !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.issuer);
        /* google.protobuf.Timestamp verification_time = 4; */
        if (message.verificationTime)
            Timestamp.internalBinaryWrite(message.verificationTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string verifier = 5; */
        if (message.verifier !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.verifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.PropertyMetadata
 */
export const PropertyMetadata = new PropertyMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Property$Type extends MessageType<Property> {
    constructor() {
        super("indykite.identity.v1beta1.Property", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { pattern: "^[0-9a-f]{1,16}$", ignoreEmpty: true } } } },
            { no: 2, name: "definition", kind: "message", T: () => PropertyDefinition },
            { no: 3, name: "meta", kind: "message", T: () => PropertyMetadata },
            { no: 4, name: "object_value", kind: "message", oneof: "value", T: () => Value },
            { no: 5, name: "reference_value", kind: "scalar", oneof: "value", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Property>): Property {
        const message = { id: "", value: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Property>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Property): Property {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* indykite.identity.v1beta1.PropertyDefinition definition */ 2:
                    message.definition = PropertyDefinition.internalBinaryRead(reader, reader.uint32(), options, message.definition);
                    break;
                case /* indykite.identity.v1beta1.PropertyMetadata meta */ 3:
                    message.meta = PropertyMetadata.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                case /* indykite.objects.v1beta1.Value object_value */ 4:
                    message.value = {
                        oneofKind: "objectValue",
                        objectValue: Value.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).objectValue)
                    };
                    break;
                case /* string reference_value */ 5:
                    message.value = {
                        oneofKind: "referenceValue",
                        referenceValue: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Property, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* indykite.identity.v1beta1.PropertyDefinition definition = 2; */
        if (message.definition)
            PropertyDefinition.internalBinaryWrite(message.definition, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.PropertyMetadata meta = 3; */
        if (message.meta)
            PropertyMetadata.internalBinaryWrite(message.meta, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* indykite.objects.v1beta1.Value object_value = 4; */
        if (message.value.oneofKind === "objectValue")
            Value.internalBinaryWrite(message.value.objectValue, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string reference_value = 5; */
        if (message.value.oneofKind === "referenceValue")
            writer.tag(5, WireType.LengthDelimited).string(message.value.referenceValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.Property
 */
export const Property = new Property$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PropertyBatchOperation$Type extends MessageType<PropertyBatchOperation> {
    constructor() {
        super("indykite.identity.v1beta1.PropertyBatchOperation", [
            { no: 1, name: "add", kind: "message", oneof: "operation", T: () => Property, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "replace", kind: "message", oneof: "operation", T: () => Property, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "remove", kind: "message", oneof: "operation", T: () => Property, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<PropertyBatchOperation>): PropertyBatchOperation {
        const message = { operation: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PropertyBatchOperation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PropertyBatchOperation): PropertyBatchOperation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.Property add */ 1:
                    message.operation = {
                        oneofKind: "add",
                        add: Property.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).add)
                    };
                    break;
                case /* indykite.identity.v1beta1.Property replace */ 2:
                    message.operation = {
                        oneofKind: "replace",
                        replace: Property.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).replace)
                    };
                    break;
                case /* indykite.identity.v1beta1.Property remove */ 3:
                    message.operation = {
                        oneofKind: "remove",
                        remove: Property.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).remove)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PropertyBatchOperation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.Property add = 1; */
        if (message.operation.oneofKind === "add")
            Property.internalBinaryWrite(message.operation.add, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.Property replace = 2; */
        if (message.operation.oneofKind === "replace")
            Property.internalBinaryWrite(message.operation.replace, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.Property remove = 3; */
        if (message.operation.oneofKind === "remove")
            Property.internalBinaryWrite(message.operation.remove, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.PropertyBatchOperation
 */
export const PropertyBatchOperation = new PropertyBatchOperation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchOperationResult$Type extends MessageType<BatchOperationResult> {
    constructor() {
        super("indykite.identity.v1beta1.BatchOperationResult", [
            { no: 4, name: "index", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 5, name: "success", kind: "message", oneof: "result", T: () => BatchOperationResultSuccess },
            { no: 6, name: "error", kind: "message", oneof: "result", T: () => BatchOperationResultError }
        ]);
    }
    create(value?: PartialMessage<BatchOperationResult>): BatchOperationResult {
        const message = { index: "0", result: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatchOperationResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchOperationResult): BatchOperationResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 index */ 4:
                    message.index = reader.uint64().toString();
                    break;
                case /* indykite.identity.v1beta1.BatchOperationResultSuccess success */ 5:
                    message.result = {
                        oneofKind: "success",
                        success: BatchOperationResultSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).success)
                    };
                    break;
                case /* indykite.identity.v1beta1.BatchOperationResultError error */ 6:
                    message.result = {
                        oneofKind: "error",
                        error: BatchOperationResultError.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchOperationResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 index = 4; */
        if (message.index !== "0")
            writer.tag(4, WireType.Varint).uint64(message.index);
        /* indykite.identity.v1beta1.BatchOperationResultSuccess success = 5; */
        if (message.result.oneofKind === "success")
            BatchOperationResultSuccess.internalBinaryWrite(message.result.success, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.BatchOperationResultError error = 6; */
        if (message.result.oneofKind === "error")
            BatchOperationResultError.internalBinaryWrite(message.result.error, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.BatchOperationResult
 */
export const BatchOperationResult = new BatchOperationResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchOperationResultSuccess$Type extends MessageType<BatchOperationResultSuccess> {
    constructor() {
        super("indykite.identity.v1beta1.BatchOperationResultSuccess", [
            { no: 1, name: "property_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { pattern: "^[0-9a-f]{1,16}$" } } } }
        ]);
    }
    create(value?: PartialMessage<BatchOperationResultSuccess>): BatchOperationResultSuccess {
        const message = { propertyId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatchOperationResultSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchOperationResultSuccess): BatchOperationResultSuccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string property_id */ 1:
                    message.propertyId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchOperationResultSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string property_id = 1; */
        if (message.propertyId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.propertyId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.BatchOperationResultSuccess
 */
export const BatchOperationResultSuccess = new BatchOperationResultSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchOperationResultError$Type extends MessageType<BatchOperationResultError> {
    constructor() {
        super("indykite.identity.v1beta1.BatchOperationResultError", [
            { no: 1, name: "message", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BatchOperationResultError>): BatchOperationResultError {
        const message = { message: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatchOperationResultError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchOperationResultError): BatchOperationResultError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string message */ 1:
                    message.message.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchOperationResultError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string message = 1; */
        for (let i = 0; i < message.message.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.message[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.BatchOperationResultError
 */
export const BatchOperationResultError = new BatchOperationResultError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchError$Type extends MessageType<BatchError> {
    constructor() {
        super("indykite.identity.v1beta1.BatchError", [
            { no: 1, name: "index", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "message", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BatchError>): BatchError {
        const message = { index: "0", message: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatchError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchError): BatchError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 index */ 1:
                    message.index = reader.int64().toString();
                    break;
                case /* repeated string message */ 2:
                    message.message.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 index = 1; */
        if (message.index !== "0")
            writer.tag(1, WireType.Varint).int64(message.index);
        /* repeated string message = 2; */
        for (let i = 0; i < message.message.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.message[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.BatchError
 */
export const BatchError = new BatchError$Type();
