// @generated by protobuf-ts 2.4.0 with parameter long_type_string,client_grpc1,generate_dependencies,// @generated from protobuf file "indykite/identity/v1beta1/import.proto" (package "indykite.identity.v1beta1", syntax proto3),// tslint:disable
//
// Copyright (c) 2020 IndyKite
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message indykite.identity.v1beta1.ImportUsersRequest
 */
export interface ImportUsersRequest {
    /**
     * @generated from protobuf field: repeated indykite.identity.v1beta1.ImportUser users = 1;
     */
    users: ImportUser[];
    /**
     * @generated from protobuf oneof: hash_algorithm
     */
    hashAlgorithm: {
        oneofKind: "bcrypt";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.Bcrypt bcrypt = 2;
         */
        bcrypt: Bcrypt;
    } | {
        oneofKind: "standardScrypt";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.StandardScrypt standard_scrypt = 3;
         */
        standardScrypt: StandardScrypt;
    } | {
        oneofKind: "scrypt";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.Scrypt scrypt = 4;
         */
        scrypt: Scrypt;
    } | {
        oneofKind: "hmacMd5";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.HMACMD5 hmac_md5 = 5;
         */
        hmacMd5: HMACMD5;
    } | {
        oneofKind: "hmacSha1";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.HMACSHA1 hmac_sha1 = 6;
         */
        hmacSha1: HMACSHA1;
    } | {
        oneofKind: "hmacSha512";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.HMACSHA512 hmac_sha512 = 7;
         */
        hmacSha512: HMACSHA512;
    } | {
        oneofKind: "hmacSha256";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.HMACSHA256 hmac_sha256 = 8;
         */
        hmacSha256: HMACSHA256;
    } | {
        oneofKind: "md5";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.MD5 md5 = 9;
         */
        md5: MD5;
    } | {
        oneofKind: "pbkdf2Sha256";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.PBKDF2SHA256 pbkdf2_sha256 = 10;
         */
        pbkdf2Sha256: PBKDF2SHA256;
    } | {
        oneofKind: "pbkdfSha1";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.PBKDFSHA1 pbkdf_sha1 = 11;
         */
        pbkdfSha1: PBKDFSHA1;
    } | {
        oneofKind: "sha1";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.SHA1 sha1 = 12;
         */
        sha1: SHA1;
    } | {
        oneofKind: "sha256";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.SHA256 sha256 = 13;
         */
        sha256: SHA256;
    } | {
        oneofKind: "sha512";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.SHA512 sha512 = 14;
         */
        sha512: SHA512;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.ImportUsersResponse
 */
export interface ImportUsersResponse {
    /**
     * @generated from protobuf field: repeated indykite.identity.v1beta1.ImportUsersResponse.ImportUserResult errors = 1;
     */
    errors: ImportUsersResponse_ImportUserResult[];
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.ImportUsersResponse.ImportUsersError
 */
export interface ImportUsersResponse_ImportUsersError {
    /**
     * @generated from protobuf field: string message = 2;
     */
    message: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.ImportUsersResponse.ImportUserResult
 */
export interface ImportUsersResponse_ImportUserResult {
    /**
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.ImportUsersResponse.ImportUsersError error = 2;
     */
    error?: ImportUsersResponse_ImportUsersError;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.ImportUser
 */
export interface ImportUser {
    /**
     * @generated from protobuf field: string uid = 1;
     */
    uid: string;
    /**
     * @generated from protobuf field: indykite.identity.v1beta1.PasswordCredential password = 2;
     */
    password?: PasswordCredential;
    /**
     * @generated from protobuf field: repeated indykite.identity.v1beta1.UserProvider provider_user_info = 3;
     */
    providerUserInfo: UserProvider[];
    /**
     * @generated from protobuf field: bool disabled = 4;
     */
    disabled: boolean;
}
/**
 * UserMetadata contains additional metadata associated with a user account.
 * Timestamps are in milliseconds since epoch.
 *
 * @generated from protobuf message indykite.identity.v1beta1.UserMetadata
 */
export interface UserMetadata {
    /**
     * @generated from protobuf field: int64 creation_timestamp = 1;
     */
    creationTimestamp: string;
    /**
     * @generated from protobuf field: int64 last_log_in_timestamp = 2;
     */
    lastLogInTimestamp: string;
    /**
     * The time at which the user was last active (ID token refreshed), or 0 if
     * the user was never active.
     *
     * @generated from protobuf field: int64 last_refresh_timestamp = 3;
     */
    lastRefreshTimestamp: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.Email
 */
export interface Email {
    /**
     * @generated from protobuf field: string email = 1;
     */
    email: string;
    /**
     * @generated from protobuf field: bool verified = 2;
     */
    verified: boolean;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.Mobile
 */
export interface Mobile {
    /**
     * @generated from protobuf field: string mobile = 1;
     */
    mobile: string;
    /**
     * @generated from protobuf field: bool verified = 2;
     */
    verified: boolean;
}
/**
 * PasswordCredential represent a password for user.
 *
 * Password can be specified for each user when importing in bulk.
 *
 * @generated from protobuf message indykite.identity.v1beta1.PasswordCredential
 */
export interface PasswordCredential {
    /**
     * @generated from protobuf oneof: uid
     */
    uid: {
        oneofKind: "email";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.Email email = 1;
         */
        email: Email;
    } | {
        oneofKind: "mobile";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.Mobile mobile = 2;
         */
        mobile: Mobile;
    } | {
        oneofKind: "userName";
        /**
         * @generated from protobuf field: string user_name = 3;
         */
        userName: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: password
     */
    password: {
        oneofKind: "value";
        /**
         * @generated from protobuf field: string value = 4;
         */
        value: string;
    } | {
        oneofKind: "hash";
        /**
         * @generated from protobuf field: indykite.identity.v1beta1.PasswordHash hash = 5;
         */
        hash: PasswordHash;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.PasswordHash
 */
export interface PasswordHash {
    /**
     * @generated from protobuf field: bytes password_hash = 4;
     */
    passwordHash: Uint8Array;
    /**
     * @generated from protobuf field: bytes salt = 5;
     */
    salt: Uint8Array;
}
/**
 * UserProvider represents a user identity provider.
 *
 * One or more user providers can be specified for each user when importing in bulk.
 *
 * @generated from protobuf message indykite.identity.v1beta1.UserProvider
 */
export interface UserProvider {
    /**
     * @generated from protobuf field: string uid = 1;
     */
    uid: string;
    /**
     * @generated from protobuf field: string provider_id = 2;
     */
    providerId: string;
    /**
     * @generated from protobuf field: string email = 3;
     */
    email: string;
    /**
     * @generated from protobuf field: string display_name = 4;
     */
    displayName: string;
    /**
     * @generated from protobuf field: string photo_url = 5;
     */
    photoUrl: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.Bcrypt
 */
export interface Bcrypt {
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.StandardScrypt
 */
export interface StandardScrypt {
    /**
     * @generated from protobuf field: int64 block_size = 1;
     */
    blockSize: string;
    /**
     * @generated from protobuf field: int64 derived_key_length = 2;
     */
    derivedKeyLength: string;
    /**
     * @generated from protobuf field: int64 memory_cost = 3;
     */
    memoryCost: string;
    /**
     * @generated from protobuf field: int64 parallelization = 4;
     */
    parallelization: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.Scrypt
 */
export interface Scrypt {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: bytes salt_separator = 2;
     */
    saltSeparator: Uint8Array;
    /**
     * @generated from protobuf field: int64 rounds = 3;
     */
    rounds: string;
    /**
     * @generated from protobuf field: int64 memory_cost = 4;
     */
    memoryCost: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.HMACMD5
 */
export interface HMACMD5 {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.HMACSHA1
 */
export interface HMACSHA1 {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.HMACSHA512
 */
export interface HMACSHA512 {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.HMACSHA256
 */
export interface HMACSHA256 {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.MD5
 */
export interface MD5 {
    /**
     * @generated from protobuf field: int64 rounds = 1;
     */
    rounds: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.PBKDF2SHA256
 */
export interface PBKDF2SHA256 {
    /**
     * @generated from protobuf field: int64 rounds = 1;
     */
    rounds: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.PBKDFSHA1
 */
export interface PBKDFSHA1 {
    /**
     * @generated from protobuf field: int64 rounds = 1;
     */
    rounds: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.SHA1
 */
export interface SHA1 {
    /**
     * @generated from protobuf field: int64 rounds = 1;
     */
    rounds: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.SHA256
 */
export interface SHA256 {
    /**
     * @generated from protobuf field: int64 rounds = 1;
     */
    rounds: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta1.SHA512
 */
export interface SHA512 {
    /**
     * @generated from protobuf field: int64 rounds = 1;
     */
    rounds: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class ImportUsersRequest$Type extends MessageType<ImportUsersRequest> {
    constructor() {
        super("indykite.identity.v1beta1.ImportUsersRequest", [
            { no: 1, name: "users", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ImportUser },
            { no: 2, name: "bcrypt", kind: "message", oneof: "hashAlgorithm", T: () => Bcrypt },
            { no: 3, name: "standard_scrypt", kind: "message", oneof: "hashAlgorithm", T: () => StandardScrypt },
            { no: 4, name: "scrypt", kind: "message", oneof: "hashAlgorithm", T: () => Scrypt },
            { no: 5, name: "hmac_md5", kind: "message", oneof: "hashAlgorithm", T: () => HMACMD5 },
            { no: 6, name: "hmac_sha1", kind: "message", oneof: "hashAlgorithm", T: () => HMACSHA1 },
            { no: 7, name: "hmac_sha512", kind: "message", oneof: "hashAlgorithm", T: () => HMACSHA512 },
            { no: 8, name: "hmac_sha256", kind: "message", oneof: "hashAlgorithm", T: () => HMACSHA256 },
            { no: 9, name: "md5", kind: "message", oneof: "hashAlgorithm", T: () => MD5 },
            { no: 10, name: "pbkdf2_sha256", kind: "message", oneof: "hashAlgorithm", T: () => PBKDF2SHA256 },
            { no: 11, name: "pbkdf_sha1", kind: "message", oneof: "hashAlgorithm", T: () => PBKDFSHA1 },
            { no: 12, name: "sha1", kind: "message", oneof: "hashAlgorithm", T: () => SHA1 },
            { no: 13, name: "sha256", kind: "message", oneof: "hashAlgorithm", T: () => SHA256 },
            { no: 14, name: "sha512", kind: "message", oneof: "hashAlgorithm", T: () => SHA512 }
        ]);
    }
    create(value?: PartialMessage<ImportUsersRequest>): ImportUsersRequest {
        const message = { users: [], hashAlgorithm: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportUsersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportUsersRequest): ImportUsersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated indykite.identity.v1beta1.ImportUser users */ 1:
                    message.users.push(ImportUser.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* indykite.identity.v1beta1.Bcrypt bcrypt */ 2:
                    message.hashAlgorithm = {
                        oneofKind: "bcrypt",
                        bcrypt: Bcrypt.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).bcrypt)
                    };
                    break;
                case /* indykite.identity.v1beta1.StandardScrypt standard_scrypt */ 3:
                    message.hashAlgorithm = {
                        oneofKind: "standardScrypt",
                        standardScrypt: StandardScrypt.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).standardScrypt)
                    };
                    break;
                case /* indykite.identity.v1beta1.Scrypt scrypt */ 4:
                    message.hashAlgorithm = {
                        oneofKind: "scrypt",
                        scrypt: Scrypt.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).scrypt)
                    };
                    break;
                case /* indykite.identity.v1beta1.HMACMD5 hmac_md5 */ 5:
                    message.hashAlgorithm = {
                        oneofKind: "hmacMd5",
                        hmacMd5: HMACMD5.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).hmacMd5)
                    };
                    break;
                case /* indykite.identity.v1beta1.HMACSHA1 hmac_sha1 */ 6:
                    message.hashAlgorithm = {
                        oneofKind: "hmacSha1",
                        hmacSha1: HMACSHA1.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).hmacSha1)
                    };
                    break;
                case /* indykite.identity.v1beta1.HMACSHA512 hmac_sha512 */ 7:
                    message.hashAlgorithm = {
                        oneofKind: "hmacSha512",
                        hmacSha512: HMACSHA512.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).hmacSha512)
                    };
                    break;
                case /* indykite.identity.v1beta1.HMACSHA256 hmac_sha256 */ 8:
                    message.hashAlgorithm = {
                        oneofKind: "hmacSha256",
                        hmacSha256: HMACSHA256.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).hmacSha256)
                    };
                    break;
                case /* indykite.identity.v1beta1.MD5 md5 */ 9:
                    message.hashAlgorithm = {
                        oneofKind: "md5",
                        md5: MD5.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).md5)
                    };
                    break;
                case /* indykite.identity.v1beta1.PBKDF2SHA256 pbkdf2_sha256 */ 10:
                    message.hashAlgorithm = {
                        oneofKind: "pbkdf2Sha256",
                        pbkdf2Sha256: PBKDF2SHA256.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).pbkdf2Sha256)
                    };
                    break;
                case /* indykite.identity.v1beta1.PBKDFSHA1 pbkdf_sha1 */ 11:
                    message.hashAlgorithm = {
                        oneofKind: "pbkdfSha1",
                        pbkdfSha1: PBKDFSHA1.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).pbkdfSha1)
                    };
                    break;
                case /* indykite.identity.v1beta1.SHA1 sha1 */ 12:
                    message.hashAlgorithm = {
                        oneofKind: "sha1",
                        sha1: SHA1.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).sha1)
                    };
                    break;
                case /* indykite.identity.v1beta1.SHA256 sha256 */ 13:
                    message.hashAlgorithm = {
                        oneofKind: "sha256",
                        sha256: SHA256.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).sha256)
                    };
                    break;
                case /* indykite.identity.v1beta1.SHA512 sha512 */ 14:
                    message.hashAlgorithm = {
                        oneofKind: "sha512",
                        sha512: SHA512.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).sha512)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportUsersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated indykite.identity.v1beta1.ImportUser users = 1; */
        for (let i = 0; i < message.users.length; i++)
            ImportUser.internalBinaryWrite(message.users[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.Bcrypt bcrypt = 2; */
        if (message.hashAlgorithm.oneofKind === "bcrypt")
            Bcrypt.internalBinaryWrite(message.hashAlgorithm.bcrypt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.StandardScrypt standard_scrypt = 3; */
        if (message.hashAlgorithm.oneofKind === "standardScrypt")
            StandardScrypt.internalBinaryWrite(message.hashAlgorithm.standardScrypt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.Scrypt scrypt = 4; */
        if (message.hashAlgorithm.oneofKind === "scrypt")
            Scrypt.internalBinaryWrite(message.hashAlgorithm.scrypt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.HMACMD5 hmac_md5 = 5; */
        if (message.hashAlgorithm.oneofKind === "hmacMd5")
            HMACMD5.internalBinaryWrite(message.hashAlgorithm.hmacMd5, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.HMACSHA1 hmac_sha1 = 6; */
        if (message.hashAlgorithm.oneofKind === "hmacSha1")
            HMACSHA1.internalBinaryWrite(message.hashAlgorithm.hmacSha1, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.HMACSHA512 hmac_sha512 = 7; */
        if (message.hashAlgorithm.oneofKind === "hmacSha512")
            HMACSHA512.internalBinaryWrite(message.hashAlgorithm.hmacSha512, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.HMACSHA256 hmac_sha256 = 8; */
        if (message.hashAlgorithm.oneofKind === "hmacSha256")
            HMACSHA256.internalBinaryWrite(message.hashAlgorithm.hmacSha256, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.MD5 md5 = 9; */
        if (message.hashAlgorithm.oneofKind === "md5")
            MD5.internalBinaryWrite(message.hashAlgorithm.md5, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.PBKDF2SHA256 pbkdf2_sha256 = 10; */
        if (message.hashAlgorithm.oneofKind === "pbkdf2Sha256")
            PBKDF2SHA256.internalBinaryWrite(message.hashAlgorithm.pbkdf2Sha256, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.PBKDFSHA1 pbkdf_sha1 = 11; */
        if (message.hashAlgorithm.oneofKind === "pbkdfSha1")
            PBKDFSHA1.internalBinaryWrite(message.hashAlgorithm.pbkdfSha1, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.SHA1 sha1 = 12; */
        if (message.hashAlgorithm.oneofKind === "sha1")
            SHA1.internalBinaryWrite(message.hashAlgorithm.sha1, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.SHA256 sha256 = 13; */
        if (message.hashAlgorithm.oneofKind === "sha256")
            SHA256.internalBinaryWrite(message.hashAlgorithm.sha256, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.SHA512 sha512 = 14; */
        if (message.hashAlgorithm.oneofKind === "sha512")
            SHA512.internalBinaryWrite(message.hashAlgorithm.sha512, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ImportUsersRequest
 */
export const ImportUsersRequest = new ImportUsersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportUsersResponse$Type extends MessageType<ImportUsersResponse> {
    constructor() {
        super("indykite.identity.v1beta1.ImportUsersResponse", [
            { no: 1, name: "errors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ImportUsersResponse_ImportUserResult }
        ]);
    }
    create(value?: PartialMessage<ImportUsersResponse>): ImportUsersResponse {
        const message = { errors: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportUsersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportUsersResponse): ImportUsersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated indykite.identity.v1beta1.ImportUsersResponse.ImportUserResult errors */ 1:
                    message.errors.push(ImportUsersResponse_ImportUserResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportUsersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated indykite.identity.v1beta1.ImportUsersResponse.ImportUserResult errors = 1; */
        for (let i = 0; i < message.errors.length; i++)
            ImportUsersResponse_ImportUserResult.internalBinaryWrite(message.errors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ImportUsersResponse
 */
export const ImportUsersResponse = new ImportUsersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportUsersResponse_ImportUsersError$Type extends MessageType<ImportUsersResponse_ImportUsersError> {
    constructor() {
        super("indykite.identity.v1beta1.ImportUsersResponse.ImportUsersError", [
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImportUsersResponse_ImportUsersError>): ImportUsersResponse_ImportUsersError {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportUsersResponse_ImportUsersError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportUsersResponse_ImportUsersError): ImportUsersResponse_ImportUsersError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportUsersResponse_ImportUsersError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ImportUsersResponse.ImportUsersError
 */
export const ImportUsersResponse_ImportUsersError = new ImportUsersResponse_ImportUsersError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportUsersResponse_ImportUserResult$Type extends MessageType<ImportUsersResponse_ImportUserResult> {
    constructor() {
        super("indykite.identity.v1beta1.ImportUsersResponse.ImportUserResult", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "error", kind: "message", T: () => ImportUsersResponse_ImportUsersError }
        ]);
    }
    create(value?: PartialMessage<ImportUsersResponse_ImportUserResult>): ImportUsersResponse_ImportUserResult {
        const message = { id: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportUsersResponse_ImportUserResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportUsersResponse_ImportUserResult): ImportUsersResponse_ImportUserResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                case /* indykite.identity.v1beta1.ImportUsersResponse.ImportUsersError error */ 2:
                    message.error = ImportUsersResponse_ImportUsersError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportUsersResponse_ImportUserResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        /* indykite.identity.v1beta1.ImportUsersResponse.ImportUsersError error = 2; */
        if (message.error)
            ImportUsersResponse_ImportUsersError.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ImportUsersResponse.ImportUserResult
 */
export const ImportUsersResponse_ImportUserResult = new ImportUsersResponse_ImportUserResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportUser$Type extends MessageType<ImportUser> {
    constructor() {
        super("indykite.identity.v1beta1.ImportUser", [
            { no: 1, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "message", T: () => PasswordCredential },
            { no: 3, name: "provider_user_info", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UserProvider },
            { no: 4, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ImportUser>): ImportUser {
        const message = { uid: "", providerUserInfo: [], disabled: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportUser>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportUser): ImportUser {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uid */ 1:
                    message.uid = reader.string();
                    break;
                case /* indykite.identity.v1beta1.PasswordCredential password */ 2:
                    message.password = PasswordCredential.internalBinaryRead(reader, reader.uint32(), options, message.password);
                    break;
                case /* repeated indykite.identity.v1beta1.UserProvider provider_user_info */ 3:
                    message.providerUserInfo.push(UserProvider.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool disabled */ 4:
                    message.disabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportUser, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uid = 1; */
        if (message.uid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uid);
        /* indykite.identity.v1beta1.PasswordCredential password = 2; */
        if (message.password)
            PasswordCredential.internalBinaryWrite(message.password, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated indykite.identity.v1beta1.UserProvider provider_user_info = 3; */
        for (let i = 0; i < message.providerUserInfo.length; i++)
            UserProvider.internalBinaryWrite(message.providerUserInfo[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool disabled = 4; */
        if (message.disabled !== false)
            writer.tag(4, WireType.Varint).bool(message.disabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.ImportUser
 */
export const ImportUser = new ImportUser$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserMetadata$Type extends MessageType<UserMetadata> {
    constructor() {
        super("indykite.identity.v1beta1.UserMetadata", [
            { no: 1, name: "creation_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "last_log_in_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "last_refresh_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<UserMetadata>): UserMetadata {
        const message = { creationTimestamp: "0", lastLogInTimestamp: "0", lastRefreshTimestamp: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserMetadata): UserMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 creation_timestamp */ 1:
                    message.creationTimestamp = reader.int64().toString();
                    break;
                case /* int64 last_log_in_timestamp */ 2:
                    message.lastLogInTimestamp = reader.int64().toString();
                    break;
                case /* int64 last_refresh_timestamp */ 3:
                    message.lastRefreshTimestamp = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 creation_timestamp = 1; */
        if (message.creationTimestamp !== "0")
            writer.tag(1, WireType.Varint).int64(message.creationTimestamp);
        /* int64 last_log_in_timestamp = 2; */
        if (message.lastLogInTimestamp !== "0")
            writer.tag(2, WireType.Varint).int64(message.lastLogInTimestamp);
        /* int64 last_refresh_timestamp = 3; */
        if (message.lastRefreshTimestamp !== "0")
            writer.tag(3, WireType.Varint).int64(message.lastRefreshTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.UserMetadata
 */
export const UserMetadata = new UserMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Email$Type extends MessageType<Email> {
    constructor() {
        super("indykite.identity.v1beta1.Email", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "verified", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Email>): Email {
        const message = { email: "", verified: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Email>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Email): Email {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                case /* bool verified */ 2:
                    message.verified = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Email, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        /* bool verified = 2; */
        if (message.verified !== false)
            writer.tag(2, WireType.Varint).bool(message.verified);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.Email
 */
export const Email = new Email$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Mobile$Type extends MessageType<Mobile> {
    constructor() {
        super("indykite.identity.v1beta1.Mobile", [
            { no: 1, name: "mobile", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "verified", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Mobile>): Mobile {
        const message = { mobile: "", verified: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Mobile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Mobile): Mobile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mobile */ 1:
                    message.mobile = reader.string();
                    break;
                case /* bool verified */ 2:
                    message.verified = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Mobile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mobile = 1; */
        if (message.mobile !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mobile);
        /* bool verified = 2; */
        if (message.verified !== false)
            writer.tag(2, WireType.Varint).bool(message.verified);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.Mobile
 */
export const Mobile = new Mobile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasswordCredential$Type extends MessageType<PasswordCredential> {
    constructor() {
        super("indykite.identity.v1beta1.PasswordCredential", [
            { no: 1, name: "email", kind: "message", oneof: "uid", T: () => Email },
            { no: 2, name: "mobile", kind: "message", oneof: "uid", T: () => Mobile },
            { no: 3, name: "user_name", kind: "scalar", oneof: "uid", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "value", kind: "scalar", oneof: "password", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "hash", kind: "message", oneof: "password", T: () => PasswordHash }
        ]);
    }
    create(value?: PartialMessage<PasswordCredential>): PasswordCredential {
        const message = { uid: { oneofKind: undefined }, password: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PasswordCredential>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PasswordCredential): PasswordCredential {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta1.Email email */ 1:
                    message.uid = {
                        oneofKind: "email",
                        email: Email.internalBinaryRead(reader, reader.uint32(), options, (message.uid as any).email)
                    };
                    break;
                case /* indykite.identity.v1beta1.Mobile mobile */ 2:
                    message.uid = {
                        oneofKind: "mobile",
                        mobile: Mobile.internalBinaryRead(reader, reader.uint32(), options, (message.uid as any).mobile)
                    };
                    break;
                case /* string user_name */ 3:
                    message.uid = {
                        oneofKind: "userName",
                        userName: reader.string()
                    };
                    break;
                case /* string value */ 4:
                    message.password = {
                        oneofKind: "value",
                        value: reader.string()
                    };
                    break;
                case /* indykite.identity.v1beta1.PasswordHash hash */ 5:
                    message.password = {
                        oneofKind: "hash",
                        hash: PasswordHash.internalBinaryRead(reader, reader.uint32(), options, (message.password as any).hash)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PasswordCredential, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta1.Email email = 1; */
        if (message.uid.oneofKind === "email")
            Email.internalBinaryWrite(message.uid.email, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta1.Mobile mobile = 2; */
        if (message.uid.oneofKind === "mobile")
            Mobile.internalBinaryWrite(message.uid.mobile, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string user_name = 3; */
        if (message.uid.oneofKind === "userName")
            writer.tag(3, WireType.LengthDelimited).string(message.uid.userName);
        /* string value = 4; */
        if (message.password.oneofKind === "value")
            writer.tag(4, WireType.LengthDelimited).string(message.password.value);
        /* indykite.identity.v1beta1.PasswordHash hash = 5; */
        if (message.password.oneofKind === "hash")
            PasswordHash.internalBinaryWrite(message.password.hash, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.PasswordCredential
 */
export const PasswordCredential = new PasswordCredential$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasswordHash$Type extends MessageType<PasswordHash> {
    constructor() {
        super("indykite.identity.v1beta1.PasswordHash", [
            { no: 4, name: "password_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "salt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PasswordHash>): PasswordHash {
        const message = { passwordHash: new Uint8Array(0), salt: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PasswordHash>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PasswordHash): PasswordHash {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes password_hash */ 4:
                    message.passwordHash = reader.bytes();
                    break;
                case /* bytes salt */ 5:
                    message.salt = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PasswordHash, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes password_hash = 4; */
        if (message.passwordHash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.passwordHash);
        /* bytes salt = 5; */
        if (message.salt.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.salt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.PasswordHash
 */
export const PasswordHash = new PasswordHash$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserProvider$Type extends MessageType<UserProvider> {
    constructor() {
        super("indykite.identity.v1beta1.UserProvider", [
            { no: 1, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "provider_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "photo_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserProvider>): UserProvider {
        const message = { uid: "", providerId: "", email: "", displayName: "", photoUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserProvider>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserProvider): UserProvider {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uid */ 1:
                    message.uid = reader.string();
                    break;
                case /* string provider_id */ 2:
                    message.providerId = reader.string();
                    break;
                case /* string email */ 3:
                    message.email = reader.string();
                    break;
                case /* string display_name */ 4:
                    message.displayName = reader.string();
                    break;
                case /* string photo_url */ 5:
                    message.photoUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserProvider, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uid = 1; */
        if (message.uid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uid);
        /* string provider_id = 2; */
        if (message.providerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.providerId);
        /* string email = 3; */
        if (message.email !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        /* string display_name = 4; */
        if (message.displayName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.displayName);
        /* string photo_url = 5; */
        if (message.photoUrl !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.photoUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.UserProvider
 */
export const UserProvider = new UserProvider$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bcrypt$Type extends MessageType<Bcrypt> {
    constructor() {
        super("indykite.identity.v1beta1.Bcrypt", []);
    }
    create(value?: PartialMessage<Bcrypt>): Bcrypt {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Bcrypt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bcrypt): Bcrypt {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Bcrypt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.Bcrypt
 */
export const Bcrypt = new Bcrypt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StandardScrypt$Type extends MessageType<StandardScrypt> {
    constructor() {
        super("indykite.identity.v1beta1.StandardScrypt", [
            { no: 1, name: "block_size", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "derived_key_length", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "memory_cost", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "parallelization", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<StandardScrypt>): StandardScrypt {
        const message = { blockSize: "0", derivedKeyLength: "0", memoryCost: "0", parallelization: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StandardScrypt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StandardScrypt): StandardScrypt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 block_size */ 1:
                    message.blockSize = reader.int64().toString();
                    break;
                case /* int64 derived_key_length */ 2:
                    message.derivedKeyLength = reader.int64().toString();
                    break;
                case /* int64 memory_cost */ 3:
                    message.memoryCost = reader.int64().toString();
                    break;
                case /* int64 parallelization */ 4:
                    message.parallelization = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StandardScrypt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 block_size = 1; */
        if (message.blockSize !== "0")
            writer.tag(1, WireType.Varint).int64(message.blockSize);
        /* int64 derived_key_length = 2; */
        if (message.derivedKeyLength !== "0")
            writer.tag(2, WireType.Varint).int64(message.derivedKeyLength);
        /* int64 memory_cost = 3; */
        if (message.memoryCost !== "0")
            writer.tag(3, WireType.Varint).int64(message.memoryCost);
        /* int64 parallelization = 4; */
        if (message.parallelization !== "0")
            writer.tag(4, WireType.Varint).int64(message.parallelization);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.StandardScrypt
 */
export const StandardScrypt = new StandardScrypt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Scrypt$Type extends MessageType<Scrypt> {
    constructor() {
        super("indykite.identity.v1beta1.Scrypt", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "salt_separator", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "rounds", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "memory_cost", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<Scrypt>): Scrypt {
        const message = { key: new Uint8Array(0), saltSeparator: new Uint8Array(0), rounds: "0", memoryCost: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Scrypt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Scrypt): Scrypt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                case /* bytes salt_separator */ 2:
                    message.saltSeparator = reader.bytes();
                    break;
                case /* int64 rounds */ 3:
                    message.rounds = reader.int64().toString();
                    break;
                case /* int64 memory_cost */ 4:
                    message.memoryCost = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Scrypt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        /* bytes salt_separator = 2; */
        if (message.saltSeparator.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.saltSeparator);
        /* int64 rounds = 3; */
        if (message.rounds !== "0")
            writer.tag(3, WireType.Varint).int64(message.rounds);
        /* int64 memory_cost = 4; */
        if (message.memoryCost !== "0")
            writer.tag(4, WireType.Varint).int64(message.memoryCost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.Scrypt
 */
export const Scrypt = new Scrypt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HMACMD5$Type extends MessageType<HMACMD5> {
    constructor() {
        super("indykite.identity.v1beta1.HMACMD5", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HMACMD5>): HMACMD5 {
        const message = { key: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HMACMD5>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HMACMD5): HMACMD5 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HMACMD5, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.HMACMD5
 */
export const HMACMD5 = new HMACMD5$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HMACSHA1$Type extends MessageType<HMACSHA1> {
    constructor() {
        super("indykite.identity.v1beta1.HMACSHA1", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HMACSHA1>): HMACSHA1 {
        const message = { key: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HMACSHA1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HMACSHA1): HMACSHA1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HMACSHA1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.HMACSHA1
 */
export const HMACSHA1 = new HMACSHA1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HMACSHA512$Type extends MessageType<HMACSHA512> {
    constructor() {
        super("indykite.identity.v1beta1.HMACSHA512", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HMACSHA512>): HMACSHA512 {
        const message = { key: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HMACSHA512>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HMACSHA512): HMACSHA512 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HMACSHA512, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.HMACSHA512
 */
export const HMACSHA512 = new HMACSHA512$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HMACSHA256$Type extends MessageType<HMACSHA256> {
    constructor() {
        super("indykite.identity.v1beta1.HMACSHA256", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HMACSHA256>): HMACSHA256 {
        const message = { key: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HMACSHA256>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HMACSHA256): HMACSHA256 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HMACSHA256, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.HMACSHA256
 */
export const HMACSHA256 = new HMACSHA256$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MD5$Type extends MessageType<MD5> {
    constructor() {
        super("indykite.identity.v1beta1.MD5", [
            { no: 1, name: "rounds", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<MD5>): MD5 {
        const message = { rounds: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MD5>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MD5): MD5 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 rounds */ 1:
                    message.rounds = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MD5, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 rounds = 1; */
        if (message.rounds !== "0")
            writer.tag(1, WireType.Varint).int64(message.rounds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.MD5
 */
export const MD5 = new MD5$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PBKDF2SHA256$Type extends MessageType<PBKDF2SHA256> {
    constructor() {
        super("indykite.identity.v1beta1.PBKDF2SHA256", [
            { no: 1, name: "rounds", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<PBKDF2SHA256>): PBKDF2SHA256 {
        const message = { rounds: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PBKDF2SHA256>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PBKDF2SHA256): PBKDF2SHA256 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 rounds */ 1:
                    message.rounds = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PBKDF2SHA256, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 rounds = 1; */
        if (message.rounds !== "0")
            writer.tag(1, WireType.Varint).int64(message.rounds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.PBKDF2SHA256
 */
export const PBKDF2SHA256 = new PBKDF2SHA256$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PBKDFSHA1$Type extends MessageType<PBKDFSHA1> {
    constructor() {
        super("indykite.identity.v1beta1.PBKDFSHA1", [
            { no: 1, name: "rounds", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<PBKDFSHA1>): PBKDFSHA1 {
        const message = { rounds: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PBKDFSHA1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PBKDFSHA1): PBKDFSHA1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 rounds */ 1:
                    message.rounds = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PBKDFSHA1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 rounds = 1; */
        if (message.rounds !== "0")
            writer.tag(1, WireType.Varint).int64(message.rounds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.PBKDFSHA1
 */
export const PBKDFSHA1 = new PBKDFSHA1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SHA1$Type extends MessageType<SHA1> {
    constructor() {
        super("indykite.identity.v1beta1.SHA1", [
            { no: 1, name: "rounds", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<SHA1>): SHA1 {
        const message = { rounds: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SHA1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SHA1): SHA1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 rounds */ 1:
                    message.rounds = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SHA1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 rounds = 1; */
        if (message.rounds !== "0")
            writer.tag(1, WireType.Varint).int64(message.rounds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.SHA1
 */
export const SHA1 = new SHA1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SHA256$Type extends MessageType<SHA256> {
    constructor() {
        super("indykite.identity.v1beta1.SHA256", [
            { no: 1, name: "rounds", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<SHA256>): SHA256 {
        const message = { rounds: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SHA256>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SHA256): SHA256 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 rounds */ 1:
                    message.rounds = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SHA256, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 rounds = 1; */
        if (message.rounds !== "0")
            writer.tag(1, WireType.Varint).int64(message.rounds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.SHA256
 */
export const SHA256 = new SHA256$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SHA512$Type extends MessageType<SHA512> {
    constructor() {
        super("indykite.identity.v1beta1.SHA512", [
            { no: 1, name: "rounds", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<SHA512>): SHA512 {
        const message = { rounds: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SHA512>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SHA512): SHA512 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 rounds */ 1:
                    message.rounds = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SHA512, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 rounds = 1; */
        if (message.rounds !== "0")
            writer.tag(1, WireType.Varint).int64(message.rounds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta1.SHA512
 */
export const SHA512 = new SHA512$Type();
