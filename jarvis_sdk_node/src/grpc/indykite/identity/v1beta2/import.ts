// @generated by protobuf-ts 2.4.0 with parameter long_type_string,client_grpc1,generate_dependencies,// @generated from protobuf file "indykite/identity/v1beta2/import.proto" (package "indykite.identity.v1beta2", syntax proto3),// tslint:disable
//
// Copyright (c) 2022 IndyKite
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PropertyBatchOperation } from "./attributes";
import { DigitalTwinState } from "./model";
import { DigitalTwinKind } from "./model";
import { BatchOperationResult } from "./attributes";
import { DigitalTwin } from "./model";
/**
 * @generated from protobuf message indykite.identity.v1beta2.ImportDigitalTwinsRequest
 */
export interface ImportDigitalTwinsRequest {
    /**
     * @generated from protobuf field: repeated indykite.identity.v1beta2.ImportDigitalTwin entities = 1;
     */
    entities: ImportDigitalTwin[];
    /**
     * @generated from protobuf oneof: hash_algorithm
     */
    hashAlgorithm: {
        oneofKind: "bcrypt";
        /**
         * @generated from protobuf field: indykite.identity.v1beta2.Bcrypt bcrypt = 2;
         */
        bcrypt: Bcrypt;
    } | {
        oneofKind: "standardScrypt";
        /**
         * @generated from protobuf field: indykite.identity.v1beta2.StandardScrypt standard_scrypt = 3;
         */
        standardScrypt: StandardScrypt;
    } | {
        oneofKind: "scrypt";
        /**
         * @generated from protobuf field: indykite.identity.v1beta2.Scrypt scrypt = 4;
         */
        scrypt: Scrypt;
    } | {
        oneofKind: "hmacMd5";
        /**
         * @generated from protobuf field: indykite.identity.v1beta2.HMACMD5 hmac_md5 = 5;
         */
        hmacMd5: HMACMD5;
    } | {
        oneofKind: "hmacSha1";
        /**
         * @generated from protobuf field: indykite.identity.v1beta2.HMACSHA1 hmac_sha1 = 6;
         */
        hmacSha1: HMACSHA1;
    } | {
        oneofKind: "hmacSha512";
        /**
         * @generated from protobuf field: indykite.identity.v1beta2.HMACSHA512 hmac_sha512 = 7;
         */
        hmacSha512: HMACSHA512;
    } | {
        oneofKind: "hmacSha256";
        /**
         * @generated from protobuf field: indykite.identity.v1beta2.HMACSHA256 hmac_sha256 = 8;
         */
        hmacSha256: HMACSHA256;
    } | {
        oneofKind: "md5";
        /**
         * @generated from protobuf field: indykite.identity.v1beta2.MD5 md5 = 9;
         */
        md5: MD5;
    } | {
        oneofKind: "pbkdf2Sha256";
        /**
         * @generated from protobuf field: indykite.identity.v1beta2.PBKDF2SHA256 pbkdf2_sha256 = 10;
         */
        pbkdf2Sha256: PBKDF2SHA256;
    } | {
        oneofKind: "pbkdfSha1";
        /**
         * @generated from protobuf field: indykite.identity.v1beta2.PBKDFSHA1 pbkdf_sha1 = 11;
         */
        pbkdfSha1: PBKDFSHA1;
    } | {
        oneofKind: "sha1";
        /**
         * @generated from protobuf field: indykite.identity.v1beta2.SHA1 sha1 = 12;
         */
        sha1: SHA1;
    } | {
        oneofKind: "sha256";
        /**
         * @generated from protobuf field: indykite.identity.v1beta2.SHA256 sha256 = 13;
         */
        sha256: SHA256;
    } | {
        oneofKind: "sha512";
        /**
         * @generated from protobuf field: indykite.identity.v1beta2.SHA512 sha512 = 14;
         */
        sha512: SHA512;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.ImportDigitalTwinSuccess
 */
export interface ImportDigitalTwinSuccess {
    /**
     * DigitalTwin is the new or exiting DigitalTwin identifier.
     *
     * @generated from protobuf field: indykite.identity.v1beta2.DigitalTwin digital_twin = 1;
     */
    digitalTwin?: DigitalTwin;
    /**
     * Results is set if the request contained 'properties' to import and the DigitalTwin was
     * patched after, this will contain the batch operation result.
     *
     * @generated from protobuf field: repeated indykite.identity.v1beta2.BatchOperationResult results = 2;
     */
    results: BatchOperationResult[];
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.ImportDigitalTwinError
 */
export interface ImportDigitalTwinError {
    /**
     * @generated from protobuf field: repeated string message = 1;
     */
    message: string[];
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.ImportDigitalTwinResult
 */
export interface ImportDigitalTwinResult {
    /**
     * @generated from protobuf field: uint64 index = 1;
     */
    index: string;
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: indykite.identity.v1beta2.ImportDigitalTwinSuccess success = 2;
         */
        success: ImportDigitalTwinSuccess;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: indykite.identity.v1beta2.ImportDigitalTwinError error = 3;
         */
        error: ImportDigitalTwinError;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.ImportDigitalTwinsResponse
 */
export interface ImportDigitalTwinsResponse {
    /**
     * @generated from protobuf field: repeated indykite.identity.v1beta2.ImportDigitalTwinResult results = 1;
     */
    results: ImportDigitalTwinResult[];
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.ImportDigitalTwin
 */
export interface ImportDigitalTwin {
    /**
     * ID to assign to new DigitalTwin or find existing and update.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * TenantId the unique identifier of the tenant of DigitalTwin.
     *
     * @generated from protobuf field: string tenant_id = 2;
     */
    tenantId: string;
    /**
     * @generated from protobuf field: indykite.identity.v1beta2.DigitalTwinKind kind = 3;
     */
    kind: DigitalTwinKind;
    /**
     * @generated from protobuf field: indykite.identity.v1beta2.DigitalTwinState state = 4;
     */
    state: DigitalTwinState;
    /**
     * Tags define semantics for DigitalTwin.
     * First tag is considered as primary tag for use cases, when 1 tag must be extracted from the list.
     *
     * Tags defines more detailed semantic meaning, and are tightly coupled with the properties a DigitalTwin can have.
     *
     * @generated from protobuf field: repeated string tags = 5;
     */
    tags: string[];
    /**
     * Password credential if available to import.
     *
     * @generated from protobuf field: indykite.identity.v1beta2.PasswordCredential password = 6;
     */
    password?: PasswordCredential;
    /**
     * OAuth2 Identity Provider information to append to the DigitalTwin.
     *
     * @generated from protobuf field: repeated indykite.identity.v1beta2.UserProvider provider_user_info = 7;
     */
    providerUserInfo: UserProvider[];
    /**
     * Import and patch additional properties after the user is imported.
     *
     * @generated from protobuf field: indykite.identity.v1beta2.ImportProperties properties = 8;
     */
    properties?: ImportProperties;
    /**
     * Metadata to preserve with user import - ignored when DigitalTwin already exist.
     *
     * @generated from protobuf field: indykite.identity.v1beta2.UserMetadata metadata = 9;
     */
    metadata?: UserMetadata;
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.ImportProperties
 */
export interface ImportProperties {
    /**
     * @generated from protobuf field: repeated indykite.identity.v1beta2.PropertyBatchOperation operations = 2;
     */
    operations: PropertyBatchOperation[];
    /**
     * ForceDelete must be set to true to delete primary property
     *
     * @generated from protobuf field: bool force_delete = 4;
     */
    forceDelete: boolean;
}
/**
 * UserMetadata contains additional metadata associated with a user account.
 * Timestamps are in milliseconds since epoch.
 *
 * @generated from protobuf message indykite.identity.v1beta2.UserMetadata
 */
export interface UserMetadata {
    /**
     * @generated from protobuf field: int64 creation_timestamp = 1;
     */
    creationTimestamp: string;
    /**
     * @generated from protobuf field: int64 last_log_in_timestamp = 2;
     */
    lastLogInTimestamp: string;
    /**
     * The time at which the user was last active (ID token refreshed), or 0 if
     * the user was never active.
     *
     * @generated from protobuf field: int64 last_refresh_timestamp = 3;
     */
    lastRefreshTimestamp: string;
}
/**
 * UserProvider represents a user identity provider.
 *
 * One or more user providers can be specified for each user when importing in bulk.
 *
 * @generated from protobuf message indykite.identity.v1beta2.UserProvider
 */
export interface UserProvider {
    /**
     * @generated from protobuf field: string uid = 1;
     */
    uid: string;
    /**
     * @generated from protobuf field: string provider_id = 2;
     */
    providerId: string;
    /**
     * @generated from protobuf field: string email = 3;
     */
    email: string;
    /**
     * @generated from protobuf field: string display_name = 4;
     */
    displayName: string;
    /**
     * @generated from protobuf field: string photo_url = 5;
     */
    photoUrl: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.Email
 */
export interface Email {
    /**
     * @generated from protobuf field: string email = 1;
     */
    email: string;
    /**
     * @generated from protobuf field: bool verified = 2;
     */
    verified: boolean;
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.Mobile
 */
export interface Mobile {
    /**
     * @generated from protobuf field: string mobile = 1;
     */
    mobile: string;
    /**
     * @generated from protobuf field: bool verified = 2;
     */
    verified: boolean;
}
/**
 * PasswordCredential represent a password for user.
 *
 * Password can be specified for each user when importing in bulk.
 *
 * @generated from protobuf message indykite.identity.v1beta2.PasswordCredential
 */
export interface PasswordCredential {
    /**
     * @generated from protobuf oneof: uid
     */
    uid: {
        oneofKind: "email";
        /**
         * Email username - use this if the username is an email.
         *
         * @generated from protobuf field: indykite.identity.v1beta2.Email email = 1;
         */
        email: Email;
    } | {
        oneofKind: "mobile";
        /**
         * Mobile username - use this if the username is an E.164 compliant identifier.
         *
         * @generated from protobuf field: indykite.identity.v1beta2.Mobile mobile = 2;
         */
        mobile: Mobile;
    } | {
        oneofKind: "username";
        /**
         * @generated from protobuf field: string username = 3;
         */
        username: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: password
     */
    password: {
        oneofKind: "value";
        /**
         * Value is the clear password value.
         *
         * @generated from protobuf field: string value = 4;
         */
        value: string;
    } | {
        oneofKind: "hash";
        /**
         * Hash value of the password, the hash algorithm is predefined in the import operation.
         *
         * @generated from protobuf field: indykite.identity.v1beta2.PasswordHash hash = 5;
         */
        hash: PasswordHash;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.PasswordHash
 */
export interface PasswordHash {
    /**
     * @generated from protobuf field: bytes password_hash = 4;
     */
    passwordHash: Uint8Array;
    /**
     * @generated from protobuf field: bytes salt = 5;
     */
    salt: Uint8Array;
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.Bcrypt
 */
export interface Bcrypt {
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.StandardScrypt
 */
export interface StandardScrypt {
    /**
     * @generated from protobuf field: int64 block_size = 1;
     */
    blockSize: string;
    /**
     * @generated from protobuf field: int64 derived_key_length = 2;
     */
    derivedKeyLength: string;
    /**
     * @generated from protobuf field: int64 memory_cost = 3;
     */
    memoryCost: string;
    /**
     * @generated from protobuf field: int64 parallelization = 4;
     */
    parallelization: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.Scrypt
 */
export interface Scrypt {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: bytes salt_separator = 2;
     */
    saltSeparator: Uint8Array;
    /**
     * @generated from protobuf field: int64 rounds = 3;
     */
    rounds: string;
    /**
     * @generated from protobuf field: int64 memory_cost = 4;
     */
    memoryCost: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.HMACMD5
 */
export interface HMACMD5 {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.HMACSHA1
 */
export interface HMACSHA1 {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.HMACSHA512
 */
export interface HMACSHA512 {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.HMACSHA256
 */
export interface HMACSHA256 {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.MD5
 */
export interface MD5 {
    /**
     * @generated from protobuf field: int64 rounds = 1;
     */
    rounds: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.PBKDF2SHA256
 */
export interface PBKDF2SHA256 {
    /**
     * @generated from protobuf field: int64 rounds = 1;
     */
    rounds: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.PBKDFSHA1
 */
export interface PBKDFSHA1 {
    /**
     * @generated from protobuf field: int64 rounds = 1;
     */
    rounds: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.SHA1
 */
export interface SHA1 {
    /**
     * @generated from protobuf field: int64 rounds = 1;
     */
    rounds: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.SHA256
 */
export interface SHA256 {
    /**
     * @generated from protobuf field: int64 rounds = 1;
     */
    rounds: string;
}
/**
 * @generated from protobuf message indykite.identity.v1beta2.SHA512
 */
export interface SHA512 {
    /**
     * @generated from protobuf field: int64 rounds = 1;
     */
    rounds: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class ImportDigitalTwinsRequest$Type extends MessageType<ImportDigitalTwinsRequest> {
    constructor() {
        super("indykite.identity.v1beta2.ImportDigitalTwinsRequest", [
            { no: 1, name: "entities", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ImportDigitalTwin, options: { "validate.rules": { repeated: { minItems: "1", maxItems: "1000", items: { message: { required: true } } } } } },
            { no: 2, name: "bcrypt", kind: "message", oneof: "hashAlgorithm", T: () => Bcrypt },
            { no: 3, name: "standard_scrypt", kind: "message", oneof: "hashAlgorithm", T: () => StandardScrypt },
            { no: 4, name: "scrypt", kind: "message", oneof: "hashAlgorithm", T: () => Scrypt },
            { no: 5, name: "hmac_md5", kind: "message", oneof: "hashAlgorithm", T: () => HMACMD5 },
            { no: 6, name: "hmac_sha1", kind: "message", oneof: "hashAlgorithm", T: () => HMACSHA1 },
            { no: 7, name: "hmac_sha512", kind: "message", oneof: "hashAlgorithm", T: () => HMACSHA512 },
            { no: 8, name: "hmac_sha256", kind: "message", oneof: "hashAlgorithm", T: () => HMACSHA256 },
            { no: 9, name: "md5", kind: "message", oneof: "hashAlgorithm", T: () => MD5 },
            { no: 10, name: "pbkdf2_sha256", kind: "message", oneof: "hashAlgorithm", T: () => PBKDF2SHA256 },
            { no: 11, name: "pbkdf_sha1", kind: "message", oneof: "hashAlgorithm", T: () => PBKDFSHA1 },
            { no: 12, name: "sha1", kind: "message", oneof: "hashAlgorithm", T: () => SHA1 },
            { no: 13, name: "sha256", kind: "message", oneof: "hashAlgorithm", T: () => SHA256 },
            { no: 14, name: "sha512", kind: "message", oneof: "hashAlgorithm", T: () => SHA512 }
        ]);
    }
    create(value?: PartialMessage<ImportDigitalTwinsRequest>): ImportDigitalTwinsRequest {
        const message = { entities: [], hashAlgorithm: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportDigitalTwinsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportDigitalTwinsRequest): ImportDigitalTwinsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated indykite.identity.v1beta2.ImportDigitalTwin entities */ 1:
                    message.entities.push(ImportDigitalTwin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* indykite.identity.v1beta2.Bcrypt bcrypt */ 2:
                    message.hashAlgorithm = {
                        oneofKind: "bcrypt",
                        bcrypt: Bcrypt.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).bcrypt)
                    };
                    break;
                case /* indykite.identity.v1beta2.StandardScrypt standard_scrypt */ 3:
                    message.hashAlgorithm = {
                        oneofKind: "standardScrypt",
                        standardScrypt: StandardScrypt.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).standardScrypt)
                    };
                    break;
                case /* indykite.identity.v1beta2.Scrypt scrypt */ 4:
                    message.hashAlgorithm = {
                        oneofKind: "scrypt",
                        scrypt: Scrypt.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).scrypt)
                    };
                    break;
                case /* indykite.identity.v1beta2.HMACMD5 hmac_md5 */ 5:
                    message.hashAlgorithm = {
                        oneofKind: "hmacMd5",
                        hmacMd5: HMACMD5.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).hmacMd5)
                    };
                    break;
                case /* indykite.identity.v1beta2.HMACSHA1 hmac_sha1 */ 6:
                    message.hashAlgorithm = {
                        oneofKind: "hmacSha1",
                        hmacSha1: HMACSHA1.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).hmacSha1)
                    };
                    break;
                case /* indykite.identity.v1beta2.HMACSHA512 hmac_sha512 */ 7:
                    message.hashAlgorithm = {
                        oneofKind: "hmacSha512",
                        hmacSha512: HMACSHA512.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).hmacSha512)
                    };
                    break;
                case /* indykite.identity.v1beta2.HMACSHA256 hmac_sha256 */ 8:
                    message.hashAlgorithm = {
                        oneofKind: "hmacSha256",
                        hmacSha256: HMACSHA256.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).hmacSha256)
                    };
                    break;
                case /* indykite.identity.v1beta2.MD5 md5 */ 9:
                    message.hashAlgorithm = {
                        oneofKind: "md5",
                        md5: MD5.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).md5)
                    };
                    break;
                case /* indykite.identity.v1beta2.PBKDF2SHA256 pbkdf2_sha256 */ 10:
                    message.hashAlgorithm = {
                        oneofKind: "pbkdf2Sha256",
                        pbkdf2Sha256: PBKDF2SHA256.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).pbkdf2Sha256)
                    };
                    break;
                case /* indykite.identity.v1beta2.PBKDFSHA1 pbkdf_sha1 */ 11:
                    message.hashAlgorithm = {
                        oneofKind: "pbkdfSha1",
                        pbkdfSha1: PBKDFSHA1.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).pbkdfSha1)
                    };
                    break;
                case /* indykite.identity.v1beta2.SHA1 sha1 */ 12:
                    message.hashAlgorithm = {
                        oneofKind: "sha1",
                        sha1: SHA1.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).sha1)
                    };
                    break;
                case /* indykite.identity.v1beta2.SHA256 sha256 */ 13:
                    message.hashAlgorithm = {
                        oneofKind: "sha256",
                        sha256: SHA256.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).sha256)
                    };
                    break;
                case /* indykite.identity.v1beta2.SHA512 sha512 */ 14:
                    message.hashAlgorithm = {
                        oneofKind: "sha512",
                        sha512: SHA512.internalBinaryRead(reader, reader.uint32(), options, (message.hashAlgorithm as any).sha512)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportDigitalTwinsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated indykite.identity.v1beta2.ImportDigitalTwin entities = 1; */
        for (let i = 0; i < message.entities.length; i++)
            ImportDigitalTwin.internalBinaryWrite(message.entities[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.Bcrypt bcrypt = 2; */
        if (message.hashAlgorithm.oneofKind === "bcrypt")
            Bcrypt.internalBinaryWrite(message.hashAlgorithm.bcrypt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.StandardScrypt standard_scrypt = 3; */
        if (message.hashAlgorithm.oneofKind === "standardScrypt")
            StandardScrypt.internalBinaryWrite(message.hashAlgorithm.standardScrypt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.Scrypt scrypt = 4; */
        if (message.hashAlgorithm.oneofKind === "scrypt")
            Scrypt.internalBinaryWrite(message.hashAlgorithm.scrypt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.HMACMD5 hmac_md5 = 5; */
        if (message.hashAlgorithm.oneofKind === "hmacMd5")
            HMACMD5.internalBinaryWrite(message.hashAlgorithm.hmacMd5, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.HMACSHA1 hmac_sha1 = 6; */
        if (message.hashAlgorithm.oneofKind === "hmacSha1")
            HMACSHA1.internalBinaryWrite(message.hashAlgorithm.hmacSha1, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.HMACSHA512 hmac_sha512 = 7; */
        if (message.hashAlgorithm.oneofKind === "hmacSha512")
            HMACSHA512.internalBinaryWrite(message.hashAlgorithm.hmacSha512, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.HMACSHA256 hmac_sha256 = 8; */
        if (message.hashAlgorithm.oneofKind === "hmacSha256")
            HMACSHA256.internalBinaryWrite(message.hashAlgorithm.hmacSha256, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.MD5 md5 = 9; */
        if (message.hashAlgorithm.oneofKind === "md5")
            MD5.internalBinaryWrite(message.hashAlgorithm.md5, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.PBKDF2SHA256 pbkdf2_sha256 = 10; */
        if (message.hashAlgorithm.oneofKind === "pbkdf2Sha256")
            PBKDF2SHA256.internalBinaryWrite(message.hashAlgorithm.pbkdf2Sha256, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.PBKDFSHA1 pbkdf_sha1 = 11; */
        if (message.hashAlgorithm.oneofKind === "pbkdfSha1")
            PBKDFSHA1.internalBinaryWrite(message.hashAlgorithm.pbkdfSha1, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.SHA1 sha1 = 12; */
        if (message.hashAlgorithm.oneofKind === "sha1")
            SHA1.internalBinaryWrite(message.hashAlgorithm.sha1, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.SHA256 sha256 = 13; */
        if (message.hashAlgorithm.oneofKind === "sha256")
            SHA256.internalBinaryWrite(message.hashAlgorithm.sha256, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.SHA512 sha512 = 14; */
        if (message.hashAlgorithm.oneofKind === "sha512")
            SHA512.internalBinaryWrite(message.hashAlgorithm.sha512, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.ImportDigitalTwinsRequest
 */
export const ImportDigitalTwinsRequest = new ImportDigitalTwinsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportDigitalTwinSuccess$Type extends MessageType<ImportDigitalTwinSuccess> {
    constructor() {
        super("indykite.identity.v1beta2.ImportDigitalTwinSuccess", [
            { no: 1, name: "digital_twin", kind: "message", T: () => DigitalTwin },
            { no: 2, name: "results", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BatchOperationResult }
        ]);
    }
    create(value?: PartialMessage<ImportDigitalTwinSuccess>): ImportDigitalTwinSuccess {
        const message = { results: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportDigitalTwinSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportDigitalTwinSuccess): ImportDigitalTwinSuccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta2.DigitalTwin digital_twin */ 1:
                    message.digitalTwin = DigitalTwin.internalBinaryRead(reader, reader.uint32(), options, message.digitalTwin);
                    break;
                case /* repeated indykite.identity.v1beta2.BatchOperationResult results */ 2:
                    message.results.push(BatchOperationResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportDigitalTwinSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta2.DigitalTwin digital_twin = 1; */
        if (message.digitalTwin)
            DigitalTwin.internalBinaryWrite(message.digitalTwin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated indykite.identity.v1beta2.BatchOperationResult results = 2; */
        for (let i = 0; i < message.results.length; i++)
            BatchOperationResult.internalBinaryWrite(message.results[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.ImportDigitalTwinSuccess
 */
export const ImportDigitalTwinSuccess = new ImportDigitalTwinSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportDigitalTwinError$Type extends MessageType<ImportDigitalTwinError> {
    constructor() {
        super("indykite.identity.v1beta2.ImportDigitalTwinError", [
            { no: 1, name: "message", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImportDigitalTwinError>): ImportDigitalTwinError {
        const message = { message: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportDigitalTwinError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportDigitalTwinError): ImportDigitalTwinError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string message */ 1:
                    message.message.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportDigitalTwinError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string message = 1; */
        for (let i = 0; i < message.message.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.message[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.ImportDigitalTwinError
 */
export const ImportDigitalTwinError = new ImportDigitalTwinError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportDigitalTwinResult$Type extends MessageType<ImportDigitalTwinResult> {
    constructor() {
        super("indykite.identity.v1beta2.ImportDigitalTwinResult", [
            { no: 1, name: "index", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "success", kind: "message", oneof: "result", T: () => ImportDigitalTwinSuccess },
            { no: 3, name: "error", kind: "message", oneof: "result", T: () => ImportDigitalTwinError }
        ]);
    }
    create(value?: PartialMessage<ImportDigitalTwinResult>): ImportDigitalTwinResult {
        const message = { index: "0", result: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportDigitalTwinResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportDigitalTwinResult): ImportDigitalTwinResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 index */ 1:
                    message.index = reader.uint64().toString();
                    break;
                case /* indykite.identity.v1beta2.ImportDigitalTwinSuccess success */ 2:
                    message.result = {
                        oneofKind: "success",
                        success: ImportDigitalTwinSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).success)
                    };
                    break;
                case /* indykite.identity.v1beta2.ImportDigitalTwinError error */ 3:
                    message.result = {
                        oneofKind: "error",
                        error: ImportDigitalTwinError.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportDigitalTwinResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 index = 1; */
        if (message.index !== "0")
            writer.tag(1, WireType.Varint).uint64(message.index);
        /* indykite.identity.v1beta2.ImportDigitalTwinSuccess success = 2; */
        if (message.result.oneofKind === "success")
            ImportDigitalTwinSuccess.internalBinaryWrite(message.result.success, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.ImportDigitalTwinError error = 3; */
        if (message.result.oneofKind === "error")
            ImportDigitalTwinError.internalBinaryWrite(message.result.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.ImportDigitalTwinResult
 */
export const ImportDigitalTwinResult = new ImportDigitalTwinResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportDigitalTwinsResponse$Type extends MessageType<ImportDigitalTwinsResponse> {
    constructor() {
        super("indykite.identity.v1beta2.ImportDigitalTwinsResponse", [
            { no: 1, name: "results", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ImportDigitalTwinResult }
        ]);
    }
    create(value?: PartialMessage<ImportDigitalTwinsResponse>): ImportDigitalTwinsResponse {
        const message = { results: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportDigitalTwinsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportDigitalTwinsResponse): ImportDigitalTwinsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated indykite.identity.v1beta2.ImportDigitalTwinResult results */ 1:
                    message.results.push(ImportDigitalTwinResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportDigitalTwinsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated indykite.identity.v1beta2.ImportDigitalTwinResult results = 1; */
        for (let i = 0; i < message.results.length; i++)
            ImportDigitalTwinResult.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.ImportDigitalTwinsResponse
 */
export const ImportDigitalTwinsResponse = new ImportDigitalTwinsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportDigitalTwin$Type extends MessageType<ImportDigitalTwin> {
    constructor() {
        super("indykite.identity.v1beta2.ImportDigitalTwin", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "27", maxLen: "100", pattern: "^gid:[A-Za-z0-9-_]{27,100}$", ignoreEmpty: true } } } },
            { no: 2, name: "tenant_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "27", maxLen: "100", pattern: "^gid:[A-Za-z0-9-_]{27,100}$" } } } },
            { no: 3, name: "kind", kind: "enum", T: () => ["indykite.identity.v1beta2.DigitalTwinKind", DigitalTwinKind, "DIGITAL_TWIN_KIND_"], options: { "validate.rules": { enum: { definedOnly: true, in: [1, 3] } } } },
            { no: 4, name: "state", kind: "enum", T: () => ["indykite.identity.v1beta2.DigitalTwinState", DigitalTwinState, "DIGITAL_TWIN_STATE_"], options: { "validate.rules": { enum: { definedOnly: true, in: [1, 2] } } } },
            { no: 5, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { maxItems: "32", unique: true, items: { string: { maxLen: "64", pattern: "^([A-Z][a-z]+)+$" } } } } } },
            { no: 6, name: "password", kind: "message", T: () => PasswordCredential },
            { no: 7, name: "provider_user_info", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UserProvider, options: { "validate.rules": { repeated: { minItems: "0", maxItems: "10", items: { message: { required: true } } } } } },
            { no: 8, name: "properties", kind: "message", T: () => ImportProperties },
            { no: 9, name: "metadata", kind: "message", T: () => UserMetadata }
        ]);
    }
    create(value?: PartialMessage<ImportDigitalTwin>): ImportDigitalTwin {
        const message = { id: "", tenantId: "", kind: 0, state: 0, tags: [], providerUserInfo: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportDigitalTwin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportDigitalTwin): ImportDigitalTwin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string tenant_id */ 2:
                    message.tenantId = reader.string();
                    break;
                case /* indykite.identity.v1beta2.DigitalTwinKind kind */ 3:
                    message.kind = reader.int32();
                    break;
                case /* indykite.identity.v1beta2.DigitalTwinState state */ 4:
                    message.state = reader.int32();
                    break;
                case /* repeated string tags */ 5:
                    message.tags.push(reader.string());
                    break;
                case /* indykite.identity.v1beta2.PasswordCredential password */ 6:
                    message.password = PasswordCredential.internalBinaryRead(reader, reader.uint32(), options, message.password);
                    break;
                case /* repeated indykite.identity.v1beta2.UserProvider provider_user_info */ 7:
                    message.providerUserInfo.push(UserProvider.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* indykite.identity.v1beta2.ImportProperties properties */ 8:
                    message.properties = ImportProperties.internalBinaryRead(reader, reader.uint32(), options, message.properties);
                    break;
                case /* indykite.identity.v1beta2.UserMetadata metadata */ 9:
                    message.metadata = UserMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportDigitalTwin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string tenant_id = 2; */
        if (message.tenantId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tenantId);
        /* indykite.identity.v1beta2.DigitalTwinKind kind = 3; */
        if (message.kind !== 0)
            writer.tag(3, WireType.Varint).int32(message.kind);
        /* indykite.identity.v1beta2.DigitalTwinState state = 4; */
        if (message.state !== 0)
            writer.tag(4, WireType.Varint).int32(message.state);
        /* repeated string tags = 5; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.tags[i]);
        /* indykite.identity.v1beta2.PasswordCredential password = 6; */
        if (message.password)
            PasswordCredential.internalBinaryWrite(message.password, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated indykite.identity.v1beta2.UserProvider provider_user_info = 7; */
        for (let i = 0; i < message.providerUserInfo.length; i++)
            UserProvider.internalBinaryWrite(message.providerUserInfo[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.ImportProperties properties = 8; */
        if (message.properties)
            ImportProperties.internalBinaryWrite(message.properties, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.UserMetadata metadata = 9; */
        if (message.metadata)
            UserMetadata.internalBinaryWrite(message.metadata, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.ImportDigitalTwin
 */
export const ImportDigitalTwin = new ImportDigitalTwin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportProperties$Type extends MessageType<ImportProperties> {
    constructor() {
        super("indykite.identity.v1beta2.ImportProperties", [
            { no: 2, name: "operations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PropertyBatchOperation, options: { "validate.rules": { repeated: { minItems: "1", items: { message: { required: true } } } } } },
            { no: 4, name: "force_delete", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ImportProperties>): ImportProperties {
        const message = { operations: [], forceDelete: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportProperties>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportProperties): ImportProperties {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated indykite.identity.v1beta2.PropertyBatchOperation operations */ 2:
                    message.operations.push(PropertyBatchOperation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool force_delete */ 4:
                    message.forceDelete = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportProperties, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated indykite.identity.v1beta2.PropertyBatchOperation operations = 2; */
        for (let i = 0; i < message.operations.length; i++)
            PropertyBatchOperation.internalBinaryWrite(message.operations[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool force_delete = 4; */
        if (message.forceDelete !== false)
            writer.tag(4, WireType.Varint).bool(message.forceDelete);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.ImportProperties
 */
export const ImportProperties = new ImportProperties$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserMetadata$Type extends MessageType<UserMetadata> {
    constructor() {
        super("indykite.identity.v1beta2.UserMetadata", [
            { no: 1, name: "creation_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "last_log_in_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "last_refresh_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<UserMetadata>): UserMetadata {
        const message = { creationTimestamp: "0", lastLogInTimestamp: "0", lastRefreshTimestamp: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserMetadata): UserMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 creation_timestamp */ 1:
                    message.creationTimestamp = reader.int64().toString();
                    break;
                case /* int64 last_log_in_timestamp */ 2:
                    message.lastLogInTimestamp = reader.int64().toString();
                    break;
                case /* int64 last_refresh_timestamp */ 3:
                    message.lastRefreshTimestamp = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 creation_timestamp = 1; */
        if (message.creationTimestamp !== "0")
            writer.tag(1, WireType.Varint).int64(message.creationTimestamp);
        /* int64 last_log_in_timestamp = 2; */
        if (message.lastLogInTimestamp !== "0")
            writer.tag(2, WireType.Varint).int64(message.lastLogInTimestamp);
        /* int64 last_refresh_timestamp = 3; */
        if (message.lastRefreshTimestamp !== "0")
            writer.tag(3, WireType.Varint).int64(message.lastRefreshTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.UserMetadata
 */
export const UserMetadata = new UserMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserProvider$Type extends MessageType<UserProvider> {
    constructor() {
        super("indykite.identity.v1beta2.UserProvider", [
            { no: 1, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "provider_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "photo_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserProvider>): UserProvider {
        const message = { uid: "", providerId: "", email: "", displayName: "", photoUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserProvider>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserProvider): UserProvider {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uid */ 1:
                    message.uid = reader.string();
                    break;
                case /* string provider_id */ 2:
                    message.providerId = reader.string();
                    break;
                case /* string email */ 3:
                    message.email = reader.string();
                    break;
                case /* string display_name */ 4:
                    message.displayName = reader.string();
                    break;
                case /* string photo_url */ 5:
                    message.photoUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserProvider, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uid = 1; */
        if (message.uid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uid);
        /* string provider_id = 2; */
        if (message.providerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.providerId);
        /* string email = 3; */
        if (message.email !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        /* string display_name = 4; */
        if (message.displayName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.displayName);
        /* string photo_url = 5; */
        if (message.photoUrl !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.photoUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.UserProvider
 */
export const UserProvider = new UserProvider$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Email$Type extends MessageType<Email> {
    constructor() {
        super("indykite.identity.v1beta2.Email", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "verified", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Email>): Email {
        const message = { email: "", verified: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Email>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Email): Email {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                case /* bool verified */ 2:
                    message.verified = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Email, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        /* bool verified = 2; */
        if (message.verified !== false)
            writer.tag(2, WireType.Varint).bool(message.verified);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.Email
 */
export const Email = new Email$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Mobile$Type extends MessageType<Mobile> {
    constructor() {
        super("indykite.identity.v1beta2.Mobile", [
            { no: 1, name: "mobile", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { pattern: "^+.*[0-9A-Za-z]{7,16}$", ignoreEmpty: true } } } },
            { no: 2, name: "verified", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Mobile>): Mobile {
        const message = { mobile: "", verified: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Mobile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Mobile): Mobile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mobile */ 1:
                    message.mobile = reader.string();
                    break;
                case /* bool verified */ 2:
                    message.verified = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Mobile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mobile = 1; */
        if (message.mobile !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mobile);
        /* bool verified = 2; */
        if (message.verified !== false)
            writer.tag(2, WireType.Varint).bool(message.verified);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.Mobile
 */
export const Mobile = new Mobile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasswordCredential$Type extends MessageType<PasswordCredential> {
    constructor() {
        super("indykite.identity.v1beta2.PasswordCredential", [
            { no: 1, name: "email", kind: "message", oneof: "uid", T: () => Email },
            { no: 2, name: "mobile", kind: "message", oneof: "uid", T: () => Mobile },
            { no: 3, name: "username", kind: "scalar", oneof: "uid", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "value", kind: "scalar", oneof: "password", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "hash", kind: "message", oneof: "password", T: () => PasswordHash }
        ]);
    }
    create(value?: PartialMessage<PasswordCredential>): PasswordCredential {
        const message = { uid: { oneofKind: undefined }, password: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PasswordCredential>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PasswordCredential): PasswordCredential {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.identity.v1beta2.Email email */ 1:
                    message.uid = {
                        oneofKind: "email",
                        email: Email.internalBinaryRead(reader, reader.uint32(), options, (message.uid as any).email)
                    };
                    break;
                case /* indykite.identity.v1beta2.Mobile mobile */ 2:
                    message.uid = {
                        oneofKind: "mobile",
                        mobile: Mobile.internalBinaryRead(reader, reader.uint32(), options, (message.uid as any).mobile)
                    };
                    break;
                case /* string username */ 3:
                    message.uid = {
                        oneofKind: "username",
                        username: reader.string()
                    };
                    break;
                case /* string value */ 4:
                    message.password = {
                        oneofKind: "value",
                        value: reader.string()
                    };
                    break;
                case /* indykite.identity.v1beta2.PasswordHash hash */ 5:
                    message.password = {
                        oneofKind: "hash",
                        hash: PasswordHash.internalBinaryRead(reader, reader.uint32(), options, (message.password as any).hash)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PasswordCredential, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.identity.v1beta2.Email email = 1; */
        if (message.uid.oneofKind === "email")
            Email.internalBinaryWrite(message.uid.email, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* indykite.identity.v1beta2.Mobile mobile = 2; */
        if (message.uid.oneofKind === "mobile")
            Mobile.internalBinaryWrite(message.uid.mobile, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string username = 3; */
        if (message.uid.oneofKind === "username")
            writer.tag(3, WireType.LengthDelimited).string(message.uid.username);
        /* string value = 4; */
        if (message.password.oneofKind === "value")
            writer.tag(4, WireType.LengthDelimited).string(message.password.value);
        /* indykite.identity.v1beta2.PasswordHash hash = 5; */
        if (message.password.oneofKind === "hash")
            PasswordHash.internalBinaryWrite(message.password.hash, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.PasswordCredential
 */
export const PasswordCredential = new PasswordCredential$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasswordHash$Type extends MessageType<PasswordHash> {
    constructor() {
        super("indykite.identity.v1beta2.PasswordHash", [
            { no: 4, name: "password_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "salt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PasswordHash>): PasswordHash {
        const message = { passwordHash: new Uint8Array(0), salt: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PasswordHash>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PasswordHash): PasswordHash {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes password_hash */ 4:
                    message.passwordHash = reader.bytes();
                    break;
                case /* bytes salt */ 5:
                    message.salt = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PasswordHash, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes password_hash = 4; */
        if (message.passwordHash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.passwordHash);
        /* bytes salt = 5; */
        if (message.salt.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.salt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.PasswordHash
 */
export const PasswordHash = new PasswordHash$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bcrypt$Type extends MessageType<Bcrypt> {
    constructor() {
        super("indykite.identity.v1beta2.Bcrypt", []);
    }
    create(value?: PartialMessage<Bcrypt>): Bcrypt {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Bcrypt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bcrypt): Bcrypt {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Bcrypt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.Bcrypt
 */
export const Bcrypt = new Bcrypt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StandardScrypt$Type extends MessageType<StandardScrypt> {
    constructor() {
        super("indykite.identity.v1beta2.StandardScrypt", [
            { no: 1, name: "block_size", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "derived_key_length", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "memory_cost", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "parallelization", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<StandardScrypt>): StandardScrypt {
        const message = { blockSize: "0", derivedKeyLength: "0", memoryCost: "0", parallelization: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StandardScrypt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StandardScrypt): StandardScrypt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 block_size */ 1:
                    message.blockSize = reader.int64().toString();
                    break;
                case /* int64 derived_key_length */ 2:
                    message.derivedKeyLength = reader.int64().toString();
                    break;
                case /* int64 memory_cost */ 3:
                    message.memoryCost = reader.int64().toString();
                    break;
                case /* int64 parallelization */ 4:
                    message.parallelization = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StandardScrypt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 block_size = 1; */
        if (message.blockSize !== "0")
            writer.tag(1, WireType.Varint).int64(message.blockSize);
        /* int64 derived_key_length = 2; */
        if (message.derivedKeyLength !== "0")
            writer.tag(2, WireType.Varint).int64(message.derivedKeyLength);
        /* int64 memory_cost = 3; */
        if (message.memoryCost !== "0")
            writer.tag(3, WireType.Varint).int64(message.memoryCost);
        /* int64 parallelization = 4; */
        if (message.parallelization !== "0")
            writer.tag(4, WireType.Varint).int64(message.parallelization);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.StandardScrypt
 */
export const StandardScrypt = new StandardScrypt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Scrypt$Type extends MessageType<Scrypt> {
    constructor() {
        super("indykite.identity.v1beta2.Scrypt", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "salt_separator", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "rounds", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "memory_cost", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<Scrypt>): Scrypt {
        const message = { key: new Uint8Array(0), saltSeparator: new Uint8Array(0), rounds: "0", memoryCost: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Scrypt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Scrypt): Scrypt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                case /* bytes salt_separator */ 2:
                    message.saltSeparator = reader.bytes();
                    break;
                case /* int64 rounds */ 3:
                    message.rounds = reader.int64().toString();
                    break;
                case /* int64 memory_cost */ 4:
                    message.memoryCost = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Scrypt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        /* bytes salt_separator = 2; */
        if (message.saltSeparator.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.saltSeparator);
        /* int64 rounds = 3; */
        if (message.rounds !== "0")
            writer.tag(3, WireType.Varint).int64(message.rounds);
        /* int64 memory_cost = 4; */
        if (message.memoryCost !== "0")
            writer.tag(4, WireType.Varint).int64(message.memoryCost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.Scrypt
 */
export const Scrypt = new Scrypt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HMACMD5$Type extends MessageType<HMACMD5> {
    constructor() {
        super("indykite.identity.v1beta2.HMACMD5", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HMACMD5>): HMACMD5 {
        const message = { key: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HMACMD5>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HMACMD5): HMACMD5 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HMACMD5, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.HMACMD5
 */
export const HMACMD5 = new HMACMD5$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HMACSHA1$Type extends MessageType<HMACSHA1> {
    constructor() {
        super("indykite.identity.v1beta2.HMACSHA1", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HMACSHA1>): HMACSHA1 {
        const message = { key: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HMACSHA1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HMACSHA1): HMACSHA1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HMACSHA1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.HMACSHA1
 */
export const HMACSHA1 = new HMACSHA1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HMACSHA512$Type extends MessageType<HMACSHA512> {
    constructor() {
        super("indykite.identity.v1beta2.HMACSHA512", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HMACSHA512>): HMACSHA512 {
        const message = { key: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HMACSHA512>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HMACSHA512): HMACSHA512 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HMACSHA512, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.HMACSHA512
 */
export const HMACSHA512 = new HMACSHA512$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HMACSHA256$Type extends MessageType<HMACSHA256> {
    constructor() {
        super("indykite.identity.v1beta2.HMACSHA256", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HMACSHA256>): HMACSHA256 {
        const message = { key: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HMACSHA256>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HMACSHA256): HMACSHA256 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HMACSHA256, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.HMACSHA256
 */
export const HMACSHA256 = new HMACSHA256$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MD5$Type extends MessageType<MD5> {
    constructor() {
        super("indykite.identity.v1beta2.MD5", [
            { no: 1, name: "rounds", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<MD5>): MD5 {
        const message = { rounds: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MD5>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MD5): MD5 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 rounds */ 1:
                    message.rounds = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MD5, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 rounds = 1; */
        if (message.rounds !== "0")
            writer.tag(1, WireType.Varint).int64(message.rounds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.MD5
 */
export const MD5 = new MD5$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PBKDF2SHA256$Type extends MessageType<PBKDF2SHA256> {
    constructor() {
        super("indykite.identity.v1beta2.PBKDF2SHA256", [
            { no: 1, name: "rounds", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<PBKDF2SHA256>): PBKDF2SHA256 {
        const message = { rounds: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PBKDF2SHA256>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PBKDF2SHA256): PBKDF2SHA256 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 rounds */ 1:
                    message.rounds = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PBKDF2SHA256, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 rounds = 1; */
        if (message.rounds !== "0")
            writer.tag(1, WireType.Varint).int64(message.rounds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.PBKDF2SHA256
 */
export const PBKDF2SHA256 = new PBKDF2SHA256$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PBKDFSHA1$Type extends MessageType<PBKDFSHA1> {
    constructor() {
        super("indykite.identity.v1beta2.PBKDFSHA1", [
            { no: 1, name: "rounds", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<PBKDFSHA1>): PBKDFSHA1 {
        const message = { rounds: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PBKDFSHA1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PBKDFSHA1): PBKDFSHA1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 rounds */ 1:
                    message.rounds = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PBKDFSHA1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 rounds = 1; */
        if (message.rounds !== "0")
            writer.tag(1, WireType.Varint).int64(message.rounds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.PBKDFSHA1
 */
export const PBKDFSHA1 = new PBKDFSHA1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SHA1$Type extends MessageType<SHA1> {
    constructor() {
        super("indykite.identity.v1beta2.SHA1", [
            { no: 1, name: "rounds", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<SHA1>): SHA1 {
        const message = { rounds: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SHA1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SHA1): SHA1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 rounds */ 1:
                    message.rounds = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SHA1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 rounds = 1; */
        if (message.rounds !== "0")
            writer.tag(1, WireType.Varint).int64(message.rounds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.SHA1
 */
export const SHA1 = new SHA1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SHA256$Type extends MessageType<SHA256> {
    constructor() {
        super("indykite.identity.v1beta2.SHA256", [
            { no: 1, name: "rounds", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<SHA256>): SHA256 {
        const message = { rounds: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SHA256>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SHA256): SHA256 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 rounds */ 1:
                    message.rounds = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SHA256, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 rounds = 1; */
        if (message.rounds !== "0")
            writer.tag(1, WireType.Varint).int64(message.rounds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.SHA256
 */
export const SHA256 = new SHA256$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SHA512$Type extends MessageType<SHA512> {
    constructor() {
        super("indykite.identity.v1beta2.SHA512", [
            { no: 1, name: "rounds", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<SHA512>): SHA512 {
        const message = { rounds: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SHA512>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SHA512): SHA512 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 rounds */ 1:
                    message.rounds = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SHA512, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 rounds = 1; */
        if (message.rounds !== "0")
            writer.tag(1, WireType.Varint).int64(message.rounds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.identity.v1beta2.SHA512
 */
export const SHA512 = new SHA512$Type();
