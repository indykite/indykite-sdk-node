// @generated by protobuf-ts 2.9.0 with parameter long_type_string,client_grpc1,generate_dependencies
// @generated from protobuf file "indykite/auditsink/v1beta1/config.proto" (package "indykite.auditsink.v1beta1", syntax proto3)
// tslint:disable
//
// Copyright (c) 2023 IndyKite
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ReadConfig
 */
export interface ReadConfig {
    /**
     * @generated from protobuf oneof: identifier
     */
    identifier: {
        oneofKind: "id";
        /**
         * @generated from protobuf field: string id = 1;
         */
        id: string;
    } | {
        oneofKind: "name";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.ReadConfig.NameIdentifier name = 2;
         */
        name: ReadConfig_NameIdentifier;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType type = 3;
     */
    type: ConfigType;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ReadConfig.NameIdentifier
 */
export interface ReadConfig_NameIdentifier {
    /**
     * @generated from protobuf field: string location_id = 1;
     */
    locationId: string;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType location_type = 2;
     */
    locationType: ConfigType;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.DeletedConfig
 */
export interface DeletedConfig {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType type = 2;
     */
    type: ConfigType;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.CreateAuthorizationPolicy
 */
export interface CreateAuthorizationPolicy {
    /**
     * Policy in JSON string format.
     *
     * @generated from protobuf field: string policy = 1;
     */
    policy: string;
    /**
     * Policy status.
     *
     * @generated from protobuf field: indykite.auditsink.v1beta1.CreateAuthorizationPolicy.Status status = 2;
     */
    status: CreateAuthorizationPolicy_Status;
    /**
     * Optional policy tags
     *
     * @generated from protobuf field: repeated string tags = 3;
     */
    tags: string[];
    /**
     * @generated from protobuf field: string display_name = 4;
     */
    displayName: string;
}
/**
 * @generated from protobuf enum indykite.auditsink.v1beta1.CreateAuthorizationPolicy.Status
 */
export enum CreateAuthorizationPolicy_Status {
    /**
     * @generated from protobuf enum value: STATUS_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: STATUS_ACTIVE = 1;
     */
    ACTIVE = 1,
    /**
     * @generated from protobuf enum value: STATUS_INACTIVE = 2;
     */
    INACTIVE = 2
}
/**
 * ConfigType is equivalent to internal DocumentType, for easier maintenance keep same numbers.
 *
 * @generated from protobuf enum indykite.auditsink.v1beta1.ConfigType
 */
export enum ConfigType {
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_CUSTOMER = 1;
     */
    CUSTOMER = 1,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_APP_SPACE = 2;
     */
    APP_SPACE = 2,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_ISSUER = 15;
     */
    ISSUER = 15,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_TENANT = 3;
     */
    TENANT = 3,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_APPLICATION = 4;
     */
    APPLICATION = 4,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_APP_AGENT = 5;
     */
    APP_AGENT = 5,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_APP_AGENT_CREDENTIAL = 6;
     */
    APP_AGENT_CREDENTIAL = 6,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_SERVICE_ACCOUNT = 18;
     */
    SERVICE_ACCOUNT = 18,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_SERVICE_CREDENTIAL = 19;
     */
    SERVICE_CREDENTIAL = 19,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_AUTH_FLOW = 7;
     */
    AUTH_FLOW = 7,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_EMAIL_SERVICE = 8;
     */
    EMAIL_SERVICE = 8,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_SMS_SERVICE = 9;
     */
    SMS_SERVICE = 9,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_AUDIT_SINK = 27;
     */
    AUDIT_SINK = 27,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_OAUTH2_CLIENT = 10;
     */
    OAUTH2_CLIENT = 10,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_OAUTH2_APPLICATION = 11;
     */
    OAUTH2_APPLICATION = 11,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_OAUTH2_PROVIDER = 17;
     */
    OAUTH2_PROVIDER = 17,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_PASSWORD_PROVIDER = 12;
     */
    PASSWORD_PROVIDER = 12,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_WEBAUTHN_PROVIDER = 13;
     */
    WEBAUTHN_PROVIDER = 13,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_AUTHENTEQ_PROVIDER = 14;
     */
    AUTHENTEQ_PROVIDER = 14,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_SAFR_PROVIDER = 16;
     */
    SAFR_PROVIDER = 16,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_READID_PROVIDER = 24;
     */
    READID_PROVIDER = 24,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_AUTHORIZATION_POLICY = 22;
     */
    AUTHORIZATION_POLICY = 22,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_KNOWLEDGE_GRAPH_SCHEMA = 23;
     */
    KNOWLEDGE_GRAPH_SCHEMA = 23
}
// @generated message type with reflection information, may provide speed optimized methods
class ReadConfig$Type extends MessageType<ReadConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.ReadConfig", [
            { no: 1, name: "id", kind: "scalar", oneof: "identifier", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "message", oneof: "identifier", T: () => ReadConfig_NameIdentifier },
            { no: 3, name: "type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<ReadConfig>): ReadConfig {
        const message = { identifier: { oneofKind: undefined }, type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadConfig): ReadConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.identifier = {
                        oneofKind: "id",
                        id: reader.string()
                    };
                    break;
                case /* indykite.auditsink.v1beta1.ReadConfig.NameIdentifier name */ 2:
                    message.identifier = {
                        oneofKind: "name",
                        name: ReadConfig_NameIdentifier.internalBinaryRead(reader, reader.uint32(), options, (message.identifier as any).name)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType type */ 3:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.identifier.oneofKind === "id")
            writer.tag(1, WireType.LengthDelimited).string(message.identifier.id);
        /* indykite.auditsink.v1beta1.ReadConfig.NameIdentifier name = 2; */
        if (message.identifier.oneofKind === "name")
            ReadConfig_NameIdentifier.internalBinaryWrite(message.identifier.name, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ConfigType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ReadConfig
 */
export const ReadConfig = new ReadConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadConfig_NameIdentifier$Type extends MessageType<ReadConfig_NameIdentifier> {
    constructor() {
        super("indykite.auditsink.v1beta1.ReadConfig.NameIdentifier", [
            { no: 1, name: "location_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "location_type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReadConfig_NameIdentifier>): ReadConfig_NameIdentifier {
        const message = { locationId: "", locationType: 0, name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadConfig_NameIdentifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadConfig_NameIdentifier): ReadConfig_NameIdentifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string location_id */ 1:
                    message.locationId = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType location_type */ 2:
                    message.locationType = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadConfig_NameIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string location_id = 1; */
        if (message.locationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationId);
        /* indykite.auditsink.v1beta1.ConfigType location_type = 2; */
        if (message.locationType !== 0)
            writer.tag(2, WireType.Varint).int32(message.locationType);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ReadConfig.NameIdentifier
 */
export const ReadConfig_NameIdentifier = new ReadConfig_NameIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletedConfig$Type extends MessageType<DeletedConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.DeletedConfig", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<DeletedConfig>): DeletedConfig {
        const message = { id: "", type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeletedConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletedConfig): DeletedConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletedConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* indykite.auditsink.v1beta1.ConfigType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.DeletedConfig
 */
export const DeletedConfig = new DeletedConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateAuthorizationPolicy$Type extends MessageType<CreateAuthorizationPolicy> {
    constructor() {
        super("indykite.auditsink.v1beta1.CreateAuthorizationPolicy", [
            { no: 1, name: "policy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["indykite.auditsink.v1beta1.CreateAuthorizationPolicy.Status", CreateAuthorizationPolicy_Status, "STATUS_"] },
            { no: 3, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateAuthorizationPolicy>): CreateAuthorizationPolicy {
        const message = { policy: "", status: 0, tags: [], displayName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateAuthorizationPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateAuthorizationPolicy): CreateAuthorizationPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string policy */ 1:
                    message.policy = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.CreateAuthorizationPolicy.Status status */ 2:
                    message.status = reader.int32();
                    break;
                case /* repeated string tags */ 3:
                    message.tags.push(reader.string());
                    break;
                case /* string display_name */ 4:
                    message.displayName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateAuthorizationPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string policy = 1; */
        if (message.policy !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.policy);
        /* indykite.auditsink.v1beta1.CreateAuthorizationPolicy.Status status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* repeated string tags = 3; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.tags[i]);
        /* string display_name = 4; */
        if (message.displayName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.displayName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.CreateAuthorizationPolicy
 */
export const CreateAuthorizationPolicy = new CreateAuthorizationPolicy$Type();
