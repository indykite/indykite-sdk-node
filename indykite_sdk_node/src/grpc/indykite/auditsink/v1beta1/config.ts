// @generated by protobuf-ts 2.9.0 with parameter long_type_string,client_grpc1,generate_dependencies
// @generated from protobuf file "indykite/auditsink/v1beta1/config.proto" (package "indykite.auditsink.v1beta1", syntax proto3)
// tslint:disable
//
// Copyright (c) 2023 IndyKite
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { IngestPipelineConfig } from "../../config/v1beta1/model";
import { ConsentConfiguration } from "../../config/v1beta1/model";
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ContainersPath
 */
export interface ContainersPath {
    /**
     * @generated from protobuf field: string customer_id = 1;
     */
    customerId: string;
    /**
     * @generated from protobuf field: string application_space_id = 2;
     */
    applicationSpaceId: string;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.CreatedConfig
 */
export interface CreatedConfig {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType type = 2;
     */
    type: ConfigType;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.CreatedConfig.Location location = 3;
     */
    location?: CreatedConfig_Location;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ContainersPath containers_path = 5;
     */
    containersPath?: ContainersPath;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigDetail detail = 4;
     */
    detail?: ConfigDetail;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.CreatedConfig.Location
 */
export interface CreatedConfig_Location {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType type = 2;
     */
    type: ConfigType;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ReadConfig
 */
export interface ReadConfig {
    /**
     * @generated from protobuf oneof: identifier
     */
    identifier: {
        oneofKind: "id";
        /**
         * @generated from protobuf field: string id = 1;
         */
        id: string;
    } | {
        oneofKind: "name";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.ReadConfig.NameIdentifier name = 2;
         */
        name: ReadConfig_NameIdentifier;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ContainersPath containers_path = 4;
     */
    containersPath?: ContainersPath;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType type = 3;
     */
    type: ConfigType;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ReadConfig.NameIdentifier
 */
export interface ReadConfig_NameIdentifier {
    /**
     * LocationId specify under which container the name search happen. Might be empty if searching customer.
     *
     * @generated from protobuf field: string location_id = 1;
     */
    locationId: string;
    /**
     * LocationType specify under which container type the name search happen. Might be empty if searching customer.
     *
     * @generated from protobuf field: optional indykite.auditsink.v1beta1.ConfigType location_type = 2;
     */
    locationType?: ConfigType;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.UpdatedConfig
 */
export interface UpdatedConfig {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType type = 2;
     */
    type: ConfigType;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ContainersPath containers_path = 5;
     */
    containersPath?: ContainersPath;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigDetail before = 3;
     */
    before?: ConfigDetail;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigDetail after = 4;
     */
    after?: ConfigDetail;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.DeletedConfig
 */
export interface DeletedConfig {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType type = 2;
     */
    type: ConfigType;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ContainersPath containers_path = 3;
     */
    containersPath?: ContainersPath;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ConfigDetail
 */
export interface ConfigDetail {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string display_name = 2;
     */
    displayName: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * @generated from protobuf field: int64 version = 4;
     */
    version: string;
    /**
     * @generated from protobuf oneof: configuration
     */
    configuration: {
        oneofKind: "applicationAgentCredential";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.ApplicationAgentCredentialConfig application_agent_credential = 8;
         */
        applicationAgentCredential: ApplicationAgentCredentialConfig;
    } | {
        oneofKind: "serviceAccountCredential";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.ServiceAccountCredentialConfig service_account_credential = 9;
         */
        serviceAccountCredential: ServiceAccountCredentialConfig;
    } | {
        oneofKind: "auditSinkConfig";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.AuditSinkConfig audit_sink_config = 12;
         */
        auditSinkConfig: AuditSinkConfig;
    } | {
        oneofKind: "authorizationPolicyConfig";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.AuthorizationPolicyConfig authorization_policy_config = 15;
         */
        authorizationPolicyConfig: AuthorizationPolicyConfig;
    } | {
        oneofKind: "tokenIntrospectConfig";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.TokenIntrospectConfig token_introspect_config = 19;
         */
        tokenIntrospectConfig: TokenIntrospectConfig;
    } | {
        oneofKind: "consentConfig";
        /**
         * @generated from protobuf field: indykite.config.v1beta1.ConsentConfiguration consent_config = 18;
         */
        consentConfig: ConsentConfiguration;
    } | {
        oneofKind: "ingestPipelineConfig";
        /**
         * @generated from protobuf field: indykite.config.v1beta1.IngestPipelineConfig ingest_pipeline_config = 20;
         */
        ingestPipelineConfig: IngestPipelineConfig;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ApplicationAgentCredentialConfig
 */
export interface ApplicationAgentCredentialConfig {
    /**
     * @generated from protobuf field: string kid = 1;
     */
    kid: string;
    /**
     * KeyFormat specify in which format the public key was provided.
     * Could by empty, if no public key was provided.
     *
     * @generated from protobuf field: string key_format = 2;
     */
    keyFormat: string;
    /**
     * @generated from protobuf field: string original_kid = 3;
     */
    originalKid: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expire_time = 4;
     */
    expireTime?: Timestamp;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ServiceAccountCredentialConfig
 */
export interface ServiceAccountCredentialConfig {
    /**
     * @generated from protobuf field: string kid = 1;
     */
    kid: string;
    /**
     * KeyFormat specify in which format the public key was provided.
     * Could by empty, if no public key was provided.
     *
     * @generated from protobuf field: string key_format = 2;
     */
    keyFormat: string;
    /**
     * @generated from protobuf field: string original_kid = 3;
     */
    originalKid: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expire_time = 4;
     */
    expireTime?: Timestamp;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.AuditSinkConfig
 */
export interface AuditSinkConfig {
    /**
     * @generated from protobuf oneof: provider
     */
    provider: {
        oneofKind: "kafka";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.AuditSinkConfig.Kafka kafka = 1;
         */
        kafka: AuditSinkConfig_Kafka;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.AuditSinkConfig.Kafka
 */
export interface AuditSinkConfig_Kafka {
    /**
     * Brokers specify Kafka destinations to connect to.
     *
     * @generated from protobuf field: repeated string brokers = 1;
     */
    brokers: string[];
    /**
     * Topic name must be valid based on source code:
     * https://github.com/apache/kafka/blob/0.10.2/core/src/main/scala/kafka/common/Topic.scala#L29-L30
     *
     * @generated from protobuf field: string topic = 2;
     */
    topic: string;
    /**
     * DisableTLS can force using non-secure connection.
     *
     * @generated from protobuf field: bool disable_tls = 3;
     */
    disableTls: boolean;
    /**
     * TLSSkipVerify defines whenever not to verify TLS certificate. Ignored if TLS is disabled.
     *
     * @generated from protobuf field: bool tls_skip_verify = 4;
     */
    tlsSkipVerify: boolean;
    /**
     * @generated from protobuf field: string username = 5;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 6;
     */
    password: string;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.AuthorizationPolicyConfig
 */
export interface AuthorizationPolicyConfig {
    /**
     * Policy in JSON string format.
     *
     * @generated from protobuf field: string policy = 1;
     */
    policy: string;
    /**
     * Policy status.
     *
     * @generated from protobuf field: indykite.auditsink.v1beta1.AuthorizationPolicyConfig.Status status = 2;
     */
    status: AuthorizationPolicyConfig_Status;
    /**
     * Optional policy tags
     *
     * @generated from protobuf field: repeated string tags = 3;
     */
    tags: string[];
}
/**
 * @generated from protobuf enum indykite.auditsink.v1beta1.AuthorizationPolicyConfig.Status
 */
export enum AuthorizationPolicyConfig_Status {
    /**
     * @generated from protobuf enum value: STATUS_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: STATUS_ACTIVE = 1;
     */
    ACTIVE = 1,
    /**
     * @generated from protobuf enum value: STATUS_INACTIVE = 2;
     */
    INACTIVE = 2,
    /**
     * @generated from protobuf enum value: STATUS_DRAFT = 3;
     */
    DRAFT = 3
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.AssignConfigPermissions
 */
export interface AssignConfigPermissions {
    /**
     * TargetIdentifier is gid identifier of Service Account or DigitalTwin.
     *
     * @generated from protobuf field: string target_identifier = 1;
     */
    targetIdentifier: string;
    /**
     * TargetType is type of TargetIdentifier.
     *
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType target_type = 2;
     */
    targetType: ConfigType;
    /**
     * Permission role id to be assigned.
     *
     * @generated from protobuf field: string role = 3;
     */
    role: string;
    /**
     * CustomerId under which to assign permissions.
     *
     * @generated from protobuf field: string customer_id = 4;
     */
    customerId: string;
    /**
     * Object to which Permission will be linked to. Can be Customer, AppSpace or Tenant.
     *
     * @generated from protobuf field: string object_id = 5;
     */
    objectId: string;
    /**
     * Object type is type of object_id.
     *
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType object_type = 6;
     */
    objectType: ConfigType;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.RevokeConfigPermissions
 */
export interface RevokeConfigPermissions {
    /**
     * TargetIdentifier is gid identifier of Service Account or DigitalTwin.
     *
     * @generated from protobuf field: string target_identifier = 1;
     */
    targetIdentifier: string;
    /**
     * TargetType is type of TargetIdentifier.
     *
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType target_type = 2;
     */
    targetType: ConfigType;
    /**
     * Permission role id to be assigned.
     *
     * @generated from protobuf field: string role = 3;
     */
    role: string;
    /**
     * CustomerId under which to assign permissions.
     *
     * @generated from protobuf field: string customer_id = 4;
     */
    customerId: string;
    /**
     * Object to which Permission will be linked to. Can be Customer, AppSpace or Tenant.
     *
     * @generated from protobuf field: string object_id = 5;
     */
    objectId: string;
    /**
     * Object type is type of object_id.
     *
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType object_type = 6;
     */
    objectType: ConfigType;
}
/**
 * Token Introspect configuration for AppSpace.
 *
 * @generated from protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig
 */
export interface TokenIntrospectConfig {
    /**
     * @generated from protobuf oneof: token_matcher
     */
    tokenMatcher: {
        oneofKind: "jwt";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.TokenIntrospectConfig.JWT jwt = 1;
         */
        jwt: TokenIntrospectConfig_JWT;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: validation
     */
    validation: {
        oneofKind: "offline";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.TokenIntrospectConfig.Offline offline = 3;
         */
        offline: TokenIntrospectConfig_Offline;
    } | {
        oneofKind: undefined;
    };
    /**
     * ClaimsMapping specify which claims from the token should be mapped to IKG Property with given name.
     * Remember, that 'email' claim is always extracted if exists and stored under 'email' key in IKG.
     *
     * Key specify name of property in IKG.
     * Value specify which claim to map and how.
     *
     * @generated from protobuf field: map<string, indykite.auditsink.v1beta1.TokenIntrospectConfig.Claim> claims_mapping = 7;
     */
    claimsMapping: {
        [key: string]: TokenIntrospectConfig_Claim;
    };
    /**
     * Node type in IKG to which we will try to match sub claim with DT external_id.
     *
     * @generated from protobuf field: string ikg_node_type = 5;
     */
    ikgNodeType: string;
    /**
     * Perform Upsert specify, if we should create and/or update DigitalTwin in IKG if it doesn't exist with.
     * In future this will perform upsert also on properties that are derived from token.
     *
     * @generated from protobuf field: bool perform_upsert = 6;
     */
    performUpsert: boolean;
}
/**
 * JWT specifies all attributes to match with received token.
 *
 * @generated from protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.JWT
 */
export interface TokenIntrospectConfig_JWT {
    /**
     * Issuer is used to exact match based on `iss` claim in JWT.
     *
     * @generated from protobuf field: string issuer = 1;
     */
    issuer: string;
    /**
     * Audience is used to exact match based on `aud` claim in JWT.
     *
     * @generated from protobuf field: string audience = 2;
     */
    audience: string;
}
/**
 * Offline validation works only with JWT.
 *
 * @generated from protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.Offline
 */
export interface TokenIntrospectConfig_Offline {
    /**
     * Public JWK to validate signature of JWT.
     * If there are no public keys specified, they will be fetched and cached from
     * jwks_uri at https://jwt-issuer.tld/.well-known/openid-configuration
     *
     * @generated from protobuf field: repeated bytes public_jwks = 1;
     */
    publicJwks: Uint8Array[];
}
/**
 * Claim specify details about claim that will be mapped to IKG.
 *
 * @generated from protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.Claim
 */
export interface TokenIntrospectConfig_Claim {
    /**
     * JSON selector of property in token claims. Currently just name in top-level object is supported.
     *
     * By default we support all standard claims from OpenID specification https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims,
     * and mapping will fail if claim and data type will not match the standard.
     *
     * For non-standard claims the type will be derived from the JSON.
     *
     * @generated from protobuf field: string selector = 1;
     */
    selector: string;
}
/**
 * ConfigType is equivalent to internal DocumentType, for easier maintenance keep same numbers.
 *
 * @generated from protobuf enum indykite.auditsink.v1beta1.ConfigType
 */
export enum ConfigType {
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_CUSTOMER = 1;
     */
    CUSTOMER = 1,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_APPLICATION_SPACE = 2;
     */
    APPLICATION_SPACE = 2,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_ISSUER = 15;
     */
    ISSUER = 15,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_APPLICATION = 4;
     */
    APPLICATION = 4,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_APP_AGENT = 5;
     */
    APP_AGENT = 5,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_APP_AGENT_CREDENTIAL = 6;
     */
    APP_AGENT_CREDENTIAL = 6,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_SERVICE_ACCOUNT = 18;
     */
    SERVICE_ACCOUNT = 18,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_SERVICE_CREDENTIAL = 19;
     */
    SERVICE_CREDENTIAL = 19,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_DIGITAL_TWIN = 21;
     */
    DIGITAL_TWIN = 21,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_AUDIT_SINK = 27;
     */
    AUDIT_SINK = 27,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_TOKEN_INTROSPECT = 30;
     */
    TOKEN_INTROSPECT = 30,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_AUTHORIZATION_POLICY = 22;
     */
    AUTHORIZATION_POLICY = 22,
    /**
     * CONFIG_TYPE_RESOURCE = 25; // Not use in Config API, but in Ingest/IKG
     * CONFIG_TYPE_RELATION = 26; // Not use in Config API, but in Ingest/IKG
     *
     * @generated from protobuf enum value: CONFIG_TYPE_CONSENT = 29;
     */
    CONSENT = 29,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_INGEST_PIPELINE = 31;
     */
    INGEST_PIPELINE = 31
}
// @generated message type with reflection information, may provide speed optimized methods
class ContainersPath$Type extends MessageType<ContainersPath> {
    constructor() {
        super("indykite.auditsink.v1beta1.ContainersPath", [
            { no: 1, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "application_space_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ContainersPath>): ContainersPath {
        const message = { customerId: "", applicationSpaceId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ContainersPath>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContainersPath): ContainersPath {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string customer_id */ 1:
                    message.customerId = reader.string();
                    break;
                case /* string application_space_id */ 2:
                    message.applicationSpaceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ContainersPath, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string customer_id = 1; */
        if (message.customerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.customerId);
        /* string application_space_id = 2; */
        if (message.applicationSpaceId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.applicationSpaceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ContainersPath
 */
export const ContainersPath = new ContainersPath$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatedConfig$Type extends MessageType<CreatedConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.CreatedConfig", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] },
            { no: 3, name: "location", kind: "message", T: () => CreatedConfig_Location },
            { no: 5, name: "containers_path", kind: "message", T: () => ContainersPath },
            { no: 4, name: "detail", kind: "message", T: () => ConfigDetail }
        ]);
    }
    create(value?: PartialMessage<CreatedConfig>): CreatedConfig {
        const message = { id: "", type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreatedConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatedConfig): CreatedConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* indykite.auditsink.v1beta1.CreatedConfig.Location location */ 3:
                    message.location = CreatedConfig_Location.internalBinaryRead(reader, reader.uint32(), options, message.location);
                    break;
                case /* indykite.auditsink.v1beta1.ContainersPath containers_path */ 5:
                    message.containersPath = ContainersPath.internalBinaryRead(reader, reader.uint32(), options, message.containersPath);
                    break;
                case /* indykite.auditsink.v1beta1.ConfigDetail detail */ 4:
                    message.detail = ConfigDetail.internalBinaryRead(reader, reader.uint32(), options, message.detail);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatedConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* indykite.auditsink.v1beta1.ConfigType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* indykite.auditsink.v1beta1.CreatedConfig.Location location = 3; */
        if (message.location)
            CreatedConfig_Location.internalBinaryWrite(message.location, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ContainersPath containers_path = 5; */
        if (message.containersPath)
            ContainersPath.internalBinaryWrite(message.containersPath, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ConfigDetail detail = 4; */
        if (message.detail)
            ConfigDetail.internalBinaryWrite(message.detail, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.CreatedConfig
 */
export const CreatedConfig = new CreatedConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatedConfig_Location$Type extends MessageType<CreatedConfig_Location> {
    constructor() {
        super("indykite.auditsink.v1beta1.CreatedConfig.Location", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<CreatedConfig_Location>): CreatedConfig_Location {
        const message = { id: "", type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreatedConfig_Location>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatedConfig_Location): CreatedConfig_Location {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatedConfig_Location, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* indykite.auditsink.v1beta1.ConfigType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.CreatedConfig.Location
 */
export const CreatedConfig_Location = new CreatedConfig_Location$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadConfig$Type extends MessageType<ReadConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.ReadConfig", [
            { no: 1, name: "id", kind: "scalar", oneof: "identifier", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "message", oneof: "identifier", T: () => ReadConfig_NameIdentifier },
            { no: 4, name: "containers_path", kind: "message", T: () => ContainersPath },
            { no: 3, name: "type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<ReadConfig>): ReadConfig {
        const message = { identifier: { oneofKind: undefined }, type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadConfig): ReadConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.identifier = {
                        oneofKind: "id",
                        id: reader.string()
                    };
                    break;
                case /* indykite.auditsink.v1beta1.ReadConfig.NameIdentifier name */ 2:
                    message.identifier = {
                        oneofKind: "name",
                        name: ReadConfig_NameIdentifier.internalBinaryRead(reader, reader.uint32(), options, (message.identifier as any).name)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.ContainersPath containers_path */ 4:
                    message.containersPath = ContainersPath.internalBinaryRead(reader, reader.uint32(), options, message.containersPath);
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType type */ 3:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.identifier.oneofKind === "id")
            writer.tag(1, WireType.LengthDelimited).string(message.identifier.id);
        /* indykite.auditsink.v1beta1.ReadConfig.NameIdentifier name = 2; */
        if (message.identifier.oneofKind === "name")
            ReadConfig_NameIdentifier.internalBinaryWrite(message.identifier.name, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ContainersPath containers_path = 4; */
        if (message.containersPath)
            ContainersPath.internalBinaryWrite(message.containersPath, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ConfigType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ReadConfig
 */
export const ReadConfig = new ReadConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadConfig_NameIdentifier$Type extends MessageType<ReadConfig_NameIdentifier> {
    constructor() {
        super("indykite.auditsink.v1beta1.ReadConfig.NameIdentifier", [
            { no: 1, name: "location_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "location_type", kind: "enum", opt: true, T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReadConfig_NameIdentifier>): ReadConfig_NameIdentifier {
        const message = { locationId: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadConfig_NameIdentifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadConfig_NameIdentifier): ReadConfig_NameIdentifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string location_id */ 1:
                    message.locationId = reader.string();
                    break;
                case /* optional indykite.auditsink.v1beta1.ConfigType location_type */ 2:
                    message.locationType = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadConfig_NameIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string location_id = 1; */
        if (message.locationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationId);
        /* optional indykite.auditsink.v1beta1.ConfigType location_type = 2; */
        if (message.locationType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.locationType);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ReadConfig.NameIdentifier
 */
export const ReadConfig_NameIdentifier = new ReadConfig_NameIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatedConfig$Type extends MessageType<UpdatedConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.UpdatedConfig", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] },
            { no: 5, name: "containers_path", kind: "message", T: () => ContainersPath },
            { no: 3, name: "before", kind: "message", T: () => ConfigDetail },
            { no: 4, name: "after", kind: "message", T: () => ConfigDetail }
        ]);
    }
    create(value?: PartialMessage<UpdatedConfig>): UpdatedConfig {
        const message = { id: "", type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdatedConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatedConfig): UpdatedConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* indykite.auditsink.v1beta1.ContainersPath containers_path */ 5:
                    message.containersPath = ContainersPath.internalBinaryRead(reader, reader.uint32(), options, message.containersPath);
                    break;
                case /* indykite.auditsink.v1beta1.ConfigDetail before */ 3:
                    message.before = ConfigDetail.internalBinaryRead(reader, reader.uint32(), options, message.before);
                    break;
                case /* indykite.auditsink.v1beta1.ConfigDetail after */ 4:
                    message.after = ConfigDetail.internalBinaryRead(reader, reader.uint32(), options, message.after);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatedConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* indykite.auditsink.v1beta1.ConfigType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* indykite.auditsink.v1beta1.ContainersPath containers_path = 5; */
        if (message.containersPath)
            ContainersPath.internalBinaryWrite(message.containersPath, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ConfigDetail before = 3; */
        if (message.before)
            ConfigDetail.internalBinaryWrite(message.before, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ConfigDetail after = 4; */
        if (message.after)
            ConfigDetail.internalBinaryWrite(message.after, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.UpdatedConfig
 */
export const UpdatedConfig = new UpdatedConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletedConfig$Type extends MessageType<DeletedConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.DeletedConfig", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] },
            { no: 3, name: "containers_path", kind: "message", T: () => ContainersPath }
        ]);
    }
    create(value?: PartialMessage<DeletedConfig>): DeletedConfig {
        const message = { id: "", type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeletedConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletedConfig): DeletedConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* indykite.auditsink.v1beta1.ContainersPath containers_path */ 3:
                    message.containersPath = ContainersPath.internalBinaryRead(reader, reader.uint32(), options, message.containersPath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletedConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* indykite.auditsink.v1beta1.ConfigType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* indykite.auditsink.v1beta1.ContainersPath containers_path = 3; */
        if (message.containersPath)
            ContainersPath.internalBinaryWrite(message.containersPath, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.DeletedConfig
 */
export const DeletedConfig = new DeletedConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigDetail$Type extends MessageType<ConfigDetail> {
    constructor() {
        super("indykite.auditsink.v1beta1.ConfigDetail", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 8, name: "application_agent_credential", kind: "message", oneof: "configuration", T: () => ApplicationAgentCredentialConfig },
            { no: 9, name: "service_account_credential", kind: "message", oneof: "configuration", T: () => ServiceAccountCredentialConfig },
            { no: 12, name: "audit_sink_config", kind: "message", oneof: "configuration", T: () => AuditSinkConfig },
            { no: 15, name: "authorization_policy_config", kind: "message", oneof: "configuration", T: () => AuthorizationPolicyConfig },
            { no: 19, name: "token_introspect_config", kind: "message", oneof: "configuration", T: () => TokenIntrospectConfig },
            { no: 18, name: "consent_config", kind: "message", oneof: "configuration", T: () => ConsentConfiguration },
            { no: 20, name: "ingest_pipeline_config", kind: "message", oneof: "configuration", T: () => IngestPipelineConfig }
        ]);
    }
    create(value?: PartialMessage<ConfigDetail>): ConfigDetail {
        const message = { name: "", displayName: "", description: "", version: "0", configuration: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConfigDetail>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigDetail): ConfigDetail {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string display_name */ 2:
                    message.displayName = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* int64 version */ 4:
                    message.version = reader.int64().toString();
                    break;
                case /* indykite.auditsink.v1beta1.ApplicationAgentCredentialConfig application_agent_credential */ 8:
                    message.configuration = {
                        oneofKind: "applicationAgentCredential",
                        applicationAgentCredential: ApplicationAgentCredentialConfig.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).applicationAgentCredential)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.ServiceAccountCredentialConfig service_account_credential */ 9:
                    message.configuration = {
                        oneofKind: "serviceAccountCredential",
                        serviceAccountCredential: ServiceAccountCredentialConfig.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).serviceAccountCredential)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.AuditSinkConfig audit_sink_config */ 12:
                    message.configuration = {
                        oneofKind: "auditSinkConfig",
                        auditSinkConfig: AuditSinkConfig.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).auditSinkConfig)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.AuthorizationPolicyConfig authorization_policy_config */ 15:
                    message.configuration = {
                        oneofKind: "authorizationPolicyConfig",
                        authorizationPolicyConfig: AuthorizationPolicyConfig.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).authorizationPolicyConfig)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.TokenIntrospectConfig token_introspect_config */ 19:
                    message.configuration = {
                        oneofKind: "tokenIntrospectConfig",
                        tokenIntrospectConfig: TokenIntrospectConfig.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).tokenIntrospectConfig)
                    };
                    break;
                case /* indykite.config.v1beta1.ConsentConfiguration consent_config */ 18:
                    message.configuration = {
                        oneofKind: "consentConfig",
                        consentConfig: ConsentConfiguration.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).consentConfig)
                    };
                    break;
                case /* indykite.config.v1beta1.IngestPipelineConfig ingest_pipeline_config */ 20:
                    message.configuration = {
                        oneofKind: "ingestPipelineConfig",
                        ingestPipelineConfig: IngestPipelineConfig.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).ingestPipelineConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigDetail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string display_name = 2; */
        if (message.displayName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.displayName);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* int64 version = 4; */
        if (message.version !== "0")
            writer.tag(4, WireType.Varint).int64(message.version);
        /* indykite.auditsink.v1beta1.ApplicationAgentCredentialConfig application_agent_credential = 8; */
        if (message.configuration.oneofKind === "applicationAgentCredential")
            ApplicationAgentCredentialConfig.internalBinaryWrite(message.configuration.applicationAgentCredential, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ServiceAccountCredentialConfig service_account_credential = 9; */
        if (message.configuration.oneofKind === "serviceAccountCredential")
            ServiceAccountCredentialConfig.internalBinaryWrite(message.configuration.serviceAccountCredential, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.AuditSinkConfig audit_sink_config = 12; */
        if (message.configuration.oneofKind === "auditSinkConfig")
            AuditSinkConfig.internalBinaryWrite(message.configuration.auditSinkConfig, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.AuthorizationPolicyConfig authorization_policy_config = 15; */
        if (message.configuration.oneofKind === "authorizationPolicyConfig")
            AuthorizationPolicyConfig.internalBinaryWrite(message.configuration.authorizationPolicyConfig, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.TokenIntrospectConfig token_introspect_config = 19; */
        if (message.configuration.oneofKind === "tokenIntrospectConfig")
            TokenIntrospectConfig.internalBinaryWrite(message.configuration.tokenIntrospectConfig, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* indykite.config.v1beta1.ConsentConfiguration consent_config = 18; */
        if (message.configuration.oneofKind === "consentConfig")
            ConsentConfiguration.internalBinaryWrite(message.configuration.consentConfig, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* indykite.config.v1beta1.IngestPipelineConfig ingest_pipeline_config = 20; */
        if (message.configuration.oneofKind === "ingestPipelineConfig")
            IngestPipelineConfig.internalBinaryWrite(message.configuration.ingestPipelineConfig, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ConfigDetail
 */
export const ConfigDetail = new ConfigDetail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplicationAgentCredentialConfig$Type extends MessageType<ApplicationAgentCredentialConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.ApplicationAgentCredentialConfig", [
            { no: 1, name: "kid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key_format", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "original_kid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "expire_time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ApplicationAgentCredentialConfig>): ApplicationAgentCredentialConfig {
        const message = { kid: "", keyFormat: "", originalKid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ApplicationAgentCredentialConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplicationAgentCredentialConfig): ApplicationAgentCredentialConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string kid */ 1:
                    message.kid = reader.string();
                    break;
                case /* string key_format */ 2:
                    message.keyFormat = reader.string();
                    break;
                case /* string original_kid */ 3:
                    message.originalKid = reader.string();
                    break;
                case /* google.protobuf.Timestamp expire_time */ 4:
                    message.expireTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expireTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplicationAgentCredentialConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string kid = 1; */
        if (message.kid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kid);
        /* string key_format = 2; */
        if (message.keyFormat !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyFormat);
        /* string original_kid = 3; */
        if (message.originalKid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.originalKid);
        /* google.protobuf.Timestamp expire_time = 4; */
        if (message.expireTime)
            Timestamp.internalBinaryWrite(message.expireTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ApplicationAgentCredentialConfig
 */
export const ApplicationAgentCredentialConfig = new ApplicationAgentCredentialConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceAccountCredentialConfig$Type extends MessageType<ServiceAccountCredentialConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.ServiceAccountCredentialConfig", [
            { no: 1, name: "kid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key_format", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "original_kid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "expire_time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ServiceAccountCredentialConfig>): ServiceAccountCredentialConfig {
        const message = { kid: "", keyFormat: "", originalKid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServiceAccountCredentialConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceAccountCredentialConfig): ServiceAccountCredentialConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string kid */ 1:
                    message.kid = reader.string();
                    break;
                case /* string key_format */ 2:
                    message.keyFormat = reader.string();
                    break;
                case /* string original_kid */ 3:
                    message.originalKid = reader.string();
                    break;
                case /* google.protobuf.Timestamp expire_time */ 4:
                    message.expireTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expireTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceAccountCredentialConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string kid = 1; */
        if (message.kid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kid);
        /* string key_format = 2; */
        if (message.keyFormat !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyFormat);
        /* string original_kid = 3; */
        if (message.originalKid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.originalKid);
        /* google.protobuf.Timestamp expire_time = 4; */
        if (message.expireTime)
            Timestamp.internalBinaryWrite(message.expireTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ServiceAccountCredentialConfig
 */
export const ServiceAccountCredentialConfig = new ServiceAccountCredentialConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuditSinkConfig$Type extends MessageType<AuditSinkConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.AuditSinkConfig", [
            { no: 1, name: "kafka", kind: "message", oneof: "provider", T: () => AuditSinkConfig_Kafka }
        ]);
    }
    create(value?: PartialMessage<AuditSinkConfig>): AuditSinkConfig {
        const message = { provider: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuditSinkConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuditSinkConfig): AuditSinkConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.auditsink.v1beta1.AuditSinkConfig.Kafka kafka */ 1:
                    message.provider = {
                        oneofKind: "kafka",
                        kafka: AuditSinkConfig_Kafka.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).kafka)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuditSinkConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.auditsink.v1beta1.AuditSinkConfig.Kafka kafka = 1; */
        if (message.provider.oneofKind === "kafka")
            AuditSinkConfig_Kafka.internalBinaryWrite(message.provider.kafka, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.AuditSinkConfig
 */
export const AuditSinkConfig = new AuditSinkConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuditSinkConfig_Kafka$Type extends MessageType<AuditSinkConfig_Kafka> {
    constructor() {
        super("indykite.auditsink.v1beta1.AuditSinkConfig.Kafka", [
            { no: 1, name: "brokers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "topic", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "disable_tls", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "tls_skip_verify", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuditSinkConfig_Kafka>): AuditSinkConfig_Kafka {
        const message = { brokers: [], topic: "", disableTls: false, tlsSkipVerify: false, username: "", password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuditSinkConfig_Kafka>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuditSinkConfig_Kafka): AuditSinkConfig_Kafka {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string brokers */ 1:
                    message.brokers.push(reader.string());
                    break;
                case /* string topic */ 2:
                    message.topic = reader.string();
                    break;
                case /* bool disable_tls */ 3:
                    message.disableTls = reader.bool();
                    break;
                case /* bool tls_skip_verify */ 4:
                    message.tlsSkipVerify = reader.bool();
                    break;
                case /* string username */ 5:
                    message.username = reader.string();
                    break;
                case /* string password */ 6:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuditSinkConfig_Kafka, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string brokers = 1; */
        for (let i = 0; i < message.brokers.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.brokers[i]);
        /* string topic = 2; */
        if (message.topic !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.topic);
        /* bool disable_tls = 3; */
        if (message.disableTls !== false)
            writer.tag(3, WireType.Varint).bool(message.disableTls);
        /* bool tls_skip_verify = 4; */
        if (message.tlsSkipVerify !== false)
            writer.tag(4, WireType.Varint).bool(message.tlsSkipVerify);
        /* string username = 5; */
        if (message.username !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.username);
        /* string password = 6; */
        if (message.password !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.AuditSinkConfig.Kafka
 */
export const AuditSinkConfig_Kafka = new AuditSinkConfig_Kafka$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizationPolicyConfig$Type extends MessageType<AuthorizationPolicyConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.AuthorizationPolicyConfig", [
            { no: 1, name: "policy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["indykite.auditsink.v1beta1.AuthorizationPolicyConfig.Status", AuthorizationPolicyConfig_Status, "STATUS_"] },
            { no: 3, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthorizationPolicyConfig>): AuthorizationPolicyConfig {
        const message = { policy: "", status: 0, tags: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuthorizationPolicyConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorizationPolicyConfig): AuthorizationPolicyConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string policy */ 1:
                    message.policy = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.AuthorizationPolicyConfig.Status status */ 2:
                    message.status = reader.int32();
                    break;
                case /* repeated string tags */ 3:
                    message.tags.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthorizationPolicyConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string policy = 1; */
        if (message.policy !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.policy);
        /* indykite.auditsink.v1beta1.AuthorizationPolicyConfig.Status status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* repeated string tags = 3; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.tags[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.AuthorizationPolicyConfig
 */
export const AuthorizationPolicyConfig = new AuthorizationPolicyConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssignConfigPermissions$Type extends MessageType<AssignConfigPermissions> {
    constructor() {
        super("indykite.auditsink.v1beta1.AssignConfigPermissions", [
            { no: 1, name: "target_identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] },
            { no: 3, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "object_type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<AssignConfigPermissions>): AssignConfigPermissions {
        const message = { targetIdentifier: "", targetType: 0, role: "", customerId: "", objectId: "", objectType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssignConfigPermissions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssignConfigPermissions): AssignConfigPermissions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string target_identifier */ 1:
                    message.targetIdentifier = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType target_type */ 2:
                    message.targetType = reader.int32();
                    break;
                case /* string role */ 3:
                    message.role = reader.string();
                    break;
                case /* string customer_id */ 4:
                    message.customerId = reader.string();
                    break;
                case /* string object_id */ 5:
                    message.objectId = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType object_type */ 6:
                    message.objectType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssignConfigPermissions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string target_identifier = 1; */
        if (message.targetIdentifier !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.targetIdentifier);
        /* indykite.auditsink.v1beta1.ConfigType target_type = 2; */
        if (message.targetType !== 0)
            writer.tag(2, WireType.Varint).int32(message.targetType);
        /* string role = 3; */
        if (message.role !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.role);
        /* string customer_id = 4; */
        if (message.customerId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.customerId);
        /* string object_id = 5; */
        if (message.objectId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.objectId);
        /* indykite.auditsink.v1beta1.ConfigType object_type = 6; */
        if (message.objectType !== 0)
            writer.tag(6, WireType.Varint).int32(message.objectType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.AssignConfigPermissions
 */
export const AssignConfigPermissions = new AssignConfigPermissions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RevokeConfigPermissions$Type extends MessageType<RevokeConfigPermissions> {
    constructor() {
        super("indykite.auditsink.v1beta1.RevokeConfigPermissions", [
            { no: 1, name: "target_identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] },
            { no: 3, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "object_type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<RevokeConfigPermissions>): RevokeConfigPermissions {
        const message = { targetIdentifier: "", targetType: 0, role: "", customerId: "", objectId: "", objectType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RevokeConfigPermissions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RevokeConfigPermissions): RevokeConfigPermissions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string target_identifier */ 1:
                    message.targetIdentifier = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType target_type */ 2:
                    message.targetType = reader.int32();
                    break;
                case /* string role */ 3:
                    message.role = reader.string();
                    break;
                case /* string customer_id */ 4:
                    message.customerId = reader.string();
                    break;
                case /* string object_id */ 5:
                    message.objectId = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType object_type */ 6:
                    message.objectType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RevokeConfigPermissions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string target_identifier = 1; */
        if (message.targetIdentifier !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.targetIdentifier);
        /* indykite.auditsink.v1beta1.ConfigType target_type = 2; */
        if (message.targetType !== 0)
            writer.tag(2, WireType.Varint).int32(message.targetType);
        /* string role = 3; */
        if (message.role !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.role);
        /* string customer_id = 4; */
        if (message.customerId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.customerId);
        /* string object_id = 5; */
        if (message.objectId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.objectId);
        /* indykite.auditsink.v1beta1.ConfigType object_type = 6; */
        if (message.objectType !== 0)
            writer.tag(6, WireType.Varint).int32(message.objectType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.RevokeConfigPermissions
 */
export const RevokeConfigPermissions = new RevokeConfigPermissions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig$Type extends MessageType<TokenIntrospectConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.TokenIntrospectConfig", [
            { no: 1, name: "jwt", kind: "message", oneof: "tokenMatcher", T: () => TokenIntrospectConfig_JWT },
            { no: 3, name: "offline", kind: "message", oneof: "validation", T: () => TokenIntrospectConfig_Offline },
            { no: 7, name: "claims_mapping", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => TokenIntrospectConfig_Claim } },
            { no: 5, name: "ikg_node_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "perform_upsert", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectConfig>): TokenIntrospectConfig {
        const message = { tokenMatcher: { oneofKind: undefined }, validation: { oneofKind: undefined }, claimsMapping: {}, ikgNodeType: "", performUpsert: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig): TokenIntrospectConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.auditsink.v1beta1.TokenIntrospectConfig.JWT jwt */ 1:
                    message.tokenMatcher = {
                        oneofKind: "jwt",
                        jwt: TokenIntrospectConfig_JWT.internalBinaryRead(reader, reader.uint32(), options, (message.tokenMatcher as any).jwt)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.TokenIntrospectConfig.Offline offline */ 3:
                    message.validation = {
                        oneofKind: "offline",
                        offline: TokenIntrospectConfig_Offline.internalBinaryRead(reader, reader.uint32(), options, (message.validation as any).offline)
                    };
                    break;
                case /* map<string, indykite.auditsink.v1beta1.TokenIntrospectConfig.Claim> claims_mapping */ 7:
                    this.binaryReadMap7(message.claimsMapping, reader, options);
                    break;
                case /* string ikg_node_type */ 5:
                    message.ikgNodeType = reader.string();
                    break;
                case /* bool perform_upsert */ 6:
                    message.performUpsert = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: TokenIntrospectConfig["claimsMapping"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TokenIntrospectConfig["claimsMapping"] | undefined, val: TokenIntrospectConfig["claimsMapping"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = TokenIntrospectConfig_Claim.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.auditsink.v1beta1.TokenIntrospectConfig.claims_mapping");
            }
        }
        map[key ?? ""] = val ?? TokenIntrospectConfig_Claim.create();
    }
    internalBinaryWrite(message: TokenIntrospectConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.auditsink.v1beta1.TokenIntrospectConfig.JWT jwt = 1; */
        if (message.tokenMatcher.oneofKind === "jwt")
            TokenIntrospectConfig_JWT.internalBinaryWrite(message.tokenMatcher.jwt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.TokenIntrospectConfig.Offline offline = 3; */
        if (message.validation.oneofKind === "offline")
            TokenIntrospectConfig_Offline.internalBinaryWrite(message.validation.offline, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* map<string, indykite.auditsink.v1beta1.TokenIntrospectConfig.Claim> claims_mapping = 7; */
        for (let k of Object.keys(message.claimsMapping)) {
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            TokenIntrospectConfig_Claim.internalBinaryWrite(message.claimsMapping[k], writer, options);
            writer.join().join();
        }
        /* string ikg_node_type = 5; */
        if (message.ikgNodeType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.ikgNodeType);
        /* bool perform_upsert = 6; */
        if (message.performUpsert !== false)
            writer.tag(6, WireType.Varint).bool(message.performUpsert);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig
 */
export const TokenIntrospectConfig = new TokenIntrospectConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig_JWT$Type extends MessageType<TokenIntrospectConfig_JWT> {
    constructor() {
        super("indykite.auditsink.v1beta1.TokenIntrospectConfig.JWT", [
            { no: 1, name: "issuer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "audience", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectConfig_JWT>): TokenIntrospectConfig_JWT {
        const message = { issuer: "", audience: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig_JWT>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig_JWT): TokenIntrospectConfig_JWT {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string issuer */ 1:
                    message.issuer = reader.string();
                    break;
                case /* string audience */ 2:
                    message.audience = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenIntrospectConfig_JWT, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string issuer = 1; */
        if (message.issuer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.issuer);
        /* string audience = 2; */
        if (message.audience !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.audience);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.JWT
 */
export const TokenIntrospectConfig_JWT = new TokenIntrospectConfig_JWT$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig_Offline$Type extends MessageType<TokenIntrospectConfig_Offline> {
    constructor() {
        super("indykite.auditsink.v1beta1.TokenIntrospectConfig.Offline", [
            { no: 1, name: "public_jwks", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectConfig_Offline>): TokenIntrospectConfig_Offline {
        const message = { publicJwks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig_Offline>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig_Offline): TokenIntrospectConfig_Offline {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes public_jwks */ 1:
                    message.publicJwks.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenIntrospectConfig_Offline, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes public_jwks = 1; */
        for (let i = 0; i < message.publicJwks.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.publicJwks[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.Offline
 */
export const TokenIntrospectConfig_Offline = new TokenIntrospectConfig_Offline$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig_Claim$Type extends MessageType<TokenIntrospectConfig_Claim> {
    constructor() {
        super("indykite.auditsink.v1beta1.TokenIntrospectConfig.Claim", [
            { no: 1, name: "selector", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectConfig_Claim>): TokenIntrospectConfig_Claim {
        const message = { selector: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig_Claim>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig_Claim): TokenIntrospectConfig_Claim {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string selector */ 1:
                    message.selector = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenIntrospectConfig_Claim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string selector = 1; */
        if (message.selector !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.selector);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.Claim
 */
export const TokenIntrospectConfig_Claim = new TokenIntrospectConfig_Claim$Type();
