// @generated by protobuf-ts 2.9.0 with parameter long_type_string,client_grpc1,generate_dependencies
// @generated from protobuf file "indykite/auditsink/v1beta1/config.proto" (package "indykite.auditsink.v1beta1", syntax proto3)
// tslint:disable
//
// Copyright (c) 2023 IndyKite
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { StringValue } from "../../../google/protobuf/wrappers";
import { Duration } from "../../../google/protobuf/duration";
import { Timestamp } from "../../../google/protobuf/timestamp";
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ContainersPath
 */
export interface ContainersPath {
    /**
     * @generated from protobuf field: string customer_id = 1;
     */
    customerId: string;
    /**
     * @generated from protobuf field: string application_space_id = 2;
     */
    applicationSpaceId: string;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.CreatedConfig
 */
export interface CreatedConfig {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType type = 2;
     */
    type: ConfigType;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.CreatedConfig.Location location = 3;
     */
    location?: CreatedConfig_Location;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ContainersPath containers_path = 5;
     */
    containersPath?: ContainersPath;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigDetail detail = 4;
     */
    detail?: ConfigDetail;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.CreatedConfig.Location
 */
export interface CreatedConfig_Location {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType type = 2;
     */
    type: ConfigType;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ReadConfig
 */
export interface ReadConfig {
    /**
     * @generated from protobuf oneof: identifier
     */
    identifier: {
        oneofKind: "id";
        /**
         * @generated from protobuf field: string id = 1;
         */
        id: string;
    } | {
        oneofKind: "name";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.ReadConfig.NameIdentifier name = 2;
         */
        name: ReadConfig_NameIdentifier;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ContainersPath containers_path = 4;
     */
    containersPath?: ContainersPath;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType type = 3;
     */
    type: ConfigType;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ReadConfig.NameIdentifier
 */
export interface ReadConfig_NameIdentifier {
    /**
     * LocationId specify under which container the name search happen. Might be empty if searching customer.
     *
     * @generated from protobuf field: string location_id = 1;
     */
    locationId: string;
    /**
     * LocationType specify under which container type the name search happen. Might be empty if searching customer.
     *
     * @generated from protobuf field: optional indykite.auditsink.v1beta1.ConfigType location_type = 2;
     */
    locationType?: ConfigType;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.UpdatedConfig
 */
export interface UpdatedConfig {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType type = 2;
     */
    type: ConfigType;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ContainersPath containers_path = 5;
     */
    containersPath?: ContainersPath;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigDetail before = 3;
     */
    before?: ConfigDetail;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigDetail after = 4;
     */
    after?: ConfigDetail;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.DeletedConfig
 */
export interface DeletedConfig {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType type = 2;
     */
    type: ConfigType;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ContainersPath containers_path = 3;
     */
    containersPath?: ContainersPath;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ConfigDetail
 */
export interface ConfigDetail {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string display_name = 2;
     */
    displayName: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * @generated from protobuf field: int64 version = 4;
     */
    version: string;
    /**
     * @generated from protobuf oneof: configuration
     */
    configuration: {
        oneofKind: "applicationAgentCredential";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.ApplicationAgentCredentialConfig application_agent_credential = 8;
         */
        applicationAgentCredential: ApplicationAgentCredentialConfig;
    } | {
        oneofKind: "serviceAccountCredential";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.ServiceAccountCredentialConfig service_account_credential = 9;
         */
        serviceAccountCredential: ServiceAccountCredentialConfig;
    } | {
        oneofKind: "auditSinkConfig";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.AuditSinkConfig audit_sink_config = 12;
         */
        auditSinkConfig: AuditSinkConfig;
    } | {
        oneofKind: "authorizationPolicyConfig";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.AuthorizationPolicyConfig authorization_policy_config = 15;
         */
        authorizationPolicyConfig: AuthorizationPolicyConfig;
    } | {
        oneofKind: "tokenIntrospectConfig";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.TokenIntrospectConfig token_introspect_config = 19;
         */
        tokenIntrospectConfig: TokenIntrospectConfig;
    } | {
        oneofKind: "externalDataResolverConfig";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.ExternalDataResolverConfig external_data_resolver_config = 22;
         */
        externalDataResolverConfig: ExternalDataResolverConfig;
    } | {
        oneofKind: "consentConfig";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.ConsentConfiguration consent_config = 18;
         */
        consentConfig: ConsentConfiguration;
    } | {
        oneofKind: "ingestPipelineConfig";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.IngestPipelineConfig ingest_pipeline_config = 20;
         */
        ingestPipelineConfig: IngestPipelineConfig;
    } | {
        oneofKind: "identityMatchingPipelineConfig";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig identity_matching_pipeline_config = 21;
         */
        identityMatchingPipelineConfig: IdentityMatchingPipelineConfig;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ApplicationAgentCredentialConfig
 */
export interface ApplicationAgentCredentialConfig {
    /**
     * @generated from protobuf field: string kid = 1;
     */
    kid: string;
    /**
     * KeyFormat specify in which format the public key was provided.
     * Could by empty, if no public key was provided.
     *
     * @generated from protobuf field: string key_format = 2;
     */
    keyFormat: string;
    /**
     * @generated from protobuf field: string original_kid = 3;
     */
    originalKid: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expire_time = 4;
     */
    expireTime?: Timestamp;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ServiceAccountCredentialConfig
 */
export interface ServiceAccountCredentialConfig {
    /**
     * @generated from protobuf field: string kid = 1;
     */
    kid: string;
    /**
     * KeyFormat specify in which format the public key was provided.
     * Could by empty, if no public key was provided.
     *
     * @generated from protobuf field: string key_format = 2;
     */
    keyFormat: string;
    /**
     * @generated from protobuf field: string original_kid = 3;
     */
    originalKid: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expire_time = 4;
     */
    expireTime?: Timestamp;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.AuditSinkConfig
 */
export interface AuditSinkConfig {
    /**
     * @generated from protobuf oneof: provider
     */
    provider: {
        oneofKind: "kafka";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.AuditSinkConfig.Kafka kafka = 1;
         */
        kafka: AuditSinkConfig_Kafka;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.AuditSinkConfig.Kafka
 */
export interface AuditSinkConfig_Kafka {
    /**
     * Brokers specify Kafka destinations to connect to.
     *
     * @generated from protobuf field: repeated string brokers = 1;
     */
    brokers: string[];
    /**
     * Topic name must be valid based on source code:
     * https://github.com/apache/kafka/blob/0.10.2/core/src/main/scala/kafka/common/Topic.scala#L29-L30
     *
     * @generated from protobuf field: string topic = 2;
     */
    topic: string;
    /**
     * DisableTLS can force using non-secure connection.
     *
     * @generated from protobuf field: bool disable_tls = 3;
     */
    disableTls: boolean;
    /**
     * TLSSkipVerify defines whenever not to verify TLS certificate. Ignored if TLS is disabled.
     *
     * @generated from protobuf field: bool tls_skip_verify = 4;
     */
    tlsSkipVerify: boolean;
    /**
     * @generated from protobuf field: string username = 5;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 6;
     */
    password: string;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ExternalDataResolverConfig
 */
export interface ExternalDataResolverConfig {
    /**
     * Full URL to endpoint that will be called.
     *
     * @generated from protobuf field: string url = 1;
     */
    url: string;
    /**
     * HTTP method to be used for the request.
     *
     * @generated from protobuf field: string method = 2;
     */
    method: string;
    /**
     * @generated from protobuf field: map<string, string> headers = 3;
     */
    headers: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ExternalDataResolverConfig.ContentType request_type = 4;
     */
    requestType: ExternalDataResolverConfig_ContentType;
    /**
     * @generated from protobuf field: string request_payload = 5;
     */
    requestPayload: string;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ExternalDataResolverConfig.ContentType response_type = 6;
     */
    responseType: ExternalDataResolverConfig_ContentType;
    /**
     * @generated from protobuf field: string response_selector = 7;
     */
    responseSelector: string;
}
/**
 * @generated from protobuf enum indykite.auditsink.v1beta1.ExternalDataResolverConfig.ContentType
 */
export enum ExternalDataResolverConfig_ContentType {
    /**
     * @generated from protobuf enum value: CONTENT_TYPE_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: CONTENT_TYPE_JSON = 1;
     */
    JSON = 1
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.AuthorizationPolicyConfig
 */
export interface AuthorizationPolicyConfig {
    /**
     * Policy in JSON string format.
     *
     * @generated from protobuf field: string policy = 1;
     */
    policy: string;
    /**
     * Policy status.
     *
     * @generated from protobuf field: indykite.auditsink.v1beta1.AuthorizationPolicyConfig.Status status = 2;
     */
    status: AuthorizationPolicyConfig_Status;
    /**
     * Optional policy tags
     *
     * @generated from protobuf field: repeated string tags = 3;
     */
    tags: string[];
}
/**
 * @generated from protobuf enum indykite.auditsink.v1beta1.AuthorizationPolicyConfig.Status
 */
export enum AuthorizationPolicyConfig_Status {
    /**
     * @generated from protobuf enum value: STATUS_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: STATUS_ACTIVE = 1;
     */
    ACTIVE = 1,
    /**
     * @generated from protobuf enum value: STATUS_INACTIVE = 2;
     */
    INACTIVE = 2,
    /**
     * @generated from protobuf enum value: STATUS_DRAFT = 3;
     */
    DRAFT = 3
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.AssignConfigPermissions
 */
export interface AssignConfigPermissions {
    /**
     * TargetIdentifier is gid identifier of Service Account or DigitalTwin.
     *
     * @generated from protobuf field: string target_identifier = 1;
     */
    targetIdentifier: string;
    /**
     * TargetType is type of TargetIdentifier.
     *
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType target_type = 2;
     */
    targetType: ConfigType;
    /**
     * Permission role id to be assigned.
     *
     * @generated from protobuf field: string role = 3;
     */
    role: string;
    /**
     * CustomerId under which to assign permissions.
     *
     * @generated from protobuf field: string customer_id = 4;
     */
    customerId: string;
    /**
     * Object to which Permission will be linked to. Can be Customer, AppSpace or Tenant.
     *
     * @generated from protobuf field: string object_id = 5;
     */
    objectId: string;
    /**
     * Object type is type of object_id.
     *
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType object_type = 6;
     */
    objectType: ConfigType;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.RevokeConfigPermissions
 */
export interface RevokeConfigPermissions {
    /**
     * TargetIdentifier is gid identifier of Service Account or DigitalTwin.
     *
     * @generated from protobuf field: string target_identifier = 1;
     */
    targetIdentifier: string;
    /**
     * TargetType is type of TargetIdentifier.
     *
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType target_type = 2;
     */
    targetType: ConfigType;
    /**
     * Permission role id to be assigned.
     *
     * @generated from protobuf field: string role = 3;
     */
    role: string;
    /**
     * CustomerId under which to assign permissions.
     *
     * @generated from protobuf field: string customer_id = 4;
     */
    customerId: string;
    /**
     * Object to which Permission will be linked to. Can be Customer, AppSpace or Tenant.
     *
     * @generated from protobuf field: string object_id = 5;
     */
    objectId: string;
    /**
     * Object type is type of object_id.
     *
     * @generated from protobuf field: indykite.auditsink.v1beta1.ConfigType object_type = 6;
     */
    objectType: ConfigType;
}
/**
 * Token Introspect configuration for AppSpace.
 *
 * @generated from protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig
 */
export interface TokenIntrospectConfig {
    /**
     * @generated from protobuf oneof: token_matcher
     */
    tokenMatcher: {
        oneofKind: "jwt";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.TokenIntrospectConfig.JWT jwt = 1;
         */
        jwt: TokenIntrospectConfig_JWT;
    } | {
        oneofKind: "opaque";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.TokenIntrospectConfig.Opaque opaque = 2;
         */
        opaque: TokenIntrospectConfig_Opaque;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: validation
     */
    validation: {
        oneofKind: "offline";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.TokenIntrospectConfig.Offline offline = 3;
         */
        offline: TokenIntrospectConfig_Offline;
    } | {
        oneofKind: "online";
        /**
         * @generated from protobuf field: indykite.auditsink.v1beta1.TokenIntrospectConfig.Online online = 4;
         */
        online: TokenIntrospectConfig_Online;
    } | {
        oneofKind: undefined;
    };
    /**
     * ClaimsMapping specify which claims from the token should be mapped to IKG Property with given name.
     * Remember, that 'email' claim is always extracted if exists and stored under 'email' key in IKG.
     *
     * Key specify name of property in IKG.
     * Value specify which claim to map and how.
     *
     * @generated from protobuf field: map<string, indykite.auditsink.v1beta1.TokenIntrospectConfig.Claim> claims_mapping = 7;
     */
    claimsMapping: {
        [key: string]: TokenIntrospectConfig_Claim;
    };
    /**
     * Node type in IKG to which we will try to match sub claim with DT external_id.
     *
     * @generated from protobuf field: string ikg_node_type = 5;
     */
    ikgNodeType: string;
    /**
     * Perform Upsert specify, if we should create and/or update DigitalTwin in IKG if it doesn't exist with.
     * In future this will perform upsert also on properties that are derived from token.
     *
     * @generated from protobuf field: bool perform_upsert = 6;
     */
    performUpsert: boolean;
}
/**
 * JWT specifies all attributes to match with received token.
 *
 * @generated from protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.JWT
 */
export interface TokenIntrospectConfig_JWT {
    /**
     * Issuer is used to exact match based on `iss` claim in JWT.
     *
     * @generated from protobuf field: string issuer = 1;
     */
    issuer: string;
    /**
     * Audience is used to exact match based on `aud` claim in JWT.
     *
     * @generated from protobuf field: string audience = 2;
     */
    audience: string;
}
/**
 * Opaque specifies the configuration is for opaque tokens.
 * Currently we will support max 1 opaque token configuration per app space.
 *
 * @generated from protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.Opaque
 */
export interface TokenIntrospectConfig_Opaque {
}
/**
 * Offline validation works only with JWT.
 *
 * @generated from protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.Offline
 */
export interface TokenIntrospectConfig_Offline {
    /**
     * Public JWK to validate signature of JWT.
     * If there are no public keys specified, they will be fetched and cached from
     * jwks_uri at https://jwt-issuer.tld/.well-known/openid-configuration
     *
     * @generated from protobuf field: repeated bytes public_jwks = 1;
     */
    publicJwks: Uint8Array[];
}
/**
 * Online validation works with both JWT and Opaque tokens.
 * It will call userinfo endpoint to validate token and fetch user claims.
 *
 * @generated from protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.Online
 */
export interface TokenIntrospectConfig_Online {
    /**
     * URI of userinfo endpoint which will be used to validate access token.
     * And also fetch user claims when opaque token is received.
     *
     * It can remain empty, if JWT token matcher is used.
     * Then the URI under "userinfo_endpoint" in .well-known/openid-configuration endpoint is used.
     *
     * @generated from protobuf field: string userinfo_endpoint = 1;
     */
    userinfoEndpoint: string;
    /**
     * Cache TTL of token validity can be used to minimize calls to userinfo endpoint.
     * The final cache TTL will be set to lower limit of this value and exp claim of JWT token.
     * If not set, token will not be cached and call to userinfo endpoint will be made on every request.
     *
     * However, token validity will be checked first if possible (JWT tokens).
     * If token is expired, userinfo endpoint will not be called, nor cache checked.
     *
     * @generated from protobuf field: google.protobuf.Duration cache_ttl = 2;
     */
    cacheTtl?: Duration;
}
/**
 * Claim specify details about claim that will be mapped to IKG.
 *
 * @generated from protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.Claim
 */
export interface TokenIntrospectConfig_Claim {
    /**
     * JSON selector of property in token claims. Currently just name in top-level object is supported.
     *
     * By default we support all standard claims from OpenID specification https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims,
     * and mapping will fail if claim and data type will not match the standard.
     *
     * For non-standard claims the type will be derived from the JSON.
     *
     * @generated from protobuf field: string selector = 1;
     */
    selector: string;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.ConsentConfiguration
 */
export interface ConsentConfiguration {
    /**
     * Purpose is a human readable description of the purpose of the consent.
     *
     * @generated from protobuf field: string purpose = 1;
     */
    purpose: string;
    /**
     * Data points is a list of properties related to the Digital twin that the consent is for.
     *
     * @generated from protobuf field: repeated string data_points = 2;
     */
    dataPoints: string[];
    /**
     * @generated from protobuf field: string application_id = 3;
     */
    applicationId: string;
    /**
     * ValidityPeriod is the time in seconds that the consent is valid for.
     * The minimum value is 1 day and the maximum value is 2 years.
     *
     * @generated from protobuf field: uint64 validity_period = 4;
     */
    validityPeriod: string;
    /**
     * Revoke after use is a boolean that determines if the consent should be revoked after it has been used.
     *
     * @generated from protobuf field: bool revoke_after_use = 5;
     */
    revokeAfterUse: boolean;
    /**
     * @generated from protobuf field: indykite.auditsink.v1beta1.ExternalTokenStatus token_status = 7;
     */
    tokenStatus: ExternalTokenStatus;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.IngestPipelineConfig
 */
export interface IngestPipelineConfig {
    /**
     * @generated from protobuf field: repeated string sources = 1;
     */
    sources: string[];
    /**
     * @generated from protobuf field: repeated indykite.auditsink.v1beta1.IngestPipelineOperation operations = 2;
     */
    operations: IngestPipelineOperation[];
    /**
     * @generated from protobuf field: string app_agent_token = 3;
     */
    appAgentToken: string;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig
 */
export interface IdentityMatchingPipelineConfig {
    /**
     * NodeFilter contain a list of source types and a list target node types that will be evaluated.
     *
     * @generated from protobuf field: indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.NodeFilter node_filter = 1;
     */
    nodeFilter?: IdentityMatchingPipelineConfig_NodeFilter;
    /**
     * SimilarityScoreCutoff defines the threshold (in range [0,1]), above which identities will be automatically matched.
     *
     * @generated from protobuf field: float similarity_score_cutoff = 2;
     */
    similarityScoreCutoff: number;
    /**
     * PropertyMappingStatus is the status assigned to the pipeline's step that maps node types' properties.
     *
     * @generated from protobuf field: indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.Status property_mapping_status = 3;
     */
    propertyMappingStatus: IdentityMatchingPipelineConfig_Status;
    /**
     * Output only. Any error message from the property mapping analysis explaining the current property_mapping_status.
     *
     * @generated from protobuf field: google.protobuf.StringValue property_mapping_message = 8;
     */
    propertyMappingMessage?: StringValue;
    /**
     * EntityMappingStatus is the status assigned to the pipeline's step that matches node identities.
     *
     * @generated from protobuf field: indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.Status entity_matching_status = 4;
     */
    entityMatchingStatus: IdentityMatchingPipelineConfig_Status;
    /**
     * Output only. Any error message from the entity matching analysis explaining the current entity_matching_status.
     *
     * @generated from protobuf field: google.protobuf.StringValue entity_matching_message = 9;
     */
    entityMatchingMessage?: StringValue;
    /**
     * PropertyMappings contains the rules the pipeline will use to match source nodes with target nodes.
     *
     * @generated from protobuf field: repeated indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.PropertyMapping property_mappings = 5;
     */
    propertyMappings: IdentityMatchingPipelineConfig_PropertyMapping[];
    /**
     * RerunInterval is the time between scheduled re-runs.
     *
     * @generated from protobuf field: string rerun_interval = 6;
     */
    rerunInterval: string;
    /**
     * Output only. The time at which the pipeline was last run.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_run_time = 7;
     */
    lastRunTime?: Timestamp;
    /**
     * Output only. The gcs url where the analysis report is stored.
     *
     * @generated from protobuf field: google.protobuf.StringValue report_url = 10;
     */
    reportUrl?: StringValue;
    /**
     * Output only. The format in which the report is stored.
     *
     * @generated from protobuf field: google.protobuf.StringValue report_type = 11;
     */
    reportType?: StringValue;
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.NodeFilter
 */
export interface IdentityMatchingPipelineConfig_NodeFilter {
    /**
     * SourceNodeTypes is a list of node types that will be compared against the nodes with type in TargetNodeTypes.
     *
     * @generated from protobuf field: repeated string source_node_types = 1;
     */
    sourceNodeTypes: string[];
    /**
     * TargetNodeTypes is a list of node types that will be compared against the nodes with type in SourceNodeTypes.
     *
     * @generated from protobuf field: repeated string target_node_types = 2;
     */
    targetNodeTypes: string[];
}
/**
 * @generated from protobuf message indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.PropertyMapping
 */
export interface IdentityMatchingPipelineConfig_PropertyMapping {
    /**
     * SourceNodeType is the type of the node that will be compared to nodes of TargetNodeType.
     *
     * @generated from protobuf field: string source_node_type = 1;
     */
    sourceNodeType: string;
    /**
     * SourceNodeProperty is a property of the source node that will be compared to TargetNodeProperty.
     *
     * @generated from protobuf field: string source_node_property = 2;
     */
    sourceNodeProperty: string;
    /**
     * TargetNodeType is the type of the node that will be compared to nodes of SourceNodeType.
     *
     * @generated from protobuf field: string target_node_type = 3;
     */
    targetNodeType: string;
    /**
     * TargetNodeProperty is a property of the source node that will be compared to SourceNodeProperty.
     *
     * @generated from protobuf field: string target_node_property = 4;
     */
    targetNodeProperty: string;
    /**
     * SimilarityScoreCutoff defines the threshold (in range [0,1]), above which identities will be automatically matched.
     *
     * @generated from protobuf field: float similarity_score_cutoff = 5;
     */
    similarityScoreCutoff: number;
}
/**
 * @generated from protobuf enum indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.Status
 */
export enum IdentityMatchingPipelineConfig_Status {
    /**
     * @generated from protobuf enum value: STATUS_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: STATUS_PENDING = 1;
     */
    PENDING = 1,
    /**
     * @generated from protobuf enum value: STATUS_IN_PROGRESS = 2;
     */
    IN_PROGRESS = 2,
    /**
     * @generated from protobuf enum value: STATUS_SUCCESS = 3;
     */
    SUCCESS = 3,
    /**
     * @generated from protobuf enum value: STATUS_ERROR = 4;
     */
    ERROR = 4
}
/**
 * ConfigType is equivalent to internal DocumentType, for easier maintenance keep same numbers.
 *
 * @generated from protobuf enum indykite.auditsink.v1beta1.ConfigType
 */
export enum ConfigType {
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_CUSTOMER = 1;
     */
    CUSTOMER = 1,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_APPLICATION_SPACE = 2;
     */
    APPLICATION_SPACE = 2,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_ISSUER = 15;
     */
    ISSUER = 15,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_APPLICATION = 4;
     */
    APPLICATION = 4,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_APP_AGENT = 5;
     */
    APP_AGENT = 5,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_APP_AGENT_CREDENTIAL = 6;
     */
    APP_AGENT_CREDENTIAL = 6,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_SERVICE_ACCOUNT = 18;
     */
    SERVICE_ACCOUNT = 18,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_SERVICE_CREDENTIAL = 19;
     */
    SERVICE_CREDENTIAL = 19,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_DIGITAL_TWIN = 21;
     */
    DIGITAL_TWIN = 21,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_AUDIT_SINK = 27;
     */
    AUDIT_SINK = 27,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_TOKEN_INTROSPECT = 30;
     */
    TOKEN_INTROSPECT = 30,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_AUTHORIZATION_POLICY = 22;
     */
    AUTHORIZATION_POLICY = 22,
    /**
     * CONFIG_TYPE_RESOURCE = 25; // Not use in Config API, but in Ingest/IKG
     * CONFIG_TYPE_RELATION = 26; // Not use in Config API, but in Ingest/IKG
     *
     * @generated from protobuf enum value: CONFIG_TYPE_CONSENT = 29;
     */
    CONSENT = 29,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_INGEST_PIPELINE = 31;
     */
    INGEST_PIPELINE = 31,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_IDENTITY_MATCHING_PIPELINE = 32;
     */
    IDENTITY_MATCHING_PIPELINE = 32,
    /**
     * @generated from protobuf enum value: CONFIG_TYPE_EXTERNAL_DATA_RESOLVER = 33;
     */
    EXTERNAL_DATA_RESOLVER = 33
}
/**
 * @generated from protobuf enum indykite.auditsink.v1beta1.ExternalTokenStatus
 */
export enum ExternalTokenStatus {
    /**
     * @generated from protobuf enum value: EXTERNAL_TOKEN_STATUS_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: EXTERNAL_TOKEN_STATUS_ENFORCE = 1;
     */
    ENFORCE = 1,
    /**
     * @generated from protobuf enum value: EXTERNAL_TOKEN_STATUS_ALLOW = 2;
     */
    ALLOW = 2,
    /**
     * @generated from protobuf enum value: EXTERNAL_TOKEN_STATUS_DISALLOW = 3;
     */
    DISALLOW = 3
}
/**
 * @generated from protobuf enum indykite.auditsink.v1beta1.IngestPipelineOperation
 */
export enum IngestPipelineOperation {
    /**
     * @generated from protobuf enum value: INGEST_PIPELINE_OPERATION_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: INGEST_PIPELINE_OPERATION_UPSERT_NODE = 1;
     */
    UPSERT_NODE = 1,
    /**
     * @generated from protobuf enum value: INGEST_PIPELINE_OPERATION_UPSERT_RELATIONSHIP = 2;
     */
    UPSERT_RELATIONSHIP = 2,
    /**
     * @generated from protobuf enum value: INGEST_PIPELINE_OPERATION_DELETE_NODE = 3;
     */
    DELETE_NODE = 3,
    /**
     * @generated from protobuf enum value: INGEST_PIPELINE_OPERATION_DELETE_RELATIONSHIP = 4;
     */
    DELETE_RELATIONSHIP = 4,
    /**
     * @generated from protobuf enum value: INGEST_PIPELINE_OPERATION_DELETE_NODE_PROPERTY = 5;
     */
    DELETE_NODE_PROPERTY = 5,
    /**
     * @generated from protobuf enum value: INGEST_PIPELINE_OPERATION_DELETE_RELATIONSHIP_PROPERTY = 6;
     */
    DELETE_RELATIONSHIP_PROPERTY = 6
}
// @generated message type with reflection information, may provide speed optimized methods
class ContainersPath$Type extends MessageType<ContainersPath> {
    constructor() {
        super("indykite.auditsink.v1beta1.ContainersPath", [
            { no: 1, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "application_space_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ContainersPath>): ContainersPath {
        const message = { customerId: "", applicationSpaceId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ContainersPath>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContainersPath): ContainersPath {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string customer_id */ 1:
                    message.customerId = reader.string();
                    break;
                case /* string application_space_id */ 2:
                    message.applicationSpaceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ContainersPath, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string customer_id = 1; */
        if (message.customerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.customerId);
        /* string application_space_id = 2; */
        if (message.applicationSpaceId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.applicationSpaceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ContainersPath
 */
export const ContainersPath = new ContainersPath$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatedConfig$Type extends MessageType<CreatedConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.CreatedConfig", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] },
            { no: 3, name: "location", kind: "message", T: () => CreatedConfig_Location },
            { no: 5, name: "containers_path", kind: "message", T: () => ContainersPath },
            { no: 4, name: "detail", kind: "message", T: () => ConfigDetail }
        ]);
    }
    create(value?: PartialMessage<CreatedConfig>): CreatedConfig {
        const message = { id: "", type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreatedConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatedConfig): CreatedConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* indykite.auditsink.v1beta1.CreatedConfig.Location location */ 3:
                    message.location = CreatedConfig_Location.internalBinaryRead(reader, reader.uint32(), options, message.location);
                    break;
                case /* indykite.auditsink.v1beta1.ContainersPath containers_path */ 5:
                    message.containersPath = ContainersPath.internalBinaryRead(reader, reader.uint32(), options, message.containersPath);
                    break;
                case /* indykite.auditsink.v1beta1.ConfigDetail detail */ 4:
                    message.detail = ConfigDetail.internalBinaryRead(reader, reader.uint32(), options, message.detail);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatedConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* indykite.auditsink.v1beta1.ConfigType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* indykite.auditsink.v1beta1.CreatedConfig.Location location = 3; */
        if (message.location)
            CreatedConfig_Location.internalBinaryWrite(message.location, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ContainersPath containers_path = 5; */
        if (message.containersPath)
            ContainersPath.internalBinaryWrite(message.containersPath, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ConfigDetail detail = 4; */
        if (message.detail)
            ConfigDetail.internalBinaryWrite(message.detail, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.CreatedConfig
 */
export const CreatedConfig = new CreatedConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatedConfig_Location$Type extends MessageType<CreatedConfig_Location> {
    constructor() {
        super("indykite.auditsink.v1beta1.CreatedConfig.Location", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<CreatedConfig_Location>): CreatedConfig_Location {
        const message = { id: "", type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreatedConfig_Location>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatedConfig_Location): CreatedConfig_Location {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatedConfig_Location, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* indykite.auditsink.v1beta1.ConfigType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.CreatedConfig.Location
 */
export const CreatedConfig_Location = new CreatedConfig_Location$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadConfig$Type extends MessageType<ReadConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.ReadConfig", [
            { no: 1, name: "id", kind: "scalar", oneof: "identifier", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "message", oneof: "identifier", T: () => ReadConfig_NameIdentifier },
            { no: 4, name: "containers_path", kind: "message", T: () => ContainersPath },
            { no: 3, name: "type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<ReadConfig>): ReadConfig {
        const message = { identifier: { oneofKind: undefined }, type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadConfig): ReadConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.identifier = {
                        oneofKind: "id",
                        id: reader.string()
                    };
                    break;
                case /* indykite.auditsink.v1beta1.ReadConfig.NameIdentifier name */ 2:
                    message.identifier = {
                        oneofKind: "name",
                        name: ReadConfig_NameIdentifier.internalBinaryRead(reader, reader.uint32(), options, (message.identifier as any).name)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.ContainersPath containers_path */ 4:
                    message.containersPath = ContainersPath.internalBinaryRead(reader, reader.uint32(), options, message.containersPath);
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType type */ 3:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.identifier.oneofKind === "id")
            writer.tag(1, WireType.LengthDelimited).string(message.identifier.id);
        /* indykite.auditsink.v1beta1.ReadConfig.NameIdentifier name = 2; */
        if (message.identifier.oneofKind === "name")
            ReadConfig_NameIdentifier.internalBinaryWrite(message.identifier.name, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ContainersPath containers_path = 4; */
        if (message.containersPath)
            ContainersPath.internalBinaryWrite(message.containersPath, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ConfigType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ReadConfig
 */
export const ReadConfig = new ReadConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadConfig_NameIdentifier$Type extends MessageType<ReadConfig_NameIdentifier> {
    constructor() {
        super("indykite.auditsink.v1beta1.ReadConfig.NameIdentifier", [
            { no: 1, name: "location_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "location_type", kind: "enum", opt: true, T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReadConfig_NameIdentifier>): ReadConfig_NameIdentifier {
        const message = { locationId: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadConfig_NameIdentifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadConfig_NameIdentifier): ReadConfig_NameIdentifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string location_id */ 1:
                    message.locationId = reader.string();
                    break;
                case /* optional indykite.auditsink.v1beta1.ConfigType location_type */ 2:
                    message.locationType = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadConfig_NameIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string location_id = 1; */
        if (message.locationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationId);
        /* optional indykite.auditsink.v1beta1.ConfigType location_type = 2; */
        if (message.locationType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.locationType);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ReadConfig.NameIdentifier
 */
export const ReadConfig_NameIdentifier = new ReadConfig_NameIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatedConfig$Type extends MessageType<UpdatedConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.UpdatedConfig", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] },
            { no: 5, name: "containers_path", kind: "message", T: () => ContainersPath },
            { no: 3, name: "before", kind: "message", T: () => ConfigDetail },
            { no: 4, name: "after", kind: "message", T: () => ConfigDetail }
        ]);
    }
    create(value?: PartialMessage<UpdatedConfig>): UpdatedConfig {
        const message = { id: "", type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdatedConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatedConfig): UpdatedConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* indykite.auditsink.v1beta1.ContainersPath containers_path */ 5:
                    message.containersPath = ContainersPath.internalBinaryRead(reader, reader.uint32(), options, message.containersPath);
                    break;
                case /* indykite.auditsink.v1beta1.ConfigDetail before */ 3:
                    message.before = ConfigDetail.internalBinaryRead(reader, reader.uint32(), options, message.before);
                    break;
                case /* indykite.auditsink.v1beta1.ConfigDetail after */ 4:
                    message.after = ConfigDetail.internalBinaryRead(reader, reader.uint32(), options, message.after);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatedConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* indykite.auditsink.v1beta1.ConfigType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* indykite.auditsink.v1beta1.ContainersPath containers_path = 5; */
        if (message.containersPath)
            ContainersPath.internalBinaryWrite(message.containersPath, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ConfigDetail before = 3; */
        if (message.before)
            ConfigDetail.internalBinaryWrite(message.before, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ConfigDetail after = 4; */
        if (message.after)
            ConfigDetail.internalBinaryWrite(message.after, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.UpdatedConfig
 */
export const UpdatedConfig = new UpdatedConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletedConfig$Type extends MessageType<DeletedConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.DeletedConfig", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] },
            { no: 3, name: "containers_path", kind: "message", T: () => ContainersPath }
        ]);
    }
    create(value?: PartialMessage<DeletedConfig>): DeletedConfig {
        const message = { id: "", type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeletedConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletedConfig): DeletedConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* indykite.auditsink.v1beta1.ContainersPath containers_path */ 3:
                    message.containersPath = ContainersPath.internalBinaryRead(reader, reader.uint32(), options, message.containersPath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletedConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* indykite.auditsink.v1beta1.ConfigType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* indykite.auditsink.v1beta1.ContainersPath containers_path = 3; */
        if (message.containersPath)
            ContainersPath.internalBinaryWrite(message.containersPath, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.DeletedConfig
 */
export const DeletedConfig = new DeletedConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigDetail$Type extends MessageType<ConfigDetail> {
    constructor() {
        super("indykite.auditsink.v1beta1.ConfigDetail", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 8, name: "application_agent_credential", kind: "message", oneof: "configuration", T: () => ApplicationAgentCredentialConfig },
            { no: 9, name: "service_account_credential", kind: "message", oneof: "configuration", T: () => ServiceAccountCredentialConfig },
            { no: 12, name: "audit_sink_config", kind: "message", oneof: "configuration", T: () => AuditSinkConfig },
            { no: 15, name: "authorization_policy_config", kind: "message", oneof: "configuration", T: () => AuthorizationPolicyConfig },
            { no: 19, name: "token_introspect_config", kind: "message", oneof: "configuration", T: () => TokenIntrospectConfig },
            { no: 22, name: "external_data_resolver_config", kind: "message", oneof: "configuration", T: () => ExternalDataResolverConfig },
            { no: 18, name: "consent_config", kind: "message", oneof: "configuration", T: () => ConsentConfiguration },
            { no: 20, name: "ingest_pipeline_config", kind: "message", oneof: "configuration", T: () => IngestPipelineConfig },
            { no: 21, name: "identity_matching_pipeline_config", kind: "message", oneof: "configuration", T: () => IdentityMatchingPipelineConfig }
        ]);
    }
    create(value?: PartialMessage<ConfigDetail>): ConfigDetail {
        const message = { name: "", displayName: "", description: "", version: "0", configuration: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConfigDetail>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigDetail): ConfigDetail {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string display_name */ 2:
                    message.displayName = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* int64 version */ 4:
                    message.version = reader.int64().toString();
                    break;
                case /* indykite.auditsink.v1beta1.ApplicationAgentCredentialConfig application_agent_credential */ 8:
                    message.configuration = {
                        oneofKind: "applicationAgentCredential",
                        applicationAgentCredential: ApplicationAgentCredentialConfig.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).applicationAgentCredential)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.ServiceAccountCredentialConfig service_account_credential */ 9:
                    message.configuration = {
                        oneofKind: "serviceAccountCredential",
                        serviceAccountCredential: ServiceAccountCredentialConfig.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).serviceAccountCredential)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.AuditSinkConfig audit_sink_config */ 12:
                    message.configuration = {
                        oneofKind: "auditSinkConfig",
                        auditSinkConfig: AuditSinkConfig.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).auditSinkConfig)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.AuthorizationPolicyConfig authorization_policy_config */ 15:
                    message.configuration = {
                        oneofKind: "authorizationPolicyConfig",
                        authorizationPolicyConfig: AuthorizationPolicyConfig.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).authorizationPolicyConfig)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.TokenIntrospectConfig token_introspect_config */ 19:
                    message.configuration = {
                        oneofKind: "tokenIntrospectConfig",
                        tokenIntrospectConfig: TokenIntrospectConfig.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).tokenIntrospectConfig)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.ExternalDataResolverConfig external_data_resolver_config */ 22:
                    message.configuration = {
                        oneofKind: "externalDataResolverConfig",
                        externalDataResolverConfig: ExternalDataResolverConfig.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).externalDataResolverConfig)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.ConsentConfiguration consent_config */ 18:
                    message.configuration = {
                        oneofKind: "consentConfig",
                        consentConfig: ConsentConfiguration.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).consentConfig)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.IngestPipelineConfig ingest_pipeline_config */ 20:
                    message.configuration = {
                        oneofKind: "ingestPipelineConfig",
                        ingestPipelineConfig: IngestPipelineConfig.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).ingestPipelineConfig)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig identity_matching_pipeline_config */ 21:
                    message.configuration = {
                        oneofKind: "identityMatchingPipelineConfig",
                        identityMatchingPipelineConfig: IdentityMatchingPipelineConfig.internalBinaryRead(reader, reader.uint32(), options, (message.configuration as any).identityMatchingPipelineConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigDetail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string display_name = 2; */
        if (message.displayName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.displayName);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* int64 version = 4; */
        if (message.version !== "0")
            writer.tag(4, WireType.Varint).int64(message.version);
        /* indykite.auditsink.v1beta1.ApplicationAgentCredentialConfig application_agent_credential = 8; */
        if (message.configuration.oneofKind === "applicationAgentCredential")
            ApplicationAgentCredentialConfig.internalBinaryWrite(message.configuration.applicationAgentCredential, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ServiceAccountCredentialConfig service_account_credential = 9; */
        if (message.configuration.oneofKind === "serviceAccountCredential")
            ServiceAccountCredentialConfig.internalBinaryWrite(message.configuration.serviceAccountCredential, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.AuditSinkConfig audit_sink_config = 12; */
        if (message.configuration.oneofKind === "auditSinkConfig")
            AuditSinkConfig.internalBinaryWrite(message.configuration.auditSinkConfig, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.AuthorizationPolicyConfig authorization_policy_config = 15; */
        if (message.configuration.oneofKind === "authorizationPolicyConfig")
            AuthorizationPolicyConfig.internalBinaryWrite(message.configuration.authorizationPolicyConfig, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.TokenIntrospectConfig token_introspect_config = 19; */
        if (message.configuration.oneofKind === "tokenIntrospectConfig")
            TokenIntrospectConfig.internalBinaryWrite(message.configuration.tokenIntrospectConfig, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ExternalDataResolverConfig external_data_resolver_config = 22; */
        if (message.configuration.oneofKind === "externalDataResolverConfig")
            ExternalDataResolverConfig.internalBinaryWrite(message.configuration.externalDataResolverConfig, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.ConsentConfiguration consent_config = 18; */
        if (message.configuration.oneofKind === "consentConfig")
            ConsentConfiguration.internalBinaryWrite(message.configuration.consentConfig, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.IngestPipelineConfig ingest_pipeline_config = 20; */
        if (message.configuration.oneofKind === "ingestPipelineConfig")
            IngestPipelineConfig.internalBinaryWrite(message.configuration.ingestPipelineConfig, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig identity_matching_pipeline_config = 21; */
        if (message.configuration.oneofKind === "identityMatchingPipelineConfig")
            IdentityMatchingPipelineConfig.internalBinaryWrite(message.configuration.identityMatchingPipelineConfig, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ConfigDetail
 */
export const ConfigDetail = new ConfigDetail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplicationAgentCredentialConfig$Type extends MessageType<ApplicationAgentCredentialConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.ApplicationAgentCredentialConfig", [
            { no: 1, name: "kid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key_format", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "original_kid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "expire_time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ApplicationAgentCredentialConfig>): ApplicationAgentCredentialConfig {
        const message = { kid: "", keyFormat: "", originalKid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ApplicationAgentCredentialConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplicationAgentCredentialConfig): ApplicationAgentCredentialConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string kid */ 1:
                    message.kid = reader.string();
                    break;
                case /* string key_format */ 2:
                    message.keyFormat = reader.string();
                    break;
                case /* string original_kid */ 3:
                    message.originalKid = reader.string();
                    break;
                case /* google.protobuf.Timestamp expire_time */ 4:
                    message.expireTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expireTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplicationAgentCredentialConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string kid = 1; */
        if (message.kid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kid);
        /* string key_format = 2; */
        if (message.keyFormat !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyFormat);
        /* string original_kid = 3; */
        if (message.originalKid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.originalKid);
        /* google.protobuf.Timestamp expire_time = 4; */
        if (message.expireTime)
            Timestamp.internalBinaryWrite(message.expireTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ApplicationAgentCredentialConfig
 */
export const ApplicationAgentCredentialConfig = new ApplicationAgentCredentialConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceAccountCredentialConfig$Type extends MessageType<ServiceAccountCredentialConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.ServiceAccountCredentialConfig", [
            { no: 1, name: "kid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key_format", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "original_kid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "expire_time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ServiceAccountCredentialConfig>): ServiceAccountCredentialConfig {
        const message = { kid: "", keyFormat: "", originalKid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServiceAccountCredentialConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceAccountCredentialConfig): ServiceAccountCredentialConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string kid */ 1:
                    message.kid = reader.string();
                    break;
                case /* string key_format */ 2:
                    message.keyFormat = reader.string();
                    break;
                case /* string original_kid */ 3:
                    message.originalKid = reader.string();
                    break;
                case /* google.protobuf.Timestamp expire_time */ 4:
                    message.expireTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expireTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceAccountCredentialConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string kid = 1; */
        if (message.kid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kid);
        /* string key_format = 2; */
        if (message.keyFormat !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyFormat);
        /* string original_kid = 3; */
        if (message.originalKid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.originalKid);
        /* google.protobuf.Timestamp expire_time = 4; */
        if (message.expireTime)
            Timestamp.internalBinaryWrite(message.expireTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ServiceAccountCredentialConfig
 */
export const ServiceAccountCredentialConfig = new ServiceAccountCredentialConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuditSinkConfig$Type extends MessageType<AuditSinkConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.AuditSinkConfig", [
            { no: 1, name: "kafka", kind: "message", oneof: "provider", T: () => AuditSinkConfig_Kafka }
        ]);
    }
    create(value?: PartialMessage<AuditSinkConfig>): AuditSinkConfig {
        const message = { provider: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuditSinkConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuditSinkConfig): AuditSinkConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.auditsink.v1beta1.AuditSinkConfig.Kafka kafka */ 1:
                    message.provider = {
                        oneofKind: "kafka",
                        kafka: AuditSinkConfig_Kafka.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).kafka)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuditSinkConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.auditsink.v1beta1.AuditSinkConfig.Kafka kafka = 1; */
        if (message.provider.oneofKind === "kafka")
            AuditSinkConfig_Kafka.internalBinaryWrite(message.provider.kafka, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.AuditSinkConfig
 */
export const AuditSinkConfig = new AuditSinkConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuditSinkConfig_Kafka$Type extends MessageType<AuditSinkConfig_Kafka> {
    constructor() {
        super("indykite.auditsink.v1beta1.AuditSinkConfig.Kafka", [
            { no: 1, name: "brokers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "topic", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "disable_tls", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "tls_skip_verify", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuditSinkConfig_Kafka>): AuditSinkConfig_Kafka {
        const message = { brokers: [], topic: "", disableTls: false, tlsSkipVerify: false, username: "", password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuditSinkConfig_Kafka>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuditSinkConfig_Kafka): AuditSinkConfig_Kafka {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string brokers */ 1:
                    message.brokers.push(reader.string());
                    break;
                case /* string topic */ 2:
                    message.topic = reader.string();
                    break;
                case /* bool disable_tls */ 3:
                    message.disableTls = reader.bool();
                    break;
                case /* bool tls_skip_verify */ 4:
                    message.tlsSkipVerify = reader.bool();
                    break;
                case /* string username */ 5:
                    message.username = reader.string();
                    break;
                case /* string password */ 6:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuditSinkConfig_Kafka, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string brokers = 1; */
        for (let i = 0; i < message.brokers.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.brokers[i]);
        /* string topic = 2; */
        if (message.topic !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.topic);
        /* bool disable_tls = 3; */
        if (message.disableTls !== false)
            writer.tag(3, WireType.Varint).bool(message.disableTls);
        /* bool tls_skip_verify = 4; */
        if (message.tlsSkipVerify !== false)
            writer.tag(4, WireType.Varint).bool(message.tlsSkipVerify);
        /* string username = 5; */
        if (message.username !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.username);
        /* string password = 6; */
        if (message.password !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.AuditSinkConfig.Kafka
 */
export const AuditSinkConfig_Kafka = new AuditSinkConfig_Kafka$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExternalDataResolverConfig$Type extends MessageType<ExternalDataResolverConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.ExternalDataResolverConfig", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "method", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "headers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "request_type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ExternalDataResolverConfig.ContentType", ExternalDataResolverConfig_ContentType, "CONTENT_TYPE_"] },
            { no: 5, name: "request_payload", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "response_type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ExternalDataResolverConfig.ContentType", ExternalDataResolverConfig_ContentType, "CONTENT_TYPE_"] },
            { no: 7, name: "response_selector", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExternalDataResolverConfig>): ExternalDataResolverConfig {
        const message = { url: "", method: "", headers: {}, requestType: 0, requestPayload: "", responseType: 0, responseSelector: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExternalDataResolverConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExternalDataResolverConfig): ExternalDataResolverConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* string method */ 2:
                    message.method = reader.string();
                    break;
                case /* map<string, string> headers */ 3:
                    this.binaryReadMap3(message.headers, reader, options);
                    break;
                case /* indykite.auditsink.v1beta1.ExternalDataResolverConfig.ContentType request_type */ 4:
                    message.requestType = reader.int32();
                    break;
                case /* string request_payload */ 5:
                    message.requestPayload = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ExternalDataResolverConfig.ContentType response_type */ 6:
                    message.responseType = reader.int32();
                    break;
                case /* string response_selector */ 7:
                    message.responseSelector = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: ExternalDataResolverConfig["headers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ExternalDataResolverConfig["headers"] | undefined, val: ExternalDataResolverConfig["headers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.auditsink.v1beta1.ExternalDataResolverConfig.headers");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ExternalDataResolverConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* string method = 2; */
        if (message.method !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.method);
        /* map<string, string> headers = 3; */
        for (let k of Object.keys(message.headers))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.headers[k]).join();
        /* indykite.auditsink.v1beta1.ExternalDataResolverConfig.ContentType request_type = 4; */
        if (message.requestType !== 0)
            writer.tag(4, WireType.Varint).int32(message.requestType);
        /* string request_payload = 5; */
        if (message.requestPayload !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.requestPayload);
        /* indykite.auditsink.v1beta1.ExternalDataResolverConfig.ContentType response_type = 6; */
        if (message.responseType !== 0)
            writer.tag(6, WireType.Varint).int32(message.responseType);
        /* string response_selector = 7; */
        if (message.responseSelector !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.responseSelector);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ExternalDataResolverConfig
 */
export const ExternalDataResolverConfig = new ExternalDataResolverConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizationPolicyConfig$Type extends MessageType<AuthorizationPolicyConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.AuthorizationPolicyConfig", [
            { no: 1, name: "policy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["indykite.auditsink.v1beta1.AuthorizationPolicyConfig.Status", AuthorizationPolicyConfig_Status, "STATUS_"] },
            { no: 3, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthorizationPolicyConfig>): AuthorizationPolicyConfig {
        const message = { policy: "", status: 0, tags: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuthorizationPolicyConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorizationPolicyConfig): AuthorizationPolicyConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string policy */ 1:
                    message.policy = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.AuthorizationPolicyConfig.Status status */ 2:
                    message.status = reader.int32();
                    break;
                case /* repeated string tags */ 3:
                    message.tags.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthorizationPolicyConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string policy = 1; */
        if (message.policy !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.policy);
        /* indykite.auditsink.v1beta1.AuthorizationPolicyConfig.Status status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* repeated string tags = 3; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.tags[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.AuthorizationPolicyConfig
 */
export const AuthorizationPolicyConfig = new AuthorizationPolicyConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssignConfigPermissions$Type extends MessageType<AssignConfigPermissions> {
    constructor() {
        super("indykite.auditsink.v1beta1.AssignConfigPermissions", [
            { no: 1, name: "target_identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] },
            { no: 3, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "object_type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<AssignConfigPermissions>): AssignConfigPermissions {
        const message = { targetIdentifier: "", targetType: 0, role: "", customerId: "", objectId: "", objectType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssignConfigPermissions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssignConfigPermissions): AssignConfigPermissions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string target_identifier */ 1:
                    message.targetIdentifier = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType target_type */ 2:
                    message.targetType = reader.int32();
                    break;
                case /* string role */ 3:
                    message.role = reader.string();
                    break;
                case /* string customer_id */ 4:
                    message.customerId = reader.string();
                    break;
                case /* string object_id */ 5:
                    message.objectId = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType object_type */ 6:
                    message.objectType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssignConfigPermissions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string target_identifier = 1; */
        if (message.targetIdentifier !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.targetIdentifier);
        /* indykite.auditsink.v1beta1.ConfigType target_type = 2; */
        if (message.targetType !== 0)
            writer.tag(2, WireType.Varint).int32(message.targetType);
        /* string role = 3; */
        if (message.role !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.role);
        /* string customer_id = 4; */
        if (message.customerId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.customerId);
        /* string object_id = 5; */
        if (message.objectId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.objectId);
        /* indykite.auditsink.v1beta1.ConfigType object_type = 6; */
        if (message.objectType !== 0)
            writer.tag(6, WireType.Varint).int32(message.objectType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.AssignConfigPermissions
 */
export const AssignConfigPermissions = new AssignConfigPermissions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RevokeConfigPermissions$Type extends MessageType<RevokeConfigPermissions> {
    constructor() {
        super("indykite.auditsink.v1beta1.RevokeConfigPermissions", [
            { no: 1, name: "target_identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] },
            { no: 3, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "object_type", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ConfigType", ConfigType, "CONFIG_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<RevokeConfigPermissions>): RevokeConfigPermissions {
        const message = { targetIdentifier: "", targetType: 0, role: "", customerId: "", objectId: "", objectType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RevokeConfigPermissions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RevokeConfigPermissions): RevokeConfigPermissions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string target_identifier */ 1:
                    message.targetIdentifier = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType target_type */ 2:
                    message.targetType = reader.int32();
                    break;
                case /* string role */ 3:
                    message.role = reader.string();
                    break;
                case /* string customer_id */ 4:
                    message.customerId = reader.string();
                    break;
                case /* string object_id */ 5:
                    message.objectId = reader.string();
                    break;
                case /* indykite.auditsink.v1beta1.ConfigType object_type */ 6:
                    message.objectType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RevokeConfigPermissions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string target_identifier = 1; */
        if (message.targetIdentifier !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.targetIdentifier);
        /* indykite.auditsink.v1beta1.ConfigType target_type = 2; */
        if (message.targetType !== 0)
            writer.tag(2, WireType.Varint).int32(message.targetType);
        /* string role = 3; */
        if (message.role !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.role);
        /* string customer_id = 4; */
        if (message.customerId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.customerId);
        /* string object_id = 5; */
        if (message.objectId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.objectId);
        /* indykite.auditsink.v1beta1.ConfigType object_type = 6; */
        if (message.objectType !== 0)
            writer.tag(6, WireType.Varint).int32(message.objectType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.RevokeConfigPermissions
 */
export const RevokeConfigPermissions = new RevokeConfigPermissions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig$Type extends MessageType<TokenIntrospectConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.TokenIntrospectConfig", [
            { no: 1, name: "jwt", kind: "message", oneof: "tokenMatcher", T: () => TokenIntrospectConfig_JWT },
            { no: 2, name: "opaque", kind: "message", oneof: "tokenMatcher", T: () => TokenIntrospectConfig_Opaque },
            { no: 3, name: "offline", kind: "message", oneof: "validation", T: () => TokenIntrospectConfig_Offline },
            { no: 4, name: "online", kind: "message", oneof: "validation", T: () => TokenIntrospectConfig_Online },
            { no: 7, name: "claims_mapping", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => TokenIntrospectConfig_Claim } },
            { no: 5, name: "ikg_node_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "perform_upsert", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectConfig>): TokenIntrospectConfig {
        const message = { tokenMatcher: { oneofKind: undefined }, validation: { oneofKind: undefined }, claimsMapping: {}, ikgNodeType: "", performUpsert: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig): TokenIntrospectConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.auditsink.v1beta1.TokenIntrospectConfig.JWT jwt */ 1:
                    message.tokenMatcher = {
                        oneofKind: "jwt",
                        jwt: TokenIntrospectConfig_JWT.internalBinaryRead(reader, reader.uint32(), options, (message.tokenMatcher as any).jwt)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.TokenIntrospectConfig.Opaque opaque */ 2:
                    message.tokenMatcher = {
                        oneofKind: "opaque",
                        opaque: TokenIntrospectConfig_Opaque.internalBinaryRead(reader, reader.uint32(), options, (message.tokenMatcher as any).opaque)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.TokenIntrospectConfig.Offline offline */ 3:
                    message.validation = {
                        oneofKind: "offline",
                        offline: TokenIntrospectConfig_Offline.internalBinaryRead(reader, reader.uint32(), options, (message.validation as any).offline)
                    };
                    break;
                case /* indykite.auditsink.v1beta1.TokenIntrospectConfig.Online online */ 4:
                    message.validation = {
                        oneofKind: "online",
                        online: TokenIntrospectConfig_Online.internalBinaryRead(reader, reader.uint32(), options, (message.validation as any).online)
                    };
                    break;
                case /* map<string, indykite.auditsink.v1beta1.TokenIntrospectConfig.Claim> claims_mapping */ 7:
                    this.binaryReadMap7(message.claimsMapping, reader, options);
                    break;
                case /* string ikg_node_type */ 5:
                    message.ikgNodeType = reader.string();
                    break;
                case /* bool perform_upsert */ 6:
                    message.performUpsert = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: TokenIntrospectConfig["claimsMapping"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TokenIntrospectConfig["claimsMapping"] | undefined, val: TokenIntrospectConfig["claimsMapping"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = TokenIntrospectConfig_Claim.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.auditsink.v1beta1.TokenIntrospectConfig.claims_mapping");
            }
        }
        map[key ?? ""] = val ?? TokenIntrospectConfig_Claim.create();
    }
    internalBinaryWrite(message: TokenIntrospectConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.auditsink.v1beta1.TokenIntrospectConfig.JWT jwt = 1; */
        if (message.tokenMatcher.oneofKind === "jwt")
            TokenIntrospectConfig_JWT.internalBinaryWrite(message.tokenMatcher.jwt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.TokenIntrospectConfig.Opaque opaque = 2; */
        if (message.tokenMatcher.oneofKind === "opaque")
            TokenIntrospectConfig_Opaque.internalBinaryWrite(message.tokenMatcher.opaque, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.TokenIntrospectConfig.Offline offline = 3; */
        if (message.validation.oneofKind === "offline")
            TokenIntrospectConfig_Offline.internalBinaryWrite(message.validation.offline, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.TokenIntrospectConfig.Online online = 4; */
        if (message.validation.oneofKind === "online")
            TokenIntrospectConfig_Online.internalBinaryWrite(message.validation.online, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* map<string, indykite.auditsink.v1beta1.TokenIntrospectConfig.Claim> claims_mapping = 7; */
        for (let k of Object.keys(message.claimsMapping)) {
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            TokenIntrospectConfig_Claim.internalBinaryWrite(message.claimsMapping[k], writer, options);
            writer.join().join();
        }
        /* string ikg_node_type = 5; */
        if (message.ikgNodeType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.ikgNodeType);
        /* bool perform_upsert = 6; */
        if (message.performUpsert !== false)
            writer.tag(6, WireType.Varint).bool(message.performUpsert);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig
 */
export const TokenIntrospectConfig = new TokenIntrospectConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig_JWT$Type extends MessageType<TokenIntrospectConfig_JWT> {
    constructor() {
        super("indykite.auditsink.v1beta1.TokenIntrospectConfig.JWT", [
            { no: 1, name: "issuer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "audience", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectConfig_JWT>): TokenIntrospectConfig_JWT {
        const message = { issuer: "", audience: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig_JWT>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig_JWT): TokenIntrospectConfig_JWT {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string issuer */ 1:
                    message.issuer = reader.string();
                    break;
                case /* string audience */ 2:
                    message.audience = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenIntrospectConfig_JWT, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string issuer = 1; */
        if (message.issuer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.issuer);
        /* string audience = 2; */
        if (message.audience !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.audience);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.JWT
 */
export const TokenIntrospectConfig_JWT = new TokenIntrospectConfig_JWT$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig_Opaque$Type extends MessageType<TokenIntrospectConfig_Opaque> {
    constructor() {
        super("indykite.auditsink.v1beta1.TokenIntrospectConfig.Opaque", []);
    }
    create(value?: PartialMessage<TokenIntrospectConfig_Opaque>): TokenIntrospectConfig_Opaque {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig_Opaque>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig_Opaque): TokenIntrospectConfig_Opaque {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TokenIntrospectConfig_Opaque, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.Opaque
 */
export const TokenIntrospectConfig_Opaque = new TokenIntrospectConfig_Opaque$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig_Offline$Type extends MessageType<TokenIntrospectConfig_Offline> {
    constructor() {
        super("indykite.auditsink.v1beta1.TokenIntrospectConfig.Offline", [
            { no: 1, name: "public_jwks", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectConfig_Offline>): TokenIntrospectConfig_Offline {
        const message = { publicJwks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig_Offline>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig_Offline): TokenIntrospectConfig_Offline {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes public_jwks */ 1:
                    message.publicJwks.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenIntrospectConfig_Offline, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes public_jwks = 1; */
        for (let i = 0; i < message.publicJwks.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.publicJwks[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.Offline
 */
export const TokenIntrospectConfig_Offline = new TokenIntrospectConfig_Offline$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig_Online$Type extends MessageType<TokenIntrospectConfig_Online> {
    constructor() {
        super("indykite.auditsink.v1beta1.TokenIntrospectConfig.Online", [
            { no: 1, name: "userinfo_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cache_ttl", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectConfig_Online>): TokenIntrospectConfig_Online {
        const message = { userinfoEndpoint: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig_Online>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig_Online): TokenIntrospectConfig_Online {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string userinfo_endpoint */ 1:
                    message.userinfoEndpoint = reader.string();
                    break;
                case /* google.protobuf.Duration cache_ttl */ 2:
                    message.cacheTtl = Duration.internalBinaryRead(reader, reader.uint32(), options, message.cacheTtl);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenIntrospectConfig_Online, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string userinfo_endpoint = 1; */
        if (message.userinfoEndpoint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userinfoEndpoint);
        /* google.protobuf.Duration cache_ttl = 2; */
        if (message.cacheTtl)
            Duration.internalBinaryWrite(message.cacheTtl, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.Online
 */
export const TokenIntrospectConfig_Online = new TokenIntrospectConfig_Online$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig_Claim$Type extends MessageType<TokenIntrospectConfig_Claim> {
    constructor() {
        super("indykite.auditsink.v1beta1.TokenIntrospectConfig.Claim", [
            { no: 1, name: "selector", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectConfig_Claim>): TokenIntrospectConfig_Claim {
        const message = { selector: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig_Claim>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig_Claim): TokenIntrospectConfig_Claim {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string selector */ 1:
                    message.selector = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenIntrospectConfig_Claim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string selector = 1; */
        if (message.selector !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.selector);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.TokenIntrospectConfig.Claim
 */
export const TokenIntrospectConfig_Claim = new TokenIntrospectConfig_Claim$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConsentConfiguration$Type extends MessageType<ConsentConfiguration> {
    constructor() {
        super("indykite.auditsink.v1beta1.ConsentConfiguration", [
            { no: 1, name: "purpose", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data_points", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "application_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "validity_period", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 5, name: "revoke_after_use", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "token_status", kind: "enum", T: () => ["indykite.auditsink.v1beta1.ExternalTokenStatus", ExternalTokenStatus, "EXTERNAL_TOKEN_STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<ConsentConfiguration>): ConsentConfiguration {
        const message = { purpose: "", dataPoints: [], applicationId: "", validityPeriod: "0", revokeAfterUse: false, tokenStatus: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConsentConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsentConfiguration): ConsentConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string purpose */ 1:
                    message.purpose = reader.string();
                    break;
                case /* repeated string data_points */ 2:
                    message.dataPoints.push(reader.string());
                    break;
                case /* string application_id */ 3:
                    message.applicationId = reader.string();
                    break;
                case /* uint64 validity_period */ 4:
                    message.validityPeriod = reader.uint64().toString();
                    break;
                case /* bool revoke_after_use */ 5:
                    message.revokeAfterUse = reader.bool();
                    break;
                case /* indykite.auditsink.v1beta1.ExternalTokenStatus token_status */ 7:
                    message.tokenStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConsentConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string purpose = 1; */
        if (message.purpose !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.purpose);
        /* repeated string data_points = 2; */
        for (let i = 0; i < message.dataPoints.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.dataPoints[i]);
        /* string application_id = 3; */
        if (message.applicationId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.applicationId);
        /* uint64 validity_period = 4; */
        if (message.validityPeriod !== "0")
            writer.tag(4, WireType.Varint).uint64(message.validityPeriod);
        /* bool revoke_after_use = 5; */
        if (message.revokeAfterUse !== false)
            writer.tag(5, WireType.Varint).bool(message.revokeAfterUse);
        /* indykite.auditsink.v1beta1.ExternalTokenStatus token_status = 7; */
        if (message.tokenStatus !== 0)
            writer.tag(7, WireType.Varint).int32(message.tokenStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.ConsentConfiguration
 */
export const ConsentConfiguration = new ConsentConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IngestPipelineConfig$Type extends MessageType<IngestPipelineConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.IngestPipelineConfig", [
            { no: 1, name: "sources", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "operations", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["indykite.auditsink.v1beta1.IngestPipelineOperation", IngestPipelineOperation, "INGEST_PIPELINE_OPERATION_"] },
            { no: 3, name: "app_agent_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<IngestPipelineConfig>): IngestPipelineConfig {
        const message = { sources: [], operations: [], appAgentToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IngestPipelineConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IngestPipelineConfig): IngestPipelineConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string sources */ 1:
                    message.sources.push(reader.string());
                    break;
                case /* repeated indykite.auditsink.v1beta1.IngestPipelineOperation operations */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.operations.push(reader.int32());
                    else
                        message.operations.push(reader.int32());
                    break;
                case /* string app_agent_token */ 3:
                    message.appAgentToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IngestPipelineConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string sources = 1; */
        for (let i = 0; i < message.sources.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.sources[i]);
        /* repeated indykite.auditsink.v1beta1.IngestPipelineOperation operations = 2; */
        if (message.operations.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.operations.length; i++)
                writer.int32(message.operations[i]);
            writer.join();
        }
        /* string app_agent_token = 3; */
        if (message.appAgentToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.appAgentToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.IngestPipelineConfig
 */
export const IngestPipelineConfig = new IngestPipelineConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdentityMatchingPipelineConfig$Type extends MessageType<IdentityMatchingPipelineConfig> {
    constructor() {
        super("indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig", [
            { no: 1, name: "node_filter", kind: "message", T: () => IdentityMatchingPipelineConfig_NodeFilter },
            { no: 2, name: "similarity_score_cutoff", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "property_mapping_status", kind: "enum", T: () => ["indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.Status", IdentityMatchingPipelineConfig_Status, "STATUS_"] },
            { no: 8, name: "property_mapping_message", kind: "message", T: () => StringValue },
            { no: 4, name: "entity_matching_status", kind: "enum", T: () => ["indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.Status", IdentityMatchingPipelineConfig_Status, "STATUS_"] },
            { no: 9, name: "entity_matching_message", kind: "message", T: () => StringValue },
            { no: 5, name: "property_mappings", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => IdentityMatchingPipelineConfig_PropertyMapping },
            { no: 6, name: "rerun_interval", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "last_run_time", kind: "message", T: () => Timestamp },
            { no: 10, name: "report_url", kind: "message", T: () => StringValue },
            { no: 11, name: "report_type", kind: "message", T: () => StringValue }
        ]);
    }
    create(value?: PartialMessage<IdentityMatchingPipelineConfig>): IdentityMatchingPipelineConfig {
        const message = { similarityScoreCutoff: 0, propertyMappingStatus: 0, entityMatchingStatus: 0, propertyMappings: [], rerunInterval: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IdentityMatchingPipelineConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IdentityMatchingPipelineConfig): IdentityMatchingPipelineConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.NodeFilter node_filter */ 1:
                    message.nodeFilter = IdentityMatchingPipelineConfig_NodeFilter.internalBinaryRead(reader, reader.uint32(), options, message.nodeFilter);
                    break;
                case /* float similarity_score_cutoff */ 2:
                    message.similarityScoreCutoff = reader.float();
                    break;
                case /* indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.Status property_mapping_status */ 3:
                    message.propertyMappingStatus = reader.int32();
                    break;
                case /* google.protobuf.StringValue property_mapping_message */ 8:
                    message.propertyMappingMessage = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.propertyMappingMessage);
                    break;
                case /* indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.Status entity_matching_status */ 4:
                    message.entityMatchingStatus = reader.int32();
                    break;
                case /* google.protobuf.StringValue entity_matching_message */ 9:
                    message.entityMatchingMessage = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.entityMatchingMessage);
                    break;
                case /* repeated indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.PropertyMapping property_mappings */ 5:
                    message.propertyMappings.push(IdentityMatchingPipelineConfig_PropertyMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string rerun_interval */ 6:
                    message.rerunInterval = reader.string();
                    break;
                case /* google.protobuf.Timestamp last_run_time */ 7:
                    message.lastRunTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastRunTime);
                    break;
                case /* google.protobuf.StringValue report_url */ 10:
                    message.reportUrl = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.reportUrl);
                    break;
                case /* google.protobuf.StringValue report_type */ 11:
                    message.reportType = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.reportType);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IdentityMatchingPipelineConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.NodeFilter node_filter = 1; */
        if (message.nodeFilter)
            IdentityMatchingPipelineConfig_NodeFilter.internalBinaryWrite(message.nodeFilter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* float similarity_score_cutoff = 2; */
        if (message.similarityScoreCutoff !== 0)
            writer.tag(2, WireType.Bit32).float(message.similarityScoreCutoff);
        /* indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.Status property_mapping_status = 3; */
        if (message.propertyMappingStatus !== 0)
            writer.tag(3, WireType.Varint).int32(message.propertyMappingStatus);
        /* google.protobuf.StringValue property_mapping_message = 8; */
        if (message.propertyMappingMessage)
            StringValue.internalBinaryWrite(message.propertyMappingMessage, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.Status entity_matching_status = 4; */
        if (message.entityMatchingStatus !== 0)
            writer.tag(4, WireType.Varint).int32(message.entityMatchingStatus);
        /* google.protobuf.StringValue entity_matching_message = 9; */
        if (message.entityMatchingMessage)
            StringValue.internalBinaryWrite(message.entityMatchingMessage, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.PropertyMapping property_mappings = 5; */
        for (let i = 0; i < message.propertyMappings.length; i++)
            IdentityMatchingPipelineConfig_PropertyMapping.internalBinaryWrite(message.propertyMappings[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string rerun_interval = 6; */
        if (message.rerunInterval !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.rerunInterval);
        /* google.protobuf.Timestamp last_run_time = 7; */
        if (message.lastRunTime)
            Timestamp.internalBinaryWrite(message.lastRunTime, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.StringValue report_url = 10; */
        if (message.reportUrl)
            StringValue.internalBinaryWrite(message.reportUrl, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.StringValue report_type = 11; */
        if (message.reportType)
            StringValue.internalBinaryWrite(message.reportType, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig
 */
export const IdentityMatchingPipelineConfig = new IdentityMatchingPipelineConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdentityMatchingPipelineConfig_NodeFilter$Type extends MessageType<IdentityMatchingPipelineConfig_NodeFilter> {
    constructor() {
        super("indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.NodeFilter", [
            { no: 1, name: "source_node_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_node_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<IdentityMatchingPipelineConfig_NodeFilter>): IdentityMatchingPipelineConfig_NodeFilter {
        const message = { sourceNodeTypes: [], targetNodeTypes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IdentityMatchingPipelineConfig_NodeFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IdentityMatchingPipelineConfig_NodeFilter): IdentityMatchingPipelineConfig_NodeFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string source_node_types */ 1:
                    message.sourceNodeTypes.push(reader.string());
                    break;
                case /* repeated string target_node_types */ 2:
                    message.targetNodeTypes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IdentityMatchingPipelineConfig_NodeFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string source_node_types = 1; */
        for (let i = 0; i < message.sourceNodeTypes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.sourceNodeTypes[i]);
        /* repeated string target_node_types = 2; */
        for (let i = 0; i < message.targetNodeTypes.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.targetNodeTypes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.NodeFilter
 */
export const IdentityMatchingPipelineConfig_NodeFilter = new IdentityMatchingPipelineConfig_NodeFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdentityMatchingPipelineConfig_PropertyMapping$Type extends MessageType<IdentityMatchingPipelineConfig_PropertyMapping> {
    constructor() {
        super("indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.PropertyMapping", [
            { no: 1, name: "source_node_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source_node_property", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "target_node_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "target_node_property", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "similarity_score_cutoff", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<IdentityMatchingPipelineConfig_PropertyMapping>): IdentityMatchingPipelineConfig_PropertyMapping {
        const message = { sourceNodeType: "", sourceNodeProperty: "", targetNodeType: "", targetNodeProperty: "", similarityScoreCutoff: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IdentityMatchingPipelineConfig_PropertyMapping>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IdentityMatchingPipelineConfig_PropertyMapping): IdentityMatchingPipelineConfig_PropertyMapping {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string source_node_type */ 1:
                    message.sourceNodeType = reader.string();
                    break;
                case /* string source_node_property */ 2:
                    message.sourceNodeProperty = reader.string();
                    break;
                case /* string target_node_type */ 3:
                    message.targetNodeType = reader.string();
                    break;
                case /* string target_node_property */ 4:
                    message.targetNodeProperty = reader.string();
                    break;
                case /* float similarity_score_cutoff */ 5:
                    message.similarityScoreCutoff = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IdentityMatchingPipelineConfig_PropertyMapping, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string source_node_type = 1; */
        if (message.sourceNodeType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sourceNodeType);
        /* string source_node_property = 2; */
        if (message.sourceNodeProperty !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sourceNodeProperty);
        /* string target_node_type = 3; */
        if (message.targetNodeType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.targetNodeType);
        /* string target_node_property = 4; */
        if (message.targetNodeProperty !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.targetNodeProperty);
        /* float similarity_score_cutoff = 5; */
        if (message.similarityScoreCutoff !== 0)
            writer.tag(5, WireType.Bit32).float(message.similarityScoreCutoff);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.auditsink.v1beta1.IdentityMatchingPipelineConfig.PropertyMapping
 */
export const IdentityMatchingPipelineConfig_PropertyMapping = new IdentityMatchingPipelineConfig_PropertyMapping$Type();
