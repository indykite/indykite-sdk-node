// @generated by protobuf-ts 2.9.0 with parameter long_type_string,client_grpc1,generate_dependencies
// @generated from protobuf file "indykite/config/v1beta1/model.proto" (package "indykite.config.v1beta1", syntax proto3)
// tslint:disable
//
// Copyright (c) 2023 IndyKite
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Duration } from "../../../google/protobuf/duration";
import { PolicyBuilderConfig } from "./policy_builder";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { StringValue } from "../../../google/protobuf/wrappers";
/**
 * UniqueNameIdentifier is an alternative to Globally Unique ID generated by the server.
 *
 * This identifier combines the Globally Unique ID of the location where to look for the name
 * to find the object. It makes the object identification easier by the human readable name.
 *
 * @generated from protobuf message indykite.config.v1beta1.UniqueNameIdentifier
 */
export interface UniqueNameIdentifier {
    /**
     * @generated from protobuf field: string location = 1;
     */
    location: string;
    /**
     * Name is unique name of configuration object.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * Customer representing the Customer Node.
 *
 * @generated from protobuf message indykite.config.v1beta1.Customer
 */
export interface Customer {
    /**
     * Globally unique identifier.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Name is unique name of configuration object.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Human readable name of configuration.
     *
     * @generated from protobuf field: string display_name = 3;
     */
    displayName: string;
    /**
     * Description of the configuration.
     *
     * @generated from protobuf field: google.protobuf.StringValue description = 4;
     */
    description?: StringValue;
    /**
     * Output only. The time at which the configuration was created.
     *
     * @generated from protobuf field: google.protobuf.Timestamp create_time = 5;
     */
    createTime?: Timestamp;
    /**
     * Output only. The user/service id who created the configuration.
     *
     * @generated from protobuf field: string created_by = 10;
     */
    createdBy: string;
    /**
     * Output only. The time at which the configuration was last changed.
     *
     * This value is initially set to the `create_time` then increases monotonically with each change.
     *
     * @generated from protobuf field: google.protobuf.Timestamp update_time = 6;
     */
    updateTime?: Timestamp;
    /**
     * Output only. The user/service id who last changed the configuration.
     *
     * @generated from protobuf field: string updated_by = 11;
     */
    updatedBy: string;
    /**
     * Output only. The time this configuration was destroyed.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp destroy_time = 7;
     */
    destroyTime?: Timestamp;
    /**
     * Output only. The time this configuration will be entirely deleted.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp delete_time = 8;
     */
    deleteTime?: Timestamp;
    /**
     * Output only. Multiversion concurrency control version.
     *
     * @generated from protobuf field: string etag = 9;
     */
    etag: string;
}
/**
 * ApplicationSpace representing the Application Space Node.
 *
 * @generated from protobuf message indykite.config.v1beta1.ApplicationSpace
 */
export interface ApplicationSpace {
    /**
     * Globally unique identifier.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Name is unique name of configuration object.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Human readable name of configuration.
     *
     * @generated from protobuf field: string display_name = 3;
     */
    displayName: string;
    /**
     * Description of the configuration.
     *
     * @generated from protobuf field: google.protobuf.StringValue description = 4;
     */
    description?: StringValue;
    /**
     * Output only. The time at which the configuration was created.
     *
     * @generated from protobuf field: google.protobuf.Timestamp create_time = 5;
     */
    createTime?: Timestamp;
    /**
     * Output only. The user/service id who created the configuration.
     *
     * @generated from protobuf field: string created_by = 12;
     */
    createdBy: string;
    /**
     * Output only. The time at which the configuration was last changed.
     *
     * This value is initially set to the `create_time` then increases monotonically with each change.
     *
     * @generated from protobuf field: google.protobuf.Timestamp update_time = 6;
     */
    updateTime?: Timestamp;
    /**
     * Output only. The user/service id who last changed the configuration.
     *
     * @generated from protobuf field: string updated_by = 13;
     */
    updatedBy: string;
    /**
     * Output only. The time this configuration was destroyed.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp destroy_time = 7;
     */
    destroyTime?: Timestamp;
    /**
     * Output only. The time this configuration will be entirely deleted.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp delete_time = 8;
     */
    deleteTime?: Timestamp;
    /**
     * Output only. Multiversion concurrency control version.
     *
     * @generated from protobuf field: string etag = 9;
     */
    etag: string;
    /**
     * CustomerId this object is directly connected to.
     *
     * @generated from protobuf field: string customer_id = 10;
     */
    customerId: string;
    /**
     * Read only. Status of the ikg db instance behind the Application Space.
     *
     * @generated from protobuf field: indykite.config.v1beta1.AppSpaceIKGStatus ikg_status = 14;
     */
    ikgStatus: AppSpaceIKGStatus;
    /**
     * @generated from protobuf field: string region = 15;
     */
    region: string;
}
/**
 * Application represents the customer application.
 *
 * @generated from protobuf message indykite.config.v1beta1.Application
 */
export interface Application {
    /**
     * Globally unique identifier.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Name is unique name of configuration object.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Human readable name of configuration.
     *
     * @generated from protobuf field: string display_name = 3;
     */
    displayName: string;
    /**
     * Description of the configuration.
     *
     * @generated from protobuf field: google.protobuf.StringValue description = 4;
     */
    description?: StringValue;
    /**
     * Output only. The time at which the configuration was created.
     *
     * @generated from protobuf field: google.protobuf.Timestamp create_time = 5;
     */
    createTime?: Timestamp;
    /**
     * Output only. The user/service id who created the configuration.
     *
     * @generated from protobuf field: string created_by = 12;
     */
    createdBy: string;
    /**
     * Output only. The time at which the configuration was last changed.
     *
     * This value is initially set to the `create_time` then increases monotonically with each change.
     *
     * @generated from protobuf field: google.protobuf.Timestamp update_time = 6;
     */
    updateTime?: Timestamp;
    /**
     * Output only. The user/service id who last changed the configuration.
     *
     * @generated from protobuf field: string updated_by = 13;
     */
    updatedBy: string;
    /**
     * Output only. The time this configuration was destroyed.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp destroy_time = 7;
     */
    destroyTime?: Timestamp;
    /**
     * Output only. The time this configuration will be entirely deleted.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp delete_time = 8;
     */
    deleteTime?: Timestamp;
    /**
     * Output only. Multiversion concurrency control version.
     *
     * @generated from protobuf field: string etag = 9;
     */
    etag: string;
    /**
     * CustomerId this object is directly or indirectly connected to.
     *
     * @generated from protobuf field: string customer_id = 10;
     */
    customerId: string;
    /**
     * AppSpaceId this object is directly or indirectly connected to.
     *
     * @generated from protobuf field: string app_space_id = 11;
     */
    appSpaceId: string;
}
/**
 * @generated from protobuf message indykite.config.v1beta1.ApplicationAgent
 */
export interface ApplicationAgent {
    /**
     * Globally unique identifier.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Name is unique name of configuration object.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Human readable name of configuration.
     *
     * @generated from protobuf field: string display_name = 3;
     */
    displayName: string;
    /**
     * Description of the configuration.
     *
     * @generated from protobuf field: google.protobuf.StringValue description = 4;
     */
    description?: StringValue;
    /**
     * Output only. The time at which the configuration was created.
     *
     * @generated from protobuf field: google.protobuf.Timestamp create_time = 5;
     */
    createTime?: Timestamp;
    /**
     * Output only. The user/service id who created the configuration.
     *
     * @generated from protobuf field: string created_by = 13;
     */
    createdBy: string;
    /**
     * Output only. The time at which the configuration was last changed.
     *
     * This value is initially set to the `create_time` then increases monotonically with each change.
     *
     * @generated from protobuf field: google.protobuf.Timestamp update_time = 6;
     */
    updateTime?: Timestamp;
    /**
     * Output only. The user/service id who last changed the configuration.
     *
     * @generated from protobuf field: string updated_by = 14;
     */
    updatedBy: string;
    /**
     * Output only. The time this configuration was destroyed.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp destroy_time = 7;
     */
    destroyTime?: Timestamp;
    /**
     * Output only. The time this configuration will be entirely deleted.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp delete_time = 8;
     */
    deleteTime?: Timestamp;
    /**
     * Output only. Multiversion concurrency control version.
     *
     * @generated from protobuf field: string etag = 9;
     */
    etag: string;
    /**
     * CustomerId this object is directly or indirectly connected to.
     *
     * @generated from protobuf field: string customer_id = 10;
     */
    customerId: string;
    /**
     * AppSpaceId this object is directly or indirectly connected to.
     *
     * @generated from protobuf field: string app_space_id = 11;
     */
    appSpaceId: string;
    /**
     * ApplicationId this object is directly connected to.
     *
     * @generated from protobuf field: string application_id = 12;
     */
    applicationId: string;
    /**
     * @generated from protobuf field: repeated string api_access_restriction = 15;
     */
    apiAccessRestriction: string[];
}
/**
 * @generated from protobuf message indykite.config.v1beta1.ApplicationAgentCredential
 */
export interface ApplicationAgentCredential {
    /**
     * Globally unique identifier.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Kid is public key ID
     *
     * @generated from protobuf field: string kid = 2;
     */
    kid: string;
    /**
     * Human readable name of configuration.
     *
     * @generated from protobuf field: string display_name = 3;
     */
    displayName: string;
    /**
     * Output only. The time at which the configuration was created.
     *
     * @generated from protobuf field: google.protobuf.Timestamp create_time = 5;
     */
    createTime?: Timestamp;
    /**
     * Output only. The user/service id who created the configuration.
     *
     * @generated from protobuf field: string created_by = 6;
     */
    createdBy: string;
    /**
     * Output only. The time this configuration was destroyed.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp destroy_time = 7;
     */
    destroyTime?: Timestamp;
    /**
     * Output only. The time this configuration will be entirely deleted.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp delete_time = 8;
     */
    deleteTime?: Timestamp;
    /**
     * CustomerId this object is directly or indirectly connected to.
     *
     * @generated from protobuf field: string customer_id = 10;
     */
    customerId: string;
    /**
     * AppSpaceId this object is directly or indirectly connected to.
     *
     * @generated from protobuf field: string app_space_id = 11;
     */
    appSpaceId: string;
    /**
     * ApplicationId this object is directly connected to.
     *
     * @generated from protobuf field: string application_id = 12;
     */
    applicationId: string;
    /**
     * ApplicationAgentId this object is directly connected to.
     *
     * @generated from protobuf field: string application_agent_id = 9;
     */
    applicationAgentId: string;
}
/**
 * @generated from protobuf message indykite.config.v1beta1.ServiceAccount
 */
export interface ServiceAccount {
    /**
     * Globally unique identifier.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Name is unique name of configuration object.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Human readable name of configuration.
     *
     * @generated from protobuf field: string display_name = 3;
     */
    displayName: string;
    /**
     * Description of the configuration.
     *
     * @generated from protobuf field: google.protobuf.StringValue description = 4;
     */
    description?: StringValue;
    /**
     * Output only. The time at which the configuration was created.
     *
     * @generated from protobuf field: google.protobuf.Timestamp create_time = 5;
     */
    createTime?: Timestamp;
    /**
     * Output only. The user/service id who created the configuration.
     *
     * @generated from protobuf field: string created_by = 12;
     */
    createdBy: string;
    /**
     * Output only. The time at which the configuration was last changed.
     *
     * This value is initially set to the `create_time` then increases monotonically with each change.
     *
     * @generated from protobuf field: google.protobuf.Timestamp update_time = 6;
     */
    updateTime?: Timestamp;
    /**
     * Output only. The user/service id who last changed the configuration.
     *
     * @generated from protobuf field: string updated_by = 13;
     */
    updatedBy: string;
    /**
     * Output only. The time this configuration was destroyed.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp destroy_time = 7;
     */
    destroyTime?: Timestamp;
    /**
     * Output only. The time this configuration will be entirely deleted.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp delete_time = 8;
     */
    deleteTime?: Timestamp;
    /**
     * Output only. Multiversion concurrency control version.
     *
     * @generated from protobuf field: string etag = 9;
     */
    etag: string;
    /**
     * CustomerId this object is directly or indirectly connected to.
     *
     * @generated from protobuf field: string customer_id = 10;
     */
    customerId: string;
    /**
     * AppSpaceId this object is directly connected to, might be empty if ServiceAccount is linked directly to Customer.
     *
     * @generated from protobuf field: string app_space_id = 11;
     */
    appSpaceId: string;
}
/**
 * @generated from protobuf message indykite.config.v1beta1.ServiceAccountCredential
 */
export interface ServiceAccountCredential {
    /**
     * Globally unique identifier.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Kid is public key ID
     *
     * @generated from protobuf field: string kid = 2;
     */
    kid: string;
    /**
     * Human readable name of configuration.
     *
     * @generated from protobuf field: string display_name = 3;
     */
    displayName: string;
    /**
     * Output only. The time at which the configuration was created.
     *
     * @generated from protobuf field: google.protobuf.Timestamp create_time = 5;
     */
    createTime?: Timestamp;
    /**
     * Output only. The user/service id who created the configuration.
     *
     * @generated from protobuf field: string created_by = 13;
     */
    createdBy: string;
    /**
     * Output only. The time this configuration was destroyed.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp destroy_time = 7;
     */
    destroyTime?: Timestamp;
    /**
     * Output only. The time this configuration will be entirely deleted.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp delete_time = 8;
     */
    deleteTime?: Timestamp;
    /**
     * CustomerId this object is indirectly connected to.
     *
     * @generated from protobuf field: string customer_id = 10;
     */
    customerId: string;
    /**
     * AppSpaceId this object is indirectly connected to.
     *
     * @generated from protobuf field: string app_space_id = 11;
     */
    appSpaceId: string;
    /**
     * ServiceAccountId this object is directly connected to.
     *
     * @generated from protobuf field: string service_account_id = 12;
     */
    serviceAccountId: string;
}
/**
 * @generated from protobuf message indykite.config.v1beta1.ConfigNode
 */
export interface ConfigNode {
    /**
     * Globally unique identifier.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Name is unique name of configuration object.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Human readable name of configuration.
     *
     * @generated from protobuf field: string display_name = 3;
     */
    displayName: string;
    /**
     * Description of the configuration.
     *
     * @generated from protobuf field: google.protobuf.StringValue description = 4;
     */
    description?: StringValue;
    /**
     * Output only. The time at which the configuration was created.
     *
     * @generated from protobuf field: google.protobuf.Timestamp create_time = 5;
     */
    createTime?: Timestamp;
    /**
     * Output only. The time at which the configuration was last changed.
     *
     * This value is initially set to the `create_time` then increases monotonically with each change.
     *
     * @generated from protobuf field: google.protobuf.Timestamp update_time = 6;
     */
    updateTime?: Timestamp;
    /**
     * Output only. The user/service id who created the configuration.
     *
     * @generated from protobuf field: string created_by = 26;
     */
    createdBy: string;
    /**
     * Output only. The user/service id who last changed the configuration.
     *
     * @generated from protobuf field: string updated_by = 27;
     */
    updatedBy: string;
    /**
     * Output only. The time this configuration was destroyed.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp destroy_time = 7;
     */
    destroyTime?: Timestamp;
    /**
     * Output only. The time this configuration will be entirely deleted.
     *
     * Only present if deletion of object was requested.
     *
     * @generated from protobuf field: google.protobuf.Timestamp delete_time = 8;
     */
    deleteTime?: Timestamp;
    /**
     * Output only. Multiversion concurrency control version.
     *
     * @generated from protobuf field: string etag = 9;
     */
    etag: string;
    /**
     * CustomerId this object is directly or indirectly connected to.
     *
     * @generated from protobuf field: string customer_id = 10;
     */
    customerId: string;
    /**
     * AppSpaceId this object is directly or indirectly connected to.
     *
     * @generated from protobuf field: string app_space_id = 11;
     */
    appSpaceId: string;
    /**
     * @generated from protobuf oneof: config
     */
    config: {
        oneofKind: "auditSinkConfig";
        /**
         * @generated from protobuf field: indykite.config.v1beta1.AuditSinkConfig audit_sink_config = 28;
         */
        auditSinkConfig: AuditSinkConfig;
    } | {
        oneofKind: "authorizationPolicyConfig";
        /**
         * @generated from protobuf field: indykite.config.v1beta1.AuthorizationPolicyConfig authorization_policy_config = 23;
         */
        authorizationPolicyConfig: AuthorizationPolicyConfig;
    } | {
        oneofKind: "consentConfig";
        /**
         * @generated from protobuf field: indykite.config.v1beta1.ConsentConfiguration consent_config = 30;
         */
        consentConfig: ConsentConfiguration;
    } | {
        oneofKind: "tokenIntrospectConfig";
        /**
         * @generated from protobuf field: indykite.config.v1beta1.TokenIntrospectConfig token_introspect_config = 31;
         */
        tokenIntrospectConfig: TokenIntrospectConfig;
    } | {
        oneofKind: "ingestPipelineConfig";
        /**
         * @generated from protobuf field: indykite.config.v1beta1.IngestPipelineConfig ingest_pipeline_config = 32;
         */
        ingestPipelineConfig: IngestPipelineConfig;
    } | {
        oneofKind: undefined;
    };
    /**
     * Optional. If document is versioned, can be set to a specific document version
     *
     * @generated from protobuf field: int64 version = 29;
     */
    version: string;
}
/**
 * @generated from protobuf message indykite.config.v1beta1.AuthorizationPolicyConfig
 */
export interface AuthorizationPolicyConfig {
    /**
     * Policy in JSON string format.
     *
     * @generated from protobuf field: string policy = 1;
     */
    policy: string; // 0.5Mb
    /**
     * Policy status.
     *
     * @generated from protobuf field: indykite.config.v1beta1.AuthorizationPolicyConfig.Status status = 2;
     */
    status: AuthorizationPolicyConfig_Status;
    /**
     * Optional policy tags
     *
     * @generated from protobuf field: repeated string tags = 3;
     */
    tags: string[];
    /**
     * Optional policy builder config
     *
     * @generated from protobuf field: indykite.config.v1beta1.PolicyBuilderConfig builder = 4;
     */
    builder?: PolicyBuilderConfig;
}
/**
 * @generated from protobuf enum indykite.config.v1beta1.AuthorizationPolicyConfig.Status
 */
export enum AuthorizationPolicyConfig_Status {
    /**
     * @generated from protobuf enum value: STATUS_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: STATUS_ACTIVE = 1;
     */
    ACTIVE = 1,
    /**
     * @generated from protobuf enum value: STATUS_INACTIVE = 2;
     */
    INACTIVE = 2,
    /**
     * @generated from protobuf enum value: STATUS_DRAFT = 3;
     */
    DRAFT = 3
}
/**
 * @generated from protobuf message indykite.config.v1beta1.AuditSinkConfig
 */
export interface AuditSinkConfig {
    /**
     * @generated from protobuf oneof: provider
     */
    provider: {
        oneofKind: "kafka";
        /**
         * @generated from protobuf field: indykite.config.v1beta1.KafkaSinkConfig kafka = 1;
         */
        kafka: KafkaSinkConfig;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message indykite.config.v1beta1.KafkaSinkConfig
 */
export interface KafkaSinkConfig {
    /**
     * Brokers specify Kafka destinations to connect to.
     *
     * @generated from protobuf field: repeated string brokers = 1;
     */
    brokers: string[];
    /**
     * Topic name must be valid based on source code:
     * https://github.com/apache/kafka/blob/0.10.2/core/src/main/scala/kafka/common/Topic.scala#L29-L30
     *
     * @generated from protobuf field: string topic = 2;
     */
    topic: string;
    /**
     * DisableTLS can force using non-secure connection.
     *
     * @generated from protobuf field: bool disable_tls = 3;
     */
    disableTls: boolean;
    /**
     * TLSSkipVerify defines whenever not to verify TLS certificate. Ignored if TLS is disabled.
     *
     * @generated from protobuf field: bool tls_skip_verify = 4;
     */
    tlsSkipVerify: boolean;
    /**
     * @generated from protobuf field: string username = 5;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 6;
     */
    password: string;
}
/**
 * @generated from protobuf message indykite.config.v1beta1.ConsentConfiguration
 */
export interface ConsentConfiguration {
    /**
     * Purpose is a human readable description of the purpose of the consent.
     *
     * @generated from protobuf field: string purpose = 1;
     */
    purpose: string;
    /**
     * Data points is a list of properties related to the Digital twin that the consent is for.
     *
     * @generated from protobuf field: repeated string data_points = 2;
     */
    dataPoints: string[];
    /**
     * First iteration the Application is embedded in the config, but that won't be the case in the future
     * ApplicationId is the id of the application that the consent is for.
     *
     * @generated from protobuf field: string application_id = 3;
     */
    applicationId: string;
    /**
     * ValidityPeriod is the time in seconds that the consent is valid for.
     * The minimum value is 1 day and the maximum value is 2 years.
     *
     * @generated from protobuf field: uint64 validity_period = 4;
     */
    validityPeriod: string;
    /**
     * Revoke after use is a boolean that determines if the consent should be revoked after it has been used.
     *
     * @generated from protobuf field: bool revoke_after_use = 5;
     */
    revokeAfterUse: boolean;
    /**
     * @generated from protobuf field: indykite.config.v1beta1.ExternalTokenStatus token_status = 7;
     */
    tokenStatus: ExternalTokenStatus;
}
/**
 * Token Introspect configuration for AppSpace.
 *
 * @generated from protobuf message indykite.config.v1beta1.TokenIntrospectConfig
 */
export interface TokenIntrospectConfig {
    /**
     * @generated from protobuf oneof: token_matcher
     */
    tokenMatcher: {
        oneofKind: "jwt";
        /**
         * @generated from protobuf field: indykite.config.v1beta1.TokenIntrospectConfig.JWT jwt = 1;
         */
        jwt: TokenIntrospectConfig_JWT;
    } | {
        oneofKind: "opaque";
        /**
         * @generated from protobuf field: indykite.config.v1beta1.TokenIntrospectConfig.Opaque opaque = 2;
         */
        opaque: TokenIntrospectConfig_Opaque;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: validation
     */
    validation: {
        oneofKind: "offline";
        /**
         * @generated from protobuf field: indykite.config.v1beta1.TokenIntrospectConfig.Offline offline = 3;
         */
        offline: TokenIntrospectConfig_Offline;
    } | {
        oneofKind: "online";
        /**
         * @generated from protobuf field: indykite.config.v1beta1.TokenIntrospectConfig.Online online = 4;
         */
        online: TokenIntrospectConfig_Online;
    } | {
        oneofKind: undefined;
    };
    /**
     * ClaimsMapping specify which claims from the token should be mapped to IKG Property with given name.
     * Remember, that 'email' claim is always extracted if exists and stored under 'email' key in IKG.
     *
     * Key specify name of property in IKG.
     * Value specify which claim to map and how.
     *
     * @generated from protobuf field: map<string, indykite.config.v1beta1.TokenIntrospectConfig.Claim> claims_mapping = 7;
     */
    claimsMapping: {
        [key: string]: TokenIntrospectConfig_Claim;
    };
    /**
     * Node type in IKG to which we will try to match sub claim with DT external_id.
     *
     * @generated from protobuf field: string ikg_node_type = 5;
     */
    ikgNodeType: string;
    /**
     * Perform Upsert specify, if we should create and/or update DigitalTwin in IKG if it doesn't exist with.
     * In future this will perform upsert also on properties that are derived from token.
     *
     * @generated from protobuf field: bool perform_upsert = 6;
     */
    performUpsert: boolean;
}
/**
 * JWT specifies all attributes to match with received token.
 *
 * @generated from protobuf message indykite.config.v1beta1.TokenIntrospectConfig.JWT
 */
export interface TokenIntrospectConfig_JWT {
    /**
     * Issuer is used to exact match based on `iss` claim in JWT.
     *
     * @generated from protobuf field: string issuer = 1;
     */
    issuer: string;
    /**
     * Audience is used to exact match based on `aud` claim in JWT.
     *
     * @generated from protobuf field: string audience = 2;
     */
    audience: string;
}
/**
 * Opaque specifies the configuration is for opaque tokens.
 * Currently we will support max 1 opaque token configuration per app space.
 *
 * @generated from protobuf message indykite.config.v1beta1.TokenIntrospectConfig.Opaque
 */
export interface TokenIntrospectConfig_Opaque {
}
/**
 * Offline validation works only with JWT.
 *
 * @generated from protobuf message indykite.config.v1beta1.TokenIntrospectConfig.Offline
 */
export interface TokenIntrospectConfig_Offline {
    /**
     * Public JWK to validate signature of JWT.
     * If there are no public keys specified, they will be fetched and cached from
     * jwks_uri at https://jwt-issuer.tld/.well-known/openid-configuration
     *
     * @generated from protobuf field: repeated bytes public_jwks = 1;
     */
    publicJwks: Uint8Array[];
}
/**
 * Online validation works with both JWT and Opaque tokens.
 * It will call userinfo endpoint to validate token and fetch user claims.
 *
 * @generated from protobuf message indykite.config.v1beta1.TokenIntrospectConfig.Online
 */
export interface TokenIntrospectConfig_Online {
    /**
     * URI of userinfo endpoint which will be used to validate access token.
     * And also fetch user claims when opaque token is received.
     *
     * It can remain empty, if JWT token matcher is used.
     * Then the URI under "userinfo_endpoint" in .well-known/openid-configuration endpoint is used.
     *
     * @generated from protobuf field: string userinfo_endpoint = 1;
     */
    userinfoEndpoint: string;
    /**
     * Cache TTL of token validity can be used to minimize calls to userinfo endpoint.
     * The final cache TTL will be set to lower limit of this value and exp claim of JWT token.
     * If not set, token will not be cached and call to userinfo endpoint will be made on every request.
     *
     * However, token validity will be checked first if possible (JWT tokens).
     * If token is expired, userinfo endpoint will not be called, nor cache checked.
     *
     * @generated from protobuf field: google.protobuf.Duration cache_ttl = 2;
     */
    cacheTtl?: Duration;
}
/**
 * Claim specify details about claim that will be mapped to IKG.
 *
 * @generated from protobuf message indykite.config.v1beta1.TokenIntrospectConfig.Claim
 */
export interface TokenIntrospectConfig_Claim {
    /**
     * JSON selector of property in token claims. Currently just name in top-level object is supported.
     *
     * By default we support all standard claims from OpenID specification https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims,
     * and mapping will fail if claim and data type will not match the standard.
     *
     * For non-standard claims the type will be derived from the JSON.
     *
     * @generated from protobuf field: string selector = 1;
     */
    selector: string;
}
/**
 * @generated from protobuf message indykite.config.v1beta1.ConsentDataPoint
 */
export interface ConsentDataPoint {
    /**
     * @generated from protobuf field: string query = 1;
     */
    query: string;
    /**
     * @generated from protobuf field: repeated indykite.config.v1beta1.ConsentDataPoint.Return returns = 2;
     */
    returns: ConsentDataPoint_Return[];
}
/**
 * @generated from protobuf message indykite.config.v1beta1.ConsentDataPoint.Return
 */
export interface ConsentDataPoint_Return {
    /**
     * @generated from protobuf field: string variable = 1;
     */
    variable: string;
    /**
     * @generated from protobuf field: repeated string properties = 2;
     */
    properties: string[];
}
/**
 * @generated from protobuf message indykite.config.v1beta1.IngestPipelineConfig
 */
export interface IngestPipelineConfig {
    /**
     * @generated from protobuf field: repeated string sources = 1;
     */
    sources: string[];
    /**
     * @generated from protobuf field: repeated indykite.config.v1beta1.IngestPipelineOperation operations = 2;
     */
    operations: IngestPipelineOperation[];
    /**
     * @generated from protobuf field: string app_agent_token = 3;
     */
    appAgentToken: string;
}
/**
 * @generated from protobuf enum indykite.config.v1beta1.AppSpaceIKGStatus
 */
export enum AppSpaceIKGStatus {
    /**
     * @generated from protobuf enum value: APP_SPACE_IKG_STATUS_STATUS_INVALID = 0;
     */
    APP_SPACE_IKG_STATUS_STATUS_INVALID = 0,
    /**
     * @generated from protobuf enum value: APP_SPACE_IKG_STATUS_STATUS_PENDING = 1;
     */
    APP_SPACE_IKG_STATUS_STATUS_PENDING = 1,
    /**
     * @generated from protobuf enum value: APP_SPACE_IKG_STATUS_STATUS_ACTIVE = 2;
     */
    APP_SPACE_IKG_STATUS_STATUS_ACTIVE = 2,
    /**
     * @generated from protobuf enum value: APP_SPACE_IKG_STATUS_STATUS_FAILED = 3;
     */
    APP_SPACE_IKG_STATUS_STATUS_FAILED = 3,
    /**
     * @generated from protobuf enum value: APP_SPACE_IKG_STATUS_STATUS_PAUSED = 4;
     */
    APP_SPACE_IKG_STATUS_STATUS_PAUSED = 4
}
/**
 * @generated from protobuf enum indykite.config.v1beta1.ExternalTokenStatus
 */
export enum ExternalTokenStatus {
    /**
     * @generated from protobuf enum value: EXTERNAL_TOKEN_STATUS_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: EXTERNAL_TOKEN_STATUS_ENFORCE = 1;
     */
    ENFORCE = 1,
    /**
     * @generated from protobuf enum value: EXTERNAL_TOKEN_STATUS_ALLOW = 2;
     */
    ALLOW = 2,
    /**
     * @generated from protobuf enum value: EXTERNAL_TOKEN_STATUS_DISALLOW = 3;
     */
    DISALLOW = 3
}
/**
 * @generated from protobuf enum indykite.config.v1beta1.IngestPipelineOperation
 */
export enum IngestPipelineOperation {
    /**
     * @generated from protobuf enum value: INGEST_PIPELINE_OPERATION_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: INGEST_PIPELINE_OPERATION_UPSERT_NODE = 1;
     */
    UPSERT_NODE = 1,
    /**
     * @generated from protobuf enum value: INGEST_PIPELINE_OPERATION_UPSERT_RELATIONSHIP = 2;
     */
    UPSERT_RELATIONSHIP = 2,
    /**
     * @generated from protobuf enum value: INGEST_PIPELINE_OPERATION_DELETE_NODE = 3;
     */
    DELETE_NODE = 3,
    /**
     * @generated from protobuf enum value: INGEST_PIPELINE_OPERATION_DELETE_RELATIONSHIP = 4;
     */
    DELETE_RELATIONSHIP = 4,
    /**
     * @generated from protobuf enum value: INGEST_PIPELINE_OPERATION_DELETE_NODE_PROPERTY = 5;
     */
    DELETE_NODE_PROPERTY = 5,
    /**
     * @generated from protobuf enum value: INGEST_PIPELINE_OPERATION_DELETE_RELATIONSHIP_PROPERTY = 6;
     */
    DELETE_RELATIONSHIP_PROPERTY = 6
}
// @generated message type with reflection information, may provide speed optimized methods
class UniqueNameIdentifier$Type extends MessageType<UniqueNameIdentifier> {
    constructor() {
        super("indykite.config.v1beta1.UniqueNameIdentifier", [
            { no: 1, name: "location", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "63", pattern: "^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$" } } } }
        ]);
    }
    create(value?: PartialMessage<UniqueNameIdentifier>): UniqueNameIdentifier {
        const message = { location: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UniqueNameIdentifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UniqueNameIdentifier): UniqueNameIdentifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string location */ 1:
                    message.location = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UniqueNameIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string location = 1; */
        if (message.location !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.location);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.UniqueNameIdentifier
 */
export const UniqueNameIdentifier = new UniqueNameIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Customer$Type extends MessageType<Customer> {
    constructor() {
        super("indykite.config.v1beta1.Customer", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "63", pattern: "^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$" } } } },
            { no: 3, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "254" } } } },
            { no: 4, name: "description", kind: "message", T: () => StringValue, options: { "validate.rules": { string: { minLen: "2", maxLen: "254" } } } },
            { no: 5, name: "create_time", kind: "message", T: () => Timestamp },
            { no: 10, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "update_time", kind: "message", T: () => Timestamp },
            { no: 11, name: "updated_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "destroy_time", kind: "message", T: () => Timestamp },
            { no: 8, name: "delete_time", kind: "message", T: () => Timestamp },
            { no: 9, name: "etag", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Customer>): Customer {
        const message = { id: "", name: "", displayName: "", createdBy: "", updatedBy: "", etag: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Customer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Customer): Customer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string display_name */ 3:
                    message.displayName = reader.string();
                    break;
                case /* google.protobuf.StringValue description */ 4:
                    message.description = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.description);
                    break;
                case /* google.protobuf.Timestamp create_time */ 5:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* string created_by */ 10:
                    message.createdBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp update_time */ 6:
                    message.updateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                case /* string updated_by */ 11:
                    message.updatedBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp destroy_time */ 7:
                    message.destroyTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.destroyTime);
                    break;
                case /* google.protobuf.Timestamp delete_time */ 8:
                    message.deleteTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deleteTime);
                    break;
                case /* string etag */ 9:
                    message.etag = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Customer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string display_name = 3; */
        if (message.displayName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        /* google.protobuf.StringValue description = 4; */
        if (message.description)
            StringValue.internalBinaryWrite(message.description, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp create_time = 5; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string created_by = 10; */
        if (message.createdBy !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.createdBy);
        /* google.protobuf.Timestamp update_time = 6; */
        if (message.updateTime)
            Timestamp.internalBinaryWrite(message.updateTime, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string updated_by = 11; */
        if (message.updatedBy !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.updatedBy);
        /* google.protobuf.Timestamp destroy_time = 7; */
        if (message.destroyTime)
            Timestamp.internalBinaryWrite(message.destroyTime, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp delete_time = 8; */
        if (message.deleteTime)
            Timestamp.internalBinaryWrite(message.deleteTime, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string etag = 9; */
        if (message.etag !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.etag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.Customer
 */
export const Customer = new Customer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplicationSpace$Type extends MessageType<ApplicationSpace> {
    constructor() {
        super("indykite.config.v1beta1.ApplicationSpace", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "63", pattern: "^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$" } } } },
            { no: 3, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "254" } } } },
            { no: 4, name: "description", kind: "message", T: () => StringValue, options: { "validate.rules": { string: { minLen: "2", maxLen: "254" } } } },
            { no: 5, name: "create_time", kind: "message", T: () => Timestamp },
            { no: 12, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "update_time", kind: "message", T: () => Timestamp },
            { no: 13, name: "updated_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "destroy_time", kind: "message", T: () => Timestamp },
            { no: 8, name: "delete_time", kind: "message", T: () => Timestamp },
            { no: 9, name: "etag", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 14, name: "ikg_status", kind: "enum", T: () => ["indykite.config.v1beta1.AppSpaceIKGStatus", AppSpaceIKGStatus] },
            { no: 15, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ApplicationSpace>): ApplicationSpace {
        const message = { id: "", name: "", displayName: "", createdBy: "", updatedBy: "", etag: "", customerId: "", ikgStatus: 0, region: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ApplicationSpace>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplicationSpace): ApplicationSpace {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string display_name */ 3:
                    message.displayName = reader.string();
                    break;
                case /* google.protobuf.StringValue description */ 4:
                    message.description = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.description);
                    break;
                case /* google.protobuf.Timestamp create_time */ 5:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* string created_by */ 12:
                    message.createdBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp update_time */ 6:
                    message.updateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                case /* string updated_by */ 13:
                    message.updatedBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp destroy_time */ 7:
                    message.destroyTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.destroyTime);
                    break;
                case /* google.protobuf.Timestamp delete_time */ 8:
                    message.deleteTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deleteTime);
                    break;
                case /* string etag */ 9:
                    message.etag = reader.string();
                    break;
                case /* string customer_id */ 10:
                    message.customerId = reader.string();
                    break;
                case /* indykite.config.v1beta1.AppSpaceIKGStatus ikg_status */ 14:
                    message.ikgStatus = reader.int32();
                    break;
                case /* string region */ 15:
                    message.region = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplicationSpace, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string display_name = 3; */
        if (message.displayName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        /* google.protobuf.StringValue description = 4; */
        if (message.description)
            StringValue.internalBinaryWrite(message.description, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp create_time = 5; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string created_by = 12; */
        if (message.createdBy !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.createdBy);
        /* google.protobuf.Timestamp update_time = 6; */
        if (message.updateTime)
            Timestamp.internalBinaryWrite(message.updateTime, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string updated_by = 13; */
        if (message.updatedBy !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.updatedBy);
        /* google.protobuf.Timestamp destroy_time = 7; */
        if (message.destroyTime)
            Timestamp.internalBinaryWrite(message.destroyTime, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp delete_time = 8; */
        if (message.deleteTime)
            Timestamp.internalBinaryWrite(message.deleteTime, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string etag = 9; */
        if (message.etag !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.etag);
        /* string customer_id = 10; */
        if (message.customerId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.customerId);
        /* indykite.config.v1beta1.AppSpaceIKGStatus ikg_status = 14; */
        if (message.ikgStatus !== 0)
            writer.tag(14, WireType.Varint).int32(message.ikgStatus);
        /* string region = 15; */
        if (message.region !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.region);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.ApplicationSpace
 */
export const ApplicationSpace = new ApplicationSpace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Application$Type extends MessageType<Application> {
    constructor() {
        super("indykite.config.v1beta1.Application", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "63", pattern: "^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$" } } } },
            { no: 3, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "254" } } } },
            { no: 4, name: "description", kind: "message", T: () => StringValue, options: { "validate.rules": { string: { minLen: "2", maxLen: "254" } } } },
            { no: 5, name: "create_time", kind: "message", T: () => Timestamp },
            { no: 12, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "update_time", kind: "message", T: () => Timestamp },
            { no: 13, name: "updated_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "destroy_time", kind: "message", T: () => Timestamp },
            { no: 8, name: "delete_time", kind: "message", T: () => Timestamp },
            { no: 9, name: "etag", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 11, name: "app_space_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } }
        ]);
    }
    create(value?: PartialMessage<Application>): Application {
        const message = { id: "", name: "", displayName: "", createdBy: "", updatedBy: "", etag: "", customerId: "", appSpaceId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Application>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Application): Application {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string display_name */ 3:
                    message.displayName = reader.string();
                    break;
                case /* google.protobuf.StringValue description */ 4:
                    message.description = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.description);
                    break;
                case /* google.protobuf.Timestamp create_time */ 5:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* string created_by */ 12:
                    message.createdBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp update_time */ 6:
                    message.updateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                case /* string updated_by */ 13:
                    message.updatedBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp destroy_time */ 7:
                    message.destroyTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.destroyTime);
                    break;
                case /* google.protobuf.Timestamp delete_time */ 8:
                    message.deleteTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deleteTime);
                    break;
                case /* string etag */ 9:
                    message.etag = reader.string();
                    break;
                case /* string customer_id */ 10:
                    message.customerId = reader.string();
                    break;
                case /* string app_space_id */ 11:
                    message.appSpaceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Application, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string display_name = 3; */
        if (message.displayName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        /* google.protobuf.StringValue description = 4; */
        if (message.description)
            StringValue.internalBinaryWrite(message.description, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp create_time = 5; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string created_by = 12; */
        if (message.createdBy !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.createdBy);
        /* google.protobuf.Timestamp update_time = 6; */
        if (message.updateTime)
            Timestamp.internalBinaryWrite(message.updateTime, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string updated_by = 13; */
        if (message.updatedBy !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.updatedBy);
        /* google.protobuf.Timestamp destroy_time = 7; */
        if (message.destroyTime)
            Timestamp.internalBinaryWrite(message.destroyTime, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp delete_time = 8; */
        if (message.deleteTime)
            Timestamp.internalBinaryWrite(message.deleteTime, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string etag = 9; */
        if (message.etag !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.etag);
        /* string customer_id = 10; */
        if (message.customerId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.customerId);
        /* string app_space_id = 11; */
        if (message.appSpaceId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.appSpaceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.Application
 */
export const Application = new Application$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplicationAgent$Type extends MessageType<ApplicationAgent> {
    constructor() {
        super("indykite.config.v1beta1.ApplicationAgent", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "63", pattern: "^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$" } } } },
            { no: 3, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "254" } } } },
            { no: 4, name: "description", kind: "message", T: () => StringValue, options: { "validate.rules": { string: { minLen: "2", maxLen: "254" } } } },
            { no: 5, name: "create_time", kind: "message", T: () => Timestamp },
            { no: 13, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "update_time", kind: "message", T: () => Timestamp },
            { no: 14, name: "updated_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "destroy_time", kind: "message", T: () => Timestamp },
            { no: 8, name: "delete_time", kind: "message", T: () => Timestamp },
            { no: 9, name: "etag", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 11, name: "app_space_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 12, name: "application_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 15, name: "api_access_restriction", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ApplicationAgent>): ApplicationAgent {
        const message = { id: "", name: "", displayName: "", createdBy: "", updatedBy: "", etag: "", customerId: "", appSpaceId: "", applicationId: "", apiAccessRestriction: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ApplicationAgent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplicationAgent): ApplicationAgent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string display_name */ 3:
                    message.displayName = reader.string();
                    break;
                case /* google.protobuf.StringValue description */ 4:
                    message.description = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.description);
                    break;
                case /* google.protobuf.Timestamp create_time */ 5:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* string created_by */ 13:
                    message.createdBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp update_time */ 6:
                    message.updateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                case /* string updated_by */ 14:
                    message.updatedBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp destroy_time */ 7:
                    message.destroyTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.destroyTime);
                    break;
                case /* google.protobuf.Timestamp delete_time */ 8:
                    message.deleteTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deleteTime);
                    break;
                case /* string etag */ 9:
                    message.etag = reader.string();
                    break;
                case /* string customer_id */ 10:
                    message.customerId = reader.string();
                    break;
                case /* string app_space_id */ 11:
                    message.appSpaceId = reader.string();
                    break;
                case /* string application_id */ 12:
                    message.applicationId = reader.string();
                    break;
                case /* repeated string api_access_restriction */ 15:
                    message.apiAccessRestriction.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplicationAgent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string display_name = 3; */
        if (message.displayName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        /* google.protobuf.StringValue description = 4; */
        if (message.description)
            StringValue.internalBinaryWrite(message.description, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp create_time = 5; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string created_by = 13; */
        if (message.createdBy !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.createdBy);
        /* google.protobuf.Timestamp update_time = 6; */
        if (message.updateTime)
            Timestamp.internalBinaryWrite(message.updateTime, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string updated_by = 14; */
        if (message.updatedBy !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.updatedBy);
        /* google.protobuf.Timestamp destroy_time = 7; */
        if (message.destroyTime)
            Timestamp.internalBinaryWrite(message.destroyTime, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp delete_time = 8; */
        if (message.deleteTime)
            Timestamp.internalBinaryWrite(message.deleteTime, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string etag = 9; */
        if (message.etag !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.etag);
        /* string customer_id = 10; */
        if (message.customerId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.customerId);
        /* string app_space_id = 11; */
        if (message.appSpaceId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.appSpaceId);
        /* string application_id = 12; */
        if (message.applicationId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.applicationId);
        /* repeated string api_access_restriction = 15; */
        for (let i = 0; i < message.apiAccessRestriction.length; i++)
            writer.tag(15, WireType.LengthDelimited).string(message.apiAccessRestriction[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.ApplicationAgent
 */
export const ApplicationAgent = new ApplicationAgent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplicationAgentCredential$Type extends MessageType<ApplicationAgentCredential> {
    constructor() {
        super("indykite.config.v1beta1.ApplicationAgentCredential", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 2, name: "kid", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "41", maxLen: "45", pattern: "^[a-zA-Z0-9-_]+$" } } } },
            { no: 3, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "254" } } } },
            { no: 5, name: "create_time", kind: "message", T: () => Timestamp },
            { no: 6, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "destroy_time", kind: "message", T: () => Timestamp },
            { no: 8, name: "delete_time", kind: "message", T: () => Timestamp },
            { no: 10, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 11, name: "app_space_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 12, name: "application_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 9, name: "application_agent_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } }
        ]);
    }
    create(value?: PartialMessage<ApplicationAgentCredential>): ApplicationAgentCredential {
        const message = { id: "", kid: "", displayName: "", createdBy: "", customerId: "", appSpaceId: "", applicationId: "", applicationAgentId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ApplicationAgentCredential>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplicationAgentCredential): ApplicationAgentCredential {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string kid */ 2:
                    message.kid = reader.string();
                    break;
                case /* string display_name */ 3:
                    message.displayName = reader.string();
                    break;
                case /* google.protobuf.Timestamp create_time */ 5:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* string created_by */ 6:
                    message.createdBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp destroy_time */ 7:
                    message.destroyTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.destroyTime);
                    break;
                case /* google.protobuf.Timestamp delete_time */ 8:
                    message.deleteTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deleteTime);
                    break;
                case /* string customer_id */ 10:
                    message.customerId = reader.string();
                    break;
                case /* string app_space_id */ 11:
                    message.appSpaceId = reader.string();
                    break;
                case /* string application_id */ 12:
                    message.applicationId = reader.string();
                    break;
                case /* string application_agent_id */ 9:
                    message.applicationAgentId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplicationAgentCredential, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string kid = 2; */
        if (message.kid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kid);
        /* string display_name = 3; */
        if (message.displayName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        /* google.protobuf.Timestamp create_time = 5; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string created_by = 6; */
        if (message.createdBy !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.createdBy);
        /* google.protobuf.Timestamp destroy_time = 7; */
        if (message.destroyTime)
            Timestamp.internalBinaryWrite(message.destroyTime, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp delete_time = 8; */
        if (message.deleteTime)
            Timestamp.internalBinaryWrite(message.deleteTime, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string customer_id = 10; */
        if (message.customerId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.customerId);
        /* string app_space_id = 11; */
        if (message.appSpaceId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.appSpaceId);
        /* string application_id = 12; */
        if (message.applicationId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.applicationId);
        /* string application_agent_id = 9; */
        if (message.applicationAgentId !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.applicationAgentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.ApplicationAgentCredential
 */
export const ApplicationAgentCredential = new ApplicationAgentCredential$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceAccount$Type extends MessageType<ServiceAccount> {
    constructor() {
        super("indykite.config.v1beta1.ServiceAccount", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "63", pattern: "^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$" } } } },
            { no: 3, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "254" } } } },
            { no: 4, name: "description", kind: "message", T: () => StringValue, options: { "validate.rules": { string: { minLen: "2", maxLen: "254" } } } },
            { no: 5, name: "create_time", kind: "message", T: () => Timestamp },
            { no: 12, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "update_time", kind: "message", T: () => Timestamp },
            { no: 13, name: "updated_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "destroy_time", kind: "message", T: () => Timestamp },
            { no: 8, name: "delete_time", kind: "message", T: () => Timestamp },
            { no: 9, name: "etag", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 11, name: "app_space_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$", ignoreEmpty: true } } } }
        ]);
    }
    create(value?: PartialMessage<ServiceAccount>): ServiceAccount {
        const message = { id: "", name: "", displayName: "", createdBy: "", updatedBy: "", etag: "", customerId: "", appSpaceId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServiceAccount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceAccount): ServiceAccount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string display_name */ 3:
                    message.displayName = reader.string();
                    break;
                case /* google.protobuf.StringValue description */ 4:
                    message.description = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.description);
                    break;
                case /* google.protobuf.Timestamp create_time */ 5:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* string created_by */ 12:
                    message.createdBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp update_time */ 6:
                    message.updateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                case /* string updated_by */ 13:
                    message.updatedBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp destroy_time */ 7:
                    message.destroyTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.destroyTime);
                    break;
                case /* google.protobuf.Timestamp delete_time */ 8:
                    message.deleteTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deleteTime);
                    break;
                case /* string etag */ 9:
                    message.etag = reader.string();
                    break;
                case /* string customer_id */ 10:
                    message.customerId = reader.string();
                    break;
                case /* string app_space_id */ 11:
                    message.appSpaceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceAccount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string display_name = 3; */
        if (message.displayName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        /* google.protobuf.StringValue description = 4; */
        if (message.description)
            StringValue.internalBinaryWrite(message.description, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp create_time = 5; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string created_by = 12; */
        if (message.createdBy !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.createdBy);
        /* google.protobuf.Timestamp update_time = 6; */
        if (message.updateTime)
            Timestamp.internalBinaryWrite(message.updateTime, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string updated_by = 13; */
        if (message.updatedBy !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.updatedBy);
        /* google.protobuf.Timestamp destroy_time = 7; */
        if (message.destroyTime)
            Timestamp.internalBinaryWrite(message.destroyTime, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp delete_time = 8; */
        if (message.deleteTime)
            Timestamp.internalBinaryWrite(message.deleteTime, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string etag = 9; */
        if (message.etag !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.etag);
        /* string customer_id = 10; */
        if (message.customerId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.customerId);
        /* string app_space_id = 11; */
        if (message.appSpaceId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.appSpaceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.ServiceAccount
 */
export const ServiceAccount = new ServiceAccount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceAccountCredential$Type extends MessageType<ServiceAccountCredential> {
    constructor() {
        super("indykite.config.v1beta1.ServiceAccountCredential", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 2, name: "kid", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "41", maxLen: "45", pattern: "^[a-zA-Z0-9-_]+$" } } } },
            { no: 3, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "254" } } } },
            { no: 5, name: "create_time", kind: "message", T: () => Timestamp },
            { no: 13, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "destroy_time", kind: "message", T: () => Timestamp },
            { no: 8, name: "delete_time", kind: "message", T: () => Timestamp },
            { no: 10, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 11, name: "app_space_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$", ignoreEmpty: true } } } },
            { no: 12, name: "service_account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } }
        ]);
    }
    create(value?: PartialMessage<ServiceAccountCredential>): ServiceAccountCredential {
        const message = { id: "", kid: "", displayName: "", createdBy: "", customerId: "", appSpaceId: "", serviceAccountId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServiceAccountCredential>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceAccountCredential): ServiceAccountCredential {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string kid */ 2:
                    message.kid = reader.string();
                    break;
                case /* string display_name */ 3:
                    message.displayName = reader.string();
                    break;
                case /* google.protobuf.Timestamp create_time */ 5:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* string created_by */ 13:
                    message.createdBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp destroy_time */ 7:
                    message.destroyTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.destroyTime);
                    break;
                case /* google.protobuf.Timestamp delete_time */ 8:
                    message.deleteTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deleteTime);
                    break;
                case /* string customer_id */ 10:
                    message.customerId = reader.string();
                    break;
                case /* string app_space_id */ 11:
                    message.appSpaceId = reader.string();
                    break;
                case /* string service_account_id */ 12:
                    message.serviceAccountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceAccountCredential, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string kid = 2; */
        if (message.kid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kid);
        /* string display_name = 3; */
        if (message.displayName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        /* google.protobuf.Timestamp create_time = 5; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string created_by = 13; */
        if (message.createdBy !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.createdBy);
        /* google.protobuf.Timestamp destroy_time = 7; */
        if (message.destroyTime)
            Timestamp.internalBinaryWrite(message.destroyTime, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp delete_time = 8; */
        if (message.deleteTime)
            Timestamp.internalBinaryWrite(message.deleteTime, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string customer_id = 10; */
        if (message.customerId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.customerId);
        /* string app_space_id = 11; */
        if (message.appSpaceId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.appSpaceId);
        /* string service_account_id = 12; */
        if (message.serviceAccountId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.serviceAccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.ServiceAccountCredential
 */
export const ServiceAccountCredential = new ServiceAccountCredential$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigNode$Type extends MessageType<ConfigNode> {
    constructor() {
        super("indykite.config.v1beta1.ConfigNode", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "63", pattern: "^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$" } } } },
            { no: 3, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "254" } } } },
            { no: 4, name: "description", kind: "message", T: () => StringValue, options: { "validate.rules": { string: { minLen: "2", maxLen: "254" } } } },
            { no: 5, name: "create_time", kind: "message", T: () => Timestamp },
            { no: 6, name: "update_time", kind: "message", T: () => Timestamp },
            { no: 26, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 27, name: "updated_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "destroy_time", kind: "message", T: () => Timestamp },
            { no: 8, name: "delete_time", kind: "message", T: () => Timestamp },
            { no: 9, name: "etag", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "customer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 11, name: "app_space_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 28, name: "audit_sink_config", kind: "message", oneof: "config", T: () => AuditSinkConfig, options: { "validate.rules": { message: { required: true } } } },
            { no: 23, name: "authorization_policy_config", kind: "message", oneof: "config", T: () => AuthorizationPolicyConfig, options: { "validate.rules": { message: { required: true } } } },
            { no: 30, name: "consent_config", kind: "message", oneof: "config", T: () => ConsentConfiguration, options: { "validate.rules": { message: { required: true } } } },
            { no: 31, name: "token_introspect_config", kind: "message", oneof: "config", T: () => TokenIntrospectConfig, options: { "validate.rules": { message: { required: true } } } },
            { no: 32, name: "ingest_pipeline_config", kind: "message", oneof: "config", T: () => IngestPipelineConfig, options: { "validate.rules": { message: { required: true } } } },
            { no: 29, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<ConfigNode>): ConfigNode {
        const message = { id: "", name: "", displayName: "", createdBy: "", updatedBy: "", etag: "", customerId: "", appSpaceId: "", config: { oneofKind: undefined }, version: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConfigNode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigNode): ConfigNode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string display_name */ 3:
                    message.displayName = reader.string();
                    break;
                case /* google.protobuf.StringValue description */ 4:
                    message.description = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.description);
                    break;
                case /* google.protobuf.Timestamp create_time */ 5:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* google.protobuf.Timestamp update_time */ 6:
                    message.updateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                case /* string created_by */ 26:
                    message.createdBy = reader.string();
                    break;
                case /* string updated_by */ 27:
                    message.updatedBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp destroy_time */ 7:
                    message.destroyTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.destroyTime);
                    break;
                case /* google.protobuf.Timestamp delete_time */ 8:
                    message.deleteTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deleteTime);
                    break;
                case /* string etag */ 9:
                    message.etag = reader.string();
                    break;
                case /* string customer_id */ 10:
                    message.customerId = reader.string();
                    break;
                case /* string app_space_id */ 11:
                    message.appSpaceId = reader.string();
                    break;
                case /* indykite.config.v1beta1.AuditSinkConfig audit_sink_config */ 28:
                    message.config = {
                        oneofKind: "auditSinkConfig",
                        auditSinkConfig: AuditSinkConfig.internalBinaryRead(reader, reader.uint32(), options, (message.config as any).auditSinkConfig)
                    };
                    break;
                case /* indykite.config.v1beta1.AuthorizationPolicyConfig authorization_policy_config */ 23:
                    message.config = {
                        oneofKind: "authorizationPolicyConfig",
                        authorizationPolicyConfig: AuthorizationPolicyConfig.internalBinaryRead(reader, reader.uint32(), options, (message.config as any).authorizationPolicyConfig)
                    };
                    break;
                case /* indykite.config.v1beta1.ConsentConfiguration consent_config */ 30:
                    message.config = {
                        oneofKind: "consentConfig",
                        consentConfig: ConsentConfiguration.internalBinaryRead(reader, reader.uint32(), options, (message.config as any).consentConfig)
                    };
                    break;
                case /* indykite.config.v1beta1.TokenIntrospectConfig token_introspect_config */ 31:
                    message.config = {
                        oneofKind: "tokenIntrospectConfig",
                        tokenIntrospectConfig: TokenIntrospectConfig.internalBinaryRead(reader, reader.uint32(), options, (message.config as any).tokenIntrospectConfig)
                    };
                    break;
                case /* indykite.config.v1beta1.IngestPipelineConfig ingest_pipeline_config */ 32:
                    message.config = {
                        oneofKind: "ingestPipelineConfig",
                        ingestPipelineConfig: IngestPipelineConfig.internalBinaryRead(reader, reader.uint32(), options, (message.config as any).ingestPipelineConfig)
                    };
                    break;
                case /* int64 version */ 29:
                    message.version = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigNode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string display_name = 3; */
        if (message.displayName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        /* google.protobuf.StringValue description = 4; */
        if (message.description)
            StringValue.internalBinaryWrite(message.description, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp create_time = 5; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp update_time = 6; */
        if (message.updateTime)
            Timestamp.internalBinaryWrite(message.updateTime, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string created_by = 26; */
        if (message.createdBy !== "")
            writer.tag(26, WireType.LengthDelimited).string(message.createdBy);
        /* string updated_by = 27; */
        if (message.updatedBy !== "")
            writer.tag(27, WireType.LengthDelimited).string(message.updatedBy);
        /* google.protobuf.Timestamp destroy_time = 7; */
        if (message.destroyTime)
            Timestamp.internalBinaryWrite(message.destroyTime, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp delete_time = 8; */
        if (message.deleteTime)
            Timestamp.internalBinaryWrite(message.deleteTime, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string etag = 9; */
        if (message.etag !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.etag);
        /* string customer_id = 10; */
        if (message.customerId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.customerId);
        /* string app_space_id = 11; */
        if (message.appSpaceId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.appSpaceId);
        /* indykite.config.v1beta1.AuditSinkConfig audit_sink_config = 28; */
        if (message.config.oneofKind === "auditSinkConfig")
            AuditSinkConfig.internalBinaryWrite(message.config.auditSinkConfig, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* indykite.config.v1beta1.AuthorizationPolicyConfig authorization_policy_config = 23; */
        if (message.config.oneofKind === "authorizationPolicyConfig")
            AuthorizationPolicyConfig.internalBinaryWrite(message.config.authorizationPolicyConfig, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* indykite.config.v1beta1.ConsentConfiguration consent_config = 30; */
        if (message.config.oneofKind === "consentConfig")
            ConsentConfiguration.internalBinaryWrite(message.config.consentConfig, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* indykite.config.v1beta1.TokenIntrospectConfig token_introspect_config = 31; */
        if (message.config.oneofKind === "tokenIntrospectConfig")
            TokenIntrospectConfig.internalBinaryWrite(message.config.tokenIntrospectConfig, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* indykite.config.v1beta1.IngestPipelineConfig ingest_pipeline_config = 32; */
        if (message.config.oneofKind === "ingestPipelineConfig")
            IngestPipelineConfig.internalBinaryWrite(message.config.ingestPipelineConfig, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* int64 version = 29; */
        if (message.version !== "0")
            writer.tag(29, WireType.Varint).int64(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.ConfigNode
 */
export const ConfigNode = new ConfigNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizationPolicyConfig$Type extends MessageType<AuthorizationPolicyConfig> {
    constructor() {
        super("indykite.config.v1beta1.AuthorizationPolicyConfig", [
            { no: 1, name: "policy", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "512000" } } } },
            { no: 2, name: "status", kind: "enum", T: () => ["indykite.config.v1beta1.AuthorizationPolicyConfig.Status", AuthorizationPolicyConfig_Status, "STATUS_"], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 3, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { unique: true, items: { string: { minLen: "1", maxLen: "20", pattern: "^[a-zA-Z0-9]+$" } }, ignoreEmpty: true } } } },
            { no: 4, name: "builder", kind: "message", T: () => PolicyBuilderConfig }
        ]);
    }
    create(value?: PartialMessage<AuthorizationPolicyConfig>): AuthorizationPolicyConfig {
        const message = { policy: "", status: 0, tags: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuthorizationPolicyConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorizationPolicyConfig): AuthorizationPolicyConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string policy */ 1:
                    message.policy = reader.string();
                    break;
                case /* indykite.config.v1beta1.AuthorizationPolicyConfig.Status status */ 2:
                    message.status = reader.int32();
                    break;
                case /* repeated string tags */ 3:
                    message.tags.push(reader.string());
                    break;
                case /* indykite.config.v1beta1.PolicyBuilderConfig builder */ 4:
                    message.builder = PolicyBuilderConfig.internalBinaryRead(reader, reader.uint32(), options, message.builder);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthorizationPolicyConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string policy = 1; */
        if (message.policy !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.policy);
        /* indykite.config.v1beta1.AuthorizationPolicyConfig.Status status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* repeated string tags = 3; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.tags[i]);
        /* indykite.config.v1beta1.PolicyBuilderConfig builder = 4; */
        if (message.builder)
            PolicyBuilderConfig.internalBinaryWrite(message.builder, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.AuthorizationPolicyConfig
 */
export const AuthorizationPolicyConfig = new AuthorizationPolicyConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuditSinkConfig$Type extends MessageType<AuditSinkConfig> {
    constructor() {
        super("indykite.config.v1beta1.AuditSinkConfig", [
            { no: 1, name: "kafka", kind: "message", oneof: "provider", T: () => KafkaSinkConfig, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<AuditSinkConfig>): AuditSinkConfig {
        const message = { provider: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuditSinkConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuditSinkConfig): AuditSinkConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.config.v1beta1.KafkaSinkConfig kafka */ 1:
                    message.provider = {
                        oneofKind: "kafka",
                        kafka: KafkaSinkConfig.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).kafka)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuditSinkConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.config.v1beta1.KafkaSinkConfig kafka = 1; */
        if (message.provider.oneofKind === "kafka")
            KafkaSinkConfig.internalBinaryWrite(message.provider.kafka, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.AuditSinkConfig
 */
export const AuditSinkConfig = new AuditSinkConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KafkaSinkConfig$Type extends MessageType<KafkaSinkConfig> {
    constructor() {
        super("indykite.config.v1beta1.KafkaSinkConfig", [
            { no: 1, name: "brokers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { unique: true, items: { string: { minLen: "8", uriRef: true } }, ignoreEmpty: true } } } },
            { no: 2, name: "topic", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", maxLen: "249", pattern: "^[a-zA-Z0-9._-]+$" } } } },
            { no: 3, name: "disable_tls", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "tls_skip_verify", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<KafkaSinkConfig>): KafkaSinkConfig {
        const message = { brokers: [], topic: "", disableTls: false, tlsSkipVerify: false, username: "", password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<KafkaSinkConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KafkaSinkConfig): KafkaSinkConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string brokers */ 1:
                    message.brokers.push(reader.string());
                    break;
                case /* string topic */ 2:
                    message.topic = reader.string();
                    break;
                case /* bool disable_tls */ 3:
                    message.disableTls = reader.bool();
                    break;
                case /* bool tls_skip_verify */ 4:
                    message.tlsSkipVerify = reader.bool();
                    break;
                case /* string username */ 5:
                    message.username = reader.string();
                    break;
                case /* string password */ 6:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KafkaSinkConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string brokers = 1; */
        for (let i = 0; i < message.brokers.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.brokers[i]);
        /* string topic = 2; */
        if (message.topic !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.topic);
        /* bool disable_tls = 3; */
        if (message.disableTls !== false)
            writer.tag(3, WireType.Varint).bool(message.disableTls);
        /* bool tls_skip_verify = 4; */
        if (message.tlsSkipVerify !== false)
            writer.tag(4, WireType.Varint).bool(message.tlsSkipVerify);
        /* string username = 5; */
        if (message.username !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.username);
        /* string password = 6; */
        if (message.password !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.KafkaSinkConfig
 */
export const KafkaSinkConfig = new KafkaSinkConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConsentConfiguration$Type extends MessageType<ConsentConfiguration> {
    constructor() {
        super("indykite.config.v1beta1.ConsentConfiguration", [
            { no: 1, name: "purpose", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "1024" } } } },
            { no: 2, name: "data_points", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { minItems: "1", unique: true, items: { string: { minLen: "1", maxLen: "1024", prefix: "{" } } } } } },
            { no: 3, name: "application_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "22", maxLen: "254", pattern: "^[A-Za-z0-9-_:]{22,254}$" } } } },
            { no: 4, name: "validity_period", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { lte: "63072000", gte: "86400" } } } },
            { no: 5, name: "revoke_after_use", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "token_status", kind: "enum", T: () => ["indykite.config.v1beta1.ExternalTokenStatus", ExternalTokenStatus, "EXTERNAL_TOKEN_STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<ConsentConfiguration>): ConsentConfiguration {
        const message = { purpose: "", dataPoints: [], applicationId: "", validityPeriod: "0", revokeAfterUse: false, tokenStatus: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConsentConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsentConfiguration): ConsentConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string purpose */ 1:
                    message.purpose = reader.string();
                    break;
                case /* repeated string data_points */ 2:
                    message.dataPoints.push(reader.string());
                    break;
                case /* string application_id */ 3:
                    message.applicationId = reader.string();
                    break;
                case /* uint64 validity_period */ 4:
                    message.validityPeriod = reader.uint64().toString();
                    break;
                case /* bool revoke_after_use */ 5:
                    message.revokeAfterUse = reader.bool();
                    break;
                case /* indykite.config.v1beta1.ExternalTokenStatus token_status */ 7:
                    message.tokenStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConsentConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string purpose = 1; */
        if (message.purpose !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.purpose);
        /* repeated string data_points = 2; */
        for (let i = 0; i < message.dataPoints.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.dataPoints[i]);
        /* string application_id = 3; */
        if (message.applicationId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.applicationId);
        /* uint64 validity_period = 4; */
        if (message.validityPeriod !== "0")
            writer.tag(4, WireType.Varint).uint64(message.validityPeriod);
        /* bool revoke_after_use = 5; */
        if (message.revokeAfterUse !== false)
            writer.tag(5, WireType.Varint).bool(message.revokeAfterUse);
        /* indykite.config.v1beta1.ExternalTokenStatus token_status = 7; */
        if (message.tokenStatus !== 0)
            writer.tag(7, WireType.Varint).int32(message.tokenStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.ConsentConfiguration
 */
export const ConsentConfiguration = new ConsentConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig$Type extends MessageType<TokenIntrospectConfig> {
    constructor() {
        super("indykite.config.v1beta1.TokenIntrospectConfig", [
            { no: 1, name: "jwt", kind: "message", oneof: "tokenMatcher", T: () => TokenIntrospectConfig_JWT, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "opaque", kind: "message", oneof: "tokenMatcher", T: () => TokenIntrospectConfig_Opaque, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "offline", kind: "message", oneof: "validation", T: () => TokenIntrospectConfig_Offline, options: { "validate.rules": { message: { required: true } } } },
            { no: 4, name: "online", kind: "message", oneof: "validation", T: () => TokenIntrospectConfig_Online, options: { "validate.rules": { message: { required: true } } } },
            { no: 7, name: "claims_mapping", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => TokenIntrospectConfig_Claim }, options: { "validate.rules": { map: { keys: { string: { maxLen: "256", pattern: "^[a-zA-Z_][a-zA-Z0-9_]+$" } }, values: { message: { required: true } } } } } },
            { no: 5, name: "ikg_node_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "2", maxLen: "64", pattern: "^([A-Z][a-z]+)+$" } } } },
            { no: 6, name: "perform_upsert", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectConfig>): TokenIntrospectConfig {
        const message = { tokenMatcher: { oneofKind: undefined }, validation: { oneofKind: undefined }, claimsMapping: {}, ikgNodeType: "", performUpsert: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig): TokenIntrospectConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.config.v1beta1.TokenIntrospectConfig.JWT jwt */ 1:
                    message.tokenMatcher = {
                        oneofKind: "jwt",
                        jwt: TokenIntrospectConfig_JWT.internalBinaryRead(reader, reader.uint32(), options, (message.tokenMatcher as any).jwt)
                    };
                    break;
                case /* indykite.config.v1beta1.TokenIntrospectConfig.Opaque opaque */ 2:
                    message.tokenMatcher = {
                        oneofKind: "opaque",
                        opaque: TokenIntrospectConfig_Opaque.internalBinaryRead(reader, reader.uint32(), options, (message.tokenMatcher as any).opaque)
                    };
                    break;
                case /* indykite.config.v1beta1.TokenIntrospectConfig.Offline offline */ 3:
                    message.validation = {
                        oneofKind: "offline",
                        offline: TokenIntrospectConfig_Offline.internalBinaryRead(reader, reader.uint32(), options, (message.validation as any).offline)
                    };
                    break;
                case /* indykite.config.v1beta1.TokenIntrospectConfig.Online online */ 4:
                    message.validation = {
                        oneofKind: "online",
                        online: TokenIntrospectConfig_Online.internalBinaryRead(reader, reader.uint32(), options, (message.validation as any).online)
                    };
                    break;
                case /* map<string, indykite.config.v1beta1.TokenIntrospectConfig.Claim> claims_mapping */ 7:
                    this.binaryReadMap7(message.claimsMapping, reader, options);
                    break;
                case /* string ikg_node_type */ 5:
                    message.ikgNodeType = reader.string();
                    break;
                case /* bool perform_upsert */ 6:
                    message.performUpsert = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: TokenIntrospectConfig["claimsMapping"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TokenIntrospectConfig["claimsMapping"] | undefined, val: TokenIntrospectConfig["claimsMapping"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = TokenIntrospectConfig_Claim.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.config.v1beta1.TokenIntrospectConfig.claims_mapping");
            }
        }
        map[key ?? ""] = val ?? TokenIntrospectConfig_Claim.create();
    }
    internalBinaryWrite(message: TokenIntrospectConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.config.v1beta1.TokenIntrospectConfig.JWT jwt = 1; */
        if (message.tokenMatcher.oneofKind === "jwt")
            TokenIntrospectConfig_JWT.internalBinaryWrite(message.tokenMatcher.jwt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* indykite.config.v1beta1.TokenIntrospectConfig.Opaque opaque = 2; */
        if (message.tokenMatcher.oneofKind === "opaque")
            TokenIntrospectConfig_Opaque.internalBinaryWrite(message.tokenMatcher.opaque, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* indykite.config.v1beta1.TokenIntrospectConfig.Offline offline = 3; */
        if (message.validation.oneofKind === "offline")
            TokenIntrospectConfig_Offline.internalBinaryWrite(message.validation.offline, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* indykite.config.v1beta1.TokenIntrospectConfig.Online online = 4; */
        if (message.validation.oneofKind === "online")
            TokenIntrospectConfig_Online.internalBinaryWrite(message.validation.online, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* map<string, indykite.config.v1beta1.TokenIntrospectConfig.Claim> claims_mapping = 7; */
        for (let k of Object.keys(message.claimsMapping)) {
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            TokenIntrospectConfig_Claim.internalBinaryWrite(message.claimsMapping[k], writer, options);
            writer.join().join();
        }
        /* string ikg_node_type = 5; */
        if (message.ikgNodeType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.ikgNodeType);
        /* bool perform_upsert = 6; */
        if (message.performUpsert !== false)
            writer.tag(6, WireType.Varint).bool(message.performUpsert);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.TokenIntrospectConfig
 */
export const TokenIntrospectConfig = new TokenIntrospectConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig_JWT$Type extends MessageType<TokenIntrospectConfig_JWT> {
    constructor() {
        super("indykite.config.v1beta1.TokenIntrospectConfig.JWT", [
            { no: 1, name: "issuer", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { uri: true } } } },
            { no: 2, name: "audience", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", maxLen: "150" } } } }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectConfig_JWT>): TokenIntrospectConfig_JWT {
        const message = { issuer: "", audience: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig_JWT>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig_JWT): TokenIntrospectConfig_JWT {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string issuer */ 1:
                    message.issuer = reader.string();
                    break;
                case /* string audience */ 2:
                    message.audience = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenIntrospectConfig_JWT, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string issuer = 1; */
        if (message.issuer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.issuer);
        /* string audience = 2; */
        if (message.audience !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.audience);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.TokenIntrospectConfig.JWT
 */
export const TokenIntrospectConfig_JWT = new TokenIntrospectConfig_JWT$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig_Opaque$Type extends MessageType<TokenIntrospectConfig_Opaque> {
    constructor() {
        super("indykite.config.v1beta1.TokenIntrospectConfig.Opaque", []);
    }
    create(value?: PartialMessage<TokenIntrospectConfig_Opaque>): TokenIntrospectConfig_Opaque {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig_Opaque>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig_Opaque): TokenIntrospectConfig_Opaque {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TokenIntrospectConfig_Opaque, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.TokenIntrospectConfig.Opaque
 */
export const TokenIntrospectConfig_Opaque = new TokenIntrospectConfig_Opaque$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig_Offline$Type extends MessageType<TokenIntrospectConfig_Offline> {
    constructor() {
        super("indykite.config.v1beta1.TokenIntrospectConfig.Offline", [
            { no: 1, name: "public_jwks", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/, options: { "validate.rules": { repeated: { maxItems: "10", items: { bytes: { minLen: "96", maxLen: "8192", prefix: "ew==", suffix: "fQ==" } } } } } }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectConfig_Offline>): TokenIntrospectConfig_Offline {
        const message = { publicJwks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig_Offline>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig_Offline): TokenIntrospectConfig_Offline {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes public_jwks */ 1:
                    message.publicJwks.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenIntrospectConfig_Offline, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes public_jwks = 1; */
        for (let i = 0; i < message.publicJwks.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.publicJwks[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.TokenIntrospectConfig.Offline
 */
export const TokenIntrospectConfig_Offline = new TokenIntrospectConfig_Offline$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig_Online$Type extends MessageType<TokenIntrospectConfig_Online> {
    constructor() {
        super("indykite.config.v1beta1.TokenIntrospectConfig.Online", [
            { no: 1, name: "userinfo_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { uri: true, ignoreEmpty: true } } } },
            { no: 2, name: "cache_ttl", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { lte: { seconds: "3600" } } } } }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectConfig_Online>): TokenIntrospectConfig_Online {
        const message = { userinfoEndpoint: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig_Online>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig_Online): TokenIntrospectConfig_Online {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string userinfo_endpoint */ 1:
                    message.userinfoEndpoint = reader.string();
                    break;
                case /* google.protobuf.Duration cache_ttl */ 2:
                    message.cacheTtl = Duration.internalBinaryRead(reader, reader.uint32(), options, message.cacheTtl);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenIntrospectConfig_Online, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string userinfo_endpoint = 1; */
        if (message.userinfoEndpoint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userinfoEndpoint);
        /* google.protobuf.Duration cache_ttl = 2; */
        if (message.cacheTtl)
            Duration.internalBinaryWrite(message.cacheTtl, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.TokenIntrospectConfig.Online
 */
export const TokenIntrospectConfig_Online = new TokenIntrospectConfig_Online$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenIntrospectConfig_Claim$Type extends MessageType<TokenIntrospectConfig_Claim> {
    constructor() {
        super("indykite.config.v1beta1.TokenIntrospectConfig.Claim", [
            { no: 1, name: "selector", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", maxLen: "200" } } } }
        ]);
    }
    create(value?: PartialMessage<TokenIntrospectConfig_Claim>): TokenIntrospectConfig_Claim {
        const message = { selector: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TokenIntrospectConfig_Claim>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenIntrospectConfig_Claim): TokenIntrospectConfig_Claim {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string selector */ 1:
                    message.selector = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenIntrospectConfig_Claim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string selector = 1; */
        if (message.selector !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.selector);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.TokenIntrospectConfig.Claim
 */
export const TokenIntrospectConfig_Claim = new TokenIntrospectConfig_Claim$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConsentDataPoint$Type extends MessageType<ConsentDataPoint> {
    constructor() {
        super("indykite.config.v1beta1.ConsentDataPoint", [
            { no: 1, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "1024" } } } },
            { no: 2, name: "returns", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ConsentDataPoint_Return, options: { "validate.rules": { repeated: { minItems: "1", maxItems: "20" } } } }
        ]);
    }
    create(value?: PartialMessage<ConsentDataPoint>): ConsentDataPoint {
        const message = { query: "", returns: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConsentDataPoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsentDataPoint): ConsentDataPoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string query */ 1:
                    message.query = reader.string();
                    break;
                case /* repeated indykite.config.v1beta1.ConsentDataPoint.Return returns */ 2:
                    message.returns.push(ConsentDataPoint_Return.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConsentDataPoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string query = 1; */
        if (message.query !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.query);
        /* repeated indykite.config.v1beta1.ConsentDataPoint.Return returns = 2; */
        for (let i = 0; i < message.returns.length; i++)
            ConsentDataPoint_Return.internalBinaryWrite(message.returns[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.ConsentDataPoint
 */
export const ConsentDataPoint = new ConsentDataPoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConsentDataPoint_Return$Type extends MessageType<ConsentDataPoint_Return> {
    constructor() {
        super("indykite.config.v1beta1.ConsentDataPoint.Return", [
            { no: 1, name: "variable", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "32" } } } },
            { no: 2, name: "properties", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { maxItems: "50" } } } }
        ]);
    }
    create(value?: PartialMessage<ConsentDataPoint_Return>): ConsentDataPoint_Return {
        const message = { variable: "", properties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConsentDataPoint_Return>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsentDataPoint_Return): ConsentDataPoint_Return {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string variable */ 1:
                    message.variable = reader.string();
                    break;
                case /* repeated string properties */ 2:
                    message.properties.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConsentDataPoint_Return, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string variable = 1; */
        if (message.variable !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.variable);
        /* repeated string properties = 2; */
        for (let i = 0; i < message.properties.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.properties[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.ConsentDataPoint.Return
 */
export const ConsentDataPoint_Return = new ConsentDataPoint_Return$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IngestPipelineConfig$Type extends MessageType<IngestPipelineConfig> {
    constructor() {
        super("indykite.config.v1beta1.IngestPipelineConfig", [
            { no: 1, name: "sources", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { minItems: "1", maxItems: "10" } } } },
            { no: 2, name: "operations", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["indykite.config.v1beta1.IngestPipelineOperation", IngestPipelineOperation, "INGEST_PIPELINE_OPERATION_"], options: { "validate.rules": { repeated: { minItems: "1", maxItems: "6" } } } },
            { no: 3, name: "app_agent_token", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { pattern: "^[A-Za-z0-9-_]+?\\.[A-Za-z0-9-_]+?\\.[A-Za-z0-9-_]+?$" } } } }
        ]);
    }
    create(value?: PartialMessage<IngestPipelineConfig>): IngestPipelineConfig {
        const message = { sources: [], operations: [], appAgentToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IngestPipelineConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IngestPipelineConfig): IngestPipelineConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string sources */ 1:
                    message.sources.push(reader.string());
                    break;
                case /* repeated indykite.config.v1beta1.IngestPipelineOperation operations */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.operations.push(reader.int32());
                    else
                        message.operations.push(reader.int32());
                    break;
                case /* string app_agent_token */ 3:
                    message.appAgentToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IngestPipelineConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string sources = 1; */
        for (let i = 0; i < message.sources.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.sources[i]);
        /* repeated indykite.config.v1beta1.IngestPipelineOperation operations = 2; */
        if (message.operations.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.operations.length; i++)
                writer.int32(message.operations[i]);
            writer.join();
        }
        /* string app_agent_token = 3; */
        if (message.appAgentToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.appAgentToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.config.v1beta1.IngestPipelineConfig
 */
export const IngestPipelineConfig = new IngestPipelineConfig$Type();
