// @generated by protobuf-ts 2.9.0 with parameter long_type_string,client_grpc1,generate_dependencies
// @generated from protobuf file "indykite/identity/v1beta2/identity_management_api.proto" (package "indykite.identity.v1beta2", syntax proto3)
// tslint:disable
//
// Copyright (c) 2020-2022 IndyKite
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import { IdentityManagementAPI } from "./identity_management_api";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { CreateCustomLoginTokenResponse } from "./identity_management_api";
import type { CreateCustomLoginTokenRequest } from "./identity_management_api";
import type { SessionIntrospectResponse } from "./identity_management_api";
import type { SessionIntrospectRequest } from "./identity_management_api";
import type { GetAccessTokenResponse } from "./identity_management_api";
import type { GetAccessTokenRequest } from "./identity_management_api";
import type { UpdatePasswordCredentialResponse } from "./identity_management_api";
import type { UpdatePasswordCredentialRequest } from "./identity_management_api";
import type { GetPasswordCredentialResponse } from "./identity_management_api";
import type { GetPasswordCredentialRequest } from "./identity_management_api";
import type { RevokeConsentResponse } from "./identity_management_api";
import type { RevokeConsentRequest } from "./identity_management_api";
import type { ListConsentsResponse } from "./identity_management_api";
import type { ListConsentsRequest } from "./identity_management_api";
import type { CreateConsentResponse } from "./identity_management_api";
import type { CreateConsentRequest } from "./identity_management_api";
import type { EnrichTokenResponse } from "./identity_management_api";
import type { EnrichTokenRequest } from "./identity_management_api";
import type { CancelInvitationResponse } from "./identity_management_api";
import type { CancelInvitationRequest } from "./identity_management_api";
import type { ResendInvitationResponse } from "./identity_management_api";
import type { ResendInvitationRequest } from "./identity_management_api";
import type { CheckInvitationStateResponse } from "./identity_management_api";
import type { CheckInvitationStateRequest } from "./identity_management_api";
import type { CreateInvitationResponse } from "./identity_management_api";
import type { CreateInvitationRequest } from "./identity_management_api";
import type { CreateOAuth2ConsentVerifierResponse } from "./identity_management_api";
import type { CreateOAuth2ConsentVerifierRequest } from "./identity_management_api";
import type { CheckOAuth2ConsentChallengeResponse } from "./identity_management_api";
import type { CheckOAuth2ConsentChallengeRequest } from "./identity_management_api";
import type { DeleteDigitalTwinResponse } from "./identity_management_api";
import type { DeleteDigitalTwinRequest } from "./identity_management_api";
import type { PatchDigitalTwinResponse } from "./identity_management_api";
import type { PatchDigitalTwinRequest } from "./identity_management_api";
import type { RegisterDigitalTwinWithoutCredentialResponse } from "./identity_management_api";
import type { RegisterDigitalTwinWithoutCredentialRequest } from "./identity_management_api";
import type { ListDigitalTwinsResponse } from "./identity_management_api";
import type { ListDigitalTwinsRequest } from "./identity_management_api";
import type { GetDigitalTwinResponse } from "./identity_management_api";
import type { GetDigitalTwinRequest } from "./identity_management_api";
import type { ImportDigitalTwinsResponse } from "./import";
import type { ImportDigitalTwinsRequest } from "./import";
import type { SelfServiceTerminateSessionResponse } from "./identity_management_api";
import type { SelfServiceTerminateSessionRequest } from "./identity_management_api";
import type { VerifyDigitalTwinEmailResponse } from "./identity_management_api";
import type { VerifyDigitalTwinEmailRequest } from "./identity_management_api";
import type { StartDigitalTwinEmailVerificationResponse } from "./identity_management_api";
import type { StartDigitalTwinEmailVerificationRequest } from "./identity_management_api";
import type { ChangePasswordResponse } from "./identity_management_api";
import type { ChangePasswordRequest } from "./identity_management_api";
import type { StartForgottenPasswordFlowResponse } from "./identity_management_api";
import type { StartForgottenPasswordFlowRequest } from "./identity_management_api";
import type { TokenIntrospectResponse } from "./identity_management_api";
import type { TokenIntrospectRequest } from "./identity_management_api";
import * as grpc from "@grpc/grpc-js";
/**
 * IdentityManagementAPI represents the service interface to manage the Identities and their data.
 *
 * @generated from protobuf service indykite.identity.v1beta2.IdentityManagementAPI
 */
export interface IIdentityManagementAPIClient {
    /**
     * TokenIntrospect function validates the token and returns information about it.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: TokenIntrospect(indykite.identity.v1beta2.TokenIntrospectRequest) returns (indykite.identity.v1beta2.TokenIntrospectResponse);
     */
    tokenIntrospect(input: TokenIntrospectRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: TokenIntrospectResponse) => void): grpc.ClientUnaryCall;
    tokenIntrospect(input: TokenIntrospectRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: TokenIntrospectResponse) => void): grpc.ClientUnaryCall;
    tokenIntrospect(input: TokenIntrospectRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: TokenIntrospectResponse) => void): grpc.ClientUnaryCall;
    tokenIntrospect(input: TokenIntrospectRequest, callback: (err: grpc.ServiceError | null, value?: TokenIntrospectResponse) => void): grpc.ClientUnaryCall;
    /**
     * StartForgottenPasswordFlow function initiates the flow where systems sends a notification to DigitalTwin
     * with a link to set the new password.
     *
     * The flow checks if the DigitalTwin has primary contact information and if so it sends a message with a link.
     * By opening the link the UI SDK guides the User-Agent through the Authentication Flow where the user is
     * allowed to set a new Password credential.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: StartForgottenPasswordFlow(indykite.identity.v1beta2.StartForgottenPasswordFlowRequest) returns (indykite.identity.v1beta2.StartForgottenPasswordFlowResponse);
     */
    startForgottenPasswordFlow(input: StartForgottenPasswordFlowRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: StartForgottenPasswordFlowResponse) => void): grpc.ClientUnaryCall;
    startForgottenPasswordFlow(input: StartForgottenPasswordFlowRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: StartForgottenPasswordFlowResponse) => void): grpc.ClientUnaryCall;
    startForgottenPasswordFlow(input: StartForgottenPasswordFlowRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: StartForgottenPasswordFlowResponse) => void): grpc.ClientUnaryCall;
    startForgottenPasswordFlow(input: StartForgottenPasswordFlowRequest, callback: (err: grpc.ServiceError | null, value?: StartForgottenPasswordFlowResponse) => void): grpc.ClientUnaryCall;
    /**
     * ChangePassword function allows the Application to replace the Password credential of a DigitalTwin.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: ChangePassword(indykite.identity.v1beta2.ChangePasswordRequest) returns (indykite.identity.v1beta2.ChangePasswordResponse);
     */
    changePassword(input: ChangePasswordRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ChangePasswordResponse) => void): grpc.ClientUnaryCall;
    changePassword(input: ChangePasswordRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: ChangePasswordResponse) => void): grpc.ClientUnaryCall;
    changePassword(input: ChangePasswordRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ChangePasswordResponse) => void): grpc.ClientUnaryCall;
    changePassword(input: ChangePasswordRequest, callback: (err: grpc.ServiceError | null, value?: ChangePasswordResponse) => void): grpc.ClientUnaryCall;
    /**
     * StartDigitalTwinEmailVerification function initiates the flow where IndyKite systems sends a
     * notification to DigitalTwin with a link to verify the control over
     * the notification channel (email only for now).
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: StartDigitalTwinEmailVerification(indykite.identity.v1beta2.StartDigitalTwinEmailVerificationRequest) returns (indykite.identity.v1beta2.StartDigitalTwinEmailVerificationResponse);
     */
    startDigitalTwinEmailVerification(input: StartDigitalTwinEmailVerificationRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: StartDigitalTwinEmailVerificationResponse) => void): grpc.ClientUnaryCall;
    startDigitalTwinEmailVerification(input: StartDigitalTwinEmailVerificationRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: StartDigitalTwinEmailVerificationResponse) => void): grpc.ClientUnaryCall;
    startDigitalTwinEmailVerification(input: StartDigitalTwinEmailVerificationRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: StartDigitalTwinEmailVerificationResponse) => void): grpc.ClientUnaryCall;
    startDigitalTwinEmailVerification(input: StartDigitalTwinEmailVerificationRequest, callback: (err: grpc.ServiceError | null, value?: StartDigitalTwinEmailVerificationResponse) => void): grpc.ClientUnaryCall;
    /**
     * VerifyDigitalTwinEmail function confirms to IndyKite system that the message from
     * StartDigitalTwinEmailVerification function was sent and user visited the link.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: VerifyDigitalTwinEmail(indykite.identity.v1beta2.VerifyDigitalTwinEmailRequest) returns (indykite.identity.v1beta2.VerifyDigitalTwinEmailResponse);
     */
    verifyDigitalTwinEmail(input: VerifyDigitalTwinEmailRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: VerifyDigitalTwinEmailResponse) => void): grpc.ClientUnaryCall;
    verifyDigitalTwinEmail(input: VerifyDigitalTwinEmailRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: VerifyDigitalTwinEmailResponse) => void): grpc.ClientUnaryCall;
    verifyDigitalTwinEmail(input: VerifyDigitalTwinEmailRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: VerifyDigitalTwinEmailResponse) => void): grpc.ClientUnaryCall;
    verifyDigitalTwinEmail(input: VerifyDigitalTwinEmailRequest, callback: (err: grpc.ServiceError | null, value?: VerifyDigitalTwinEmailResponse) => void): grpc.ClientUnaryCall;
    /**
     * SelfServiceTerminateSession function terminates and invalidates a login session.
     *
     * This is a protected operation and it can be accessed by both credentials,
     * with valid agent or DigitalTwin credential.
     *
     * @generated from protobuf rpc: SelfServiceTerminateSession(indykite.identity.v1beta2.SelfServiceTerminateSessionRequest) returns (indykite.identity.v1beta2.SelfServiceTerminateSessionResponse);
     */
    selfServiceTerminateSession(input: SelfServiceTerminateSessionRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: SelfServiceTerminateSessionResponse) => void): grpc.ClientUnaryCall;
    selfServiceTerminateSession(input: SelfServiceTerminateSessionRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: SelfServiceTerminateSessionResponse) => void): grpc.ClientUnaryCall;
    selfServiceTerminateSession(input: SelfServiceTerminateSessionRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: SelfServiceTerminateSessionResponse) => void): grpc.ClientUnaryCall;
    selfServiceTerminateSession(input: SelfServiceTerminateSessionRequest, callback: (err: grpc.ServiceError | null, value?: SelfServiceTerminateSessionResponse) => void): grpc.ClientUnaryCall;
    /**
     * ImportDigitalTwins imports multiple DigitalTwin into the IndyKite database.
     *
     * No more than 1000 users can be imported in a single call.
     *
     * @generated from protobuf rpc: ImportDigitalTwins(indykite.identity.v1beta2.ImportDigitalTwinsRequest) returns (indykite.identity.v1beta2.ImportDigitalTwinsResponse);
     */
    importDigitalTwins(input: ImportDigitalTwinsRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ImportDigitalTwinsResponse) => void): grpc.ClientUnaryCall;
    importDigitalTwins(input: ImportDigitalTwinsRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: ImportDigitalTwinsResponse) => void): grpc.ClientUnaryCall;
    importDigitalTwins(input: ImportDigitalTwinsRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ImportDigitalTwinsResponse) => void): grpc.ClientUnaryCall;
    importDigitalTwins(input: ImportDigitalTwinsRequest, callback: (err: grpc.ServiceError | null, value?: ImportDigitalTwinsResponse) => void): grpc.ClientUnaryCall;
    /**
     * GetDigitalTwin gets a DigitalTwin and requested properties.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: GetDigitalTwin(indykite.identity.v1beta2.GetDigitalTwinRequest) returns (indykite.identity.v1beta2.GetDigitalTwinResponse);
     */
    getDigitalTwin(input: GetDigitalTwinRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetDigitalTwinResponse) => void): grpc.ClientUnaryCall;
    getDigitalTwin(input: GetDigitalTwinRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: GetDigitalTwinResponse) => void): grpc.ClientUnaryCall;
    getDigitalTwin(input: GetDigitalTwinRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetDigitalTwinResponse) => void): grpc.ClientUnaryCall;
    getDigitalTwin(input: GetDigitalTwinRequest, callback: (err: grpc.ServiceError | null, value?: GetDigitalTwinResponse) => void): grpc.ClientUnaryCall;
    /**
     * ListDigitalTwins lists DigitalTwins matching the filter.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: ListDigitalTwins(indykite.identity.v1beta2.ListDigitalTwinsRequest) returns (indykite.identity.v1beta2.ListDigitalTwinsResponse);
     */
    listDigitalTwins(input: ListDigitalTwinsRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListDigitalTwinsResponse) => void): grpc.ClientUnaryCall;
    listDigitalTwins(input: ListDigitalTwinsRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: ListDigitalTwinsResponse) => void): grpc.ClientUnaryCall;
    listDigitalTwins(input: ListDigitalTwinsRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListDigitalTwinsResponse) => void): grpc.ClientUnaryCall;
    listDigitalTwins(input: ListDigitalTwinsRequest, callback: (err: grpc.ServiceError | null, value?: ListDigitalTwinsResponse) => void): grpc.ClientUnaryCall;
    /**
     * RegisterDigitalTwinWithoutCredential creates a DigitalTwin without credentials, but with properties
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: RegisterDigitalTwinWithoutCredential(indykite.identity.v1beta2.RegisterDigitalTwinWithoutCredentialRequest) returns (indykite.identity.v1beta2.RegisterDigitalTwinWithoutCredentialResponse);
     */
    registerDigitalTwinWithoutCredential(input: RegisterDigitalTwinWithoutCredentialRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: RegisterDigitalTwinWithoutCredentialResponse) => void): grpc.ClientUnaryCall;
    registerDigitalTwinWithoutCredential(input: RegisterDigitalTwinWithoutCredentialRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: RegisterDigitalTwinWithoutCredentialResponse) => void): grpc.ClientUnaryCall;
    registerDigitalTwinWithoutCredential(input: RegisterDigitalTwinWithoutCredentialRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: RegisterDigitalTwinWithoutCredentialResponse) => void): grpc.ClientUnaryCall;
    registerDigitalTwinWithoutCredential(input: RegisterDigitalTwinWithoutCredentialRequest, callback: (err: grpc.ServiceError | null, value?: RegisterDigitalTwinWithoutCredentialResponse) => void): grpc.ClientUnaryCall;
    /**
     * PatchDigitalTwin updates the properties of a DigitalTwin.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: PatchDigitalTwin(indykite.identity.v1beta2.PatchDigitalTwinRequest) returns (indykite.identity.v1beta2.PatchDigitalTwinResponse);
     */
    patchDigitalTwin(input: PatchDigitalTwinRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: PatchDigitalTwinResponse) => void): grpc.ClientUnaryCall;
    patchDigitalTwin(input: PatchDigitalTwinRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: PatchDigitalTwinResponse) => void): grpc.ClientUnaryCall;
    patchDigitalTwin(input: PatchDigitalTwinRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: PatchDigitalTwinResponse) => void): grpc.ClientUnaryCall;
    patchDigitalTwin(input: PatchDigitalTwinRequest, callback: (err: grpc.ServiceError | null, value?: PatchDigitalTwinResponse) => void): grpc.ClientUnaryCall;
    /**
     * DeleteDigitalTwin deletes the given DigitalTwin entirely from the system.
     *
     * This operation can't be restored.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: DeleteDigitalTwin(indykite.identity.v1beta2.DeleteDigitalTwinRequest) returns (indykite.identity.v1beta2.DeleteDigitalTwinResponse);
     */
    deleteDigitalTwin(input: DeleteDigitalTwinRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: DeleteDigitalTwinResponse) => void): grpc.ClientUnaryCall;
    deleteDigitalTwin(input: DeleteDigitalTwinRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: DeleteDigitalTwinResponse) => void): grpc.ClientUnaryCall;
    deleteDigitalTwin(input: DeleteDigitalTwinRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: DeleteDigitalTwinResponse) => void): grpc.ClientUnaryCall;
    deleteDigitalTwin(input: DeleteDigitalTwinRequest, callback: (err: grpc.ServiceError | null, value?: DeleteDigitalTwinResponse) => void): grpc.ClientUnaryCall;
    /**
     * CheckOAuth2ConsentChallenge read the Consent Challenge from DB.
     *
     * @generated from protobuf rpc: CheckOAuth2ConsentChallenge(indykite.identity.v1beta2.CheckOAuth2ConsentChallengeRequest) returns (indykite.identity.v1beta2.CheckOAuth2ConsentChallengeResponse);
     */
    checkOAuth2ConsentChallenge(input: CheckOAuth2ConsentChallengeRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CheckOAuth2ConsentChallengeResponse) => void): grpc.ClientUnaryCall;
    checkOAuth2ConsentChallenge(input: CheckOAuth2ConsentChallengeRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: CheckOAuth2ConsentChallengeResponse) => void): grpc.ClientUnaryCall;
    checkOAuth2ConsentChallenge(input: CheckOAuth2ConsentChallengeRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CheckOAuth2ConsentChallengeResponse) => void): grpc.ClientUnaryCall;
    checkOAuth2ConsentChallenge(input: CheckOAuth2ConsentChallengeRequest, callback: (err: grpc.ServiceError | null, value?: CheckOAuth2ConsentChallengeResponse) => void): grpc.ClientUnaryCall;
    /**
     * CreateOAuth2ConsentVerifier invalidates the Consent Challenge and creates a new Consent Verifier.
     *
     * @generated from protobuf rpc: CreateOAuth2ConsentVerifier(indykite.identity.v1beta2.CreateOAuth2ConsentVerifierRequest) returns (indykite.identity.v1beta2.CreateOAuth2ConsentVerifierResponse);
     */
    createOAuth2ConsentVerifier(input: CreateOAuth2ConsentVerifierRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CreateOAuth2ConsentVerifierResponse) => void): grpc.ClientUnaryCall;
    createOAuth2ConsentVerifier(input: CreateOAuth2ConsentVerifierRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: CreateOAuth2ConsentVerifierResponse) => void): grpc.ClientUnaryCall;
    createOAuth2ConsentVerifier(input: CreateOAuth2ConsentVerifierRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CreateOAuth2ConsentVerifierResponse) => void): grpc.ClientUnaryCall;
    createOAuth2ConsentVerifier(input: CreateOAuth2ConsentVerifierRequest, callback: (err: grpc.ServiceError | null, value?: CreateOAuth2ConsentVerifierResponse) => void): grpc.ClientUnaryCall;
    /**
     * CreateInvitation will start invitation workflow
     *
     * @generated from protobuf rpc: CreateInvitation(indykite.identity.v1beta2.CreateInvitationRequest) returns (indykite.identity.v1beta2.CreateInvitationResponse);
     */
    createInvitation(input: CreateInvitationRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CreateInvitationResponse) => void): grpc.ClientUnaryCall;
    createInvitation(input: CreateInvitationRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: CreateInvitationResponse) => void): grpc.ClientUnaryCall;
    createInvitation(input: CreateInvitationRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CreateInvitationResponse) => void): grpc.ClientUnaryCall;
    createInvitation(input: CreateInvitationRequest, callback: (err: grpc.ServiceError | null, value?: CreateInvitationResponse) => void): grpc.ClientUnaryCall;
    /**
     * CheckInvitationState returns state of invitation and its data
     *
     * @generated from protobuf rpc: CheckInvitationState(indykite.identity.v1beta2.CheckInvitationStateRequest) returns (indykite.identity.v1beta2.CheckInvitationStateResponse);
     */
    checkInvitationState(input: CheckInvitationStateRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CheckInvitationStateResponse) => void): grpc.ClientUnaryCall;
    checkInvitationState(input: CheckInvitationStateRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: CheckInvitationStateResponse) => void): grpc.ClientUnaryCall;
    checkInvitationState(input: CheckInvitationStateRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CheckInvitationStateResponse) => void): grpc.ClientUnaryCall;
    checkInvitationState(input: CheckInvitationStateRequest, callback: (err: grpc.ServiceError | null, value?: CheckInvitationStateResponse) => void): grpc.ClientUnaryCall;
    /**
     * ResendInvitation expect reference ID of invitation to send email again
     *
     * @generated from protobuf rpc: ResendInvitation(indykite.identity.v1beta2.ResendInvitationRequest) returns (indykite.identity.v1beta2.ResendInvitationResponse);
     */
    resendInvitation(input: ResendInvitationRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ResendInvitationResponse) => void): grpc.ClientUnaryCall;
    resendInvitation(input: ResendInvitationRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: ResendInvitationResponse) => void): grpc.ClientUnaryCall;
    resendInvitation(input: ResendInvitationRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ResendInvitationResponse) => void): grpc.ClientUnaryCall;
    resendInvitation(input: ResendInvitationRequest, callback: (err: grpc.ServiceError | null, value?: ResendInvitationResponse) => void): grpc.ClientUnaryCall;
    /**
     * CancelInvitation expects reference ID of invitation to cancel
     *
     * @generated from protobuf rpc: CancelInvitation(indykite.identity.v1beta2.CancelInvitationRequest) returns (indykite.identity.v1beta2.CancelInvitationResponse);
     */
    cancelInvitation(input: CancelInvitationRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CancelInvitationResponse) => void): grpc.ClientUnaryCall;
    cancelInvitation(input: CancelInvitationRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: CancelInvitationResponse) => void): grpc.ClientUnaryCall;
    cancelInvitation(input: CancelInvitationRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CancelInvitationResponse) => void): grpc.ClientUnaryCall;
    cancelInvitation(input: CancelInvitationRequest, callback: (err: grpc.ServiceError | null, value?: CancelInvitationResponse) => void): grpc.ClientUnaryCall;
    /**
     * EnrichToken allows a session and an access token to be enriched with additional data
     *
     * @generated from protobuf rpc: EnrichToken(indykite.identity.v1beta2.EnrichTokenRequest) returns (indykite.identity.v1beta2.EnrichTokenResponse);
     */
    enrichToken(input: EnrichTokenRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EnrichTokenResponse) => void): grpc.ClientUnaryCall;
    enrichToken(input: EnrichTokenRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: EnrichTokenResponse) => void): grpc.ClientUnaryCall;
    enrichToken(input: EnrichTokenRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EnrichTokenResponse) => void): grpc.ClientUnaryCall;
    enrichToken(input: EnrichTokenRequest, callback: (err: grpc.ServiceError | null, value?: EnrichTokenResponse) => void): grpc.ClientUnaryCall;
    /**
     * @generated from protobuf rpc: CreateConsent(indykite.identity.v1beta2.CreateConsentRequest) returns (indykite.identity.v1beta2.CreateConsentResponse);
     */
    createConsent(input: CreateConsentRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CreateConsentResponse) => void): grpc.ClientUnaryCall;
    createConsent(input: CreateConsentRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: CreateConsentResponse) => void): grpc.ClientUnaryCall;
    createConsent(input: CreateConsentRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CreateConsentResponse) => void): grpc.ClientUnaryCall;
    createConsent(input: CreateConsentRequest, callback: (err: grpc.ServiceError | null, value?: CreateConsentResponse) => void): grpc.ClientUnaryCall;
    /**
     * @generated from protobuf rpc: ListConsents(indykite.identity.v1beta2.ListConsentsRequest) returns (stream indykite.identity.v1beta2.ListConsentsResponse);
     */
    listConsents(input: ListConsentsRequest, metadata?: grpc.Metadata, options?: grpc.CallOptions): grpc.ClientReadableStream<ListConsentsResponse>;
    listConsents(input: ListConsentsRequest, options?: grpc.CallOptions): grpc.ClientReadableStream<ListConsentsResponse>;
    /**
     * @generated from protobuf rpc: RevokeConsent(indykite.identity.v1beta2.RevokeConsentRequest) returns (indykite.identity.v1beta2.RevokeConsentResponse);
     */
    revokeConsent(input: RevokeConsentRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: RevokeConsentResponse) => void): grpc.ClientUnaryCall;
    revokeConsent(input: RevokeConsentRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: RevokeConsentResponse) => void): grpc.ClientUnaryCall;
    revokeConsent(input: RevokeConsentRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: RevokeConsentResponse) => void): grpc.ClientUnaryCall;
    revokeConsent(input: RevokeConsentRequest, callback: (err: grpc.ServiceError | null, value?: RevokeConsentResponse) => void): grpc.ClientUnaryCall;
    // Experimental functions

    /**
     * GetPasswordCredential is Experimental and not implemented yet
     *
     * @generated from protobuf rpc: GetPasswordCredential(indykite.identity.v1beta2.GetPasswordCredentialRequest) returns (indykite.identity.v1beta2.GetPasswordCredentialResponse);
     */
    getPasswordCredential(input: GetPasswordCredentialRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetPasswordCredentialResponse) => void): grpc.ClientUnaryCall;
    getPasswordCredential(input: GetPasswordCredentialRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: GetPasswordCredentialResponse) => void): grpc.ClientUnaryCall;
    getPasswordCredential(input: GetPasswordCredentialRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetPasswordCredentialResponse) => void): grpc.ClientUnaryCall;
    getPasswordCredential(input: GetPasswordCredentialRequest, callback: (err: grpc.ServiceError | null, value?: GetPasswordCredentialResponse) => void): grpc.ClientUnaryCall;
    /**
     * GetPasswordCredential is Experimental and not implemented yet
     *
     * @generated from protobuf rpc: UpdatePasswordCredential(indykite.identity.v1beta2.UpdatePasswordCredentialRequest) returns (indykite.identity.v1beta2.UpdatePasswordCredentialResponse);
     */
    updatePasswordCredential(input: UpdatePasswordCredentialRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: UpdatePasswordCredentialResponse) => void): grpc.ClientUnaryCall;
    updatePasswordCredential(input: UpdatePasswordCredentialRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: UpdatePasswordCredentialResponse) => void): grpc.ClientUnaryCall;
    updatePasswordCredential(input: UpdatePasswordCredentialRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: UpdatePasswordCredentialResponse) => void): grpc.ClientUnaryCall;
    updatePasswordCredential(input: UpdatePasswordCredentialRequest, callback: (err: grpc.ServiceError | null, value?: UpdatePasswordCredentialResponse) => void): grpc.ClientUnaryCall;
    /**
     * GetAccessToken is Experimental and not implemented yet
     *
     * @generated from protobuf rpc: GetAccessToken(indykite.identity.v1beta2.GetAccessTokenRequest) returns (indykite.identity.v1beta2.GetAccessTokenResponse);
     */
    getAccessToken(input: GetAccessTokenRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetAccessTokenResponse) => void): grpc.ClientUnaryCall;
    getAccessToken(input: GetAccessTokenRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: GetAccessTokenResponse) => void): grpc.ClientUnaryCall;
    getAccessToken(input: GetAccessTokenRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetAccessTokenResponse) => void): grpc.ClientUnaryCall;
    getAccessToken(input: GetAccessTokenRequest, callback: (err: grpc.ServiceError | null, value?: GetAccessTokenResponse) => void): grpc.ClientUnaryCall;
    /**
     * SessionIntrospect is Experimental and not implemented yet
     *
     * @generated from protobuf rpc: SessionIntrospect(indykite.identity.v1beta2.SessionIntrospectRequest) returns (indykite.identity.v1beta2.SessionIntrospectResponse);
     */
    sessionIntrospect(input: SessionIntrospectRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: SessionIntrospectResponse) => void): grpc.ClientUnaryCall;
    sessionIntrospect(input: SessionIntrospectRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: SessionIntrospectResponse) => void): grpc.ClientUnaryCall;
    sessionIntrospect(input: SessionIntrospectRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: SessionIntrospectResponse) => void): grpc.ClientUnaryCall;
    sessionIntrospect(input: SessionIntrospectRequest, callback: (err: grpc.ServiceError | null, value?: SessionIntrospectResponse) => void): grpc.ClientUnaryCall;
    /**
     * CreateCustomLoginToken creates a signed custom authentication token with the specified user ID.
     *
     * The resulting JWT can be used in a IndyKite AuthN SDK to trigger an authentication flow. See
     * https://docs.indykite.com/sdk/authnn/create-custom-tokens#sign_in_using_custom_tokens_on_clients
     * for more details on how to use custom tokens for client authentication.
     *
     * @generated from protobuf rpc: CreateCustomLoginToken(indykite.identity.v1beta2.CreateCustomLoginTokenRequest) returns (indykite.identity.v1beta2.CreateCustomLoginTokenResponse);
     */
    createCustomLoginToken(input: CreateCustomLoginTokenRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CreateCustomLoginTokenResponse) => void): grpc.ClientUnaryCall;
    createCustomLoginToken(input: CreateCustomLoginTokenRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: CreateCustomLoginTokenResponse) => void): grpc.ClientUnaryCall;
    createCustomLoginToken(input: CreateCustomLoginTokenRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CreateCustomLoginTokenResponse) => void): grpc.ClientUnaryCall;
    createCustomLoginToken(input: CreateCustomLoginTokenRequest, callback: (err: grpc.ServiceError | null, value?: CreateCustomLoginTokenResponse) => void): grpc.ClientUnaryCall;
}
/**
 * IdentityManagementAPI represents the service interface to manage the Identities and their data.
 *
 * @generated from protobuf service indykite.identity.v1beta2.IdentityManagementAPI
 */
export class IdentityManagementAPIClient extends grpc.Client implements IIdentityManagementAPIClient {
    private readonly _binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions>;
    constructor(address: string, credentials: grpc.ChannelCredentials, options: grpc.ClientOptions = {}, binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions> = {}) {
        super(address, credentials, options);
        this._binaryOptions = binaryOptions;
    }
    /**
     * TokenIntrospect function validates the token and returns information about it.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: TokenIntrospect(indykite.identity.v1beta2.TokenIntrospectRequest) returns (indykite.identity.v1beta2.TokenIntrospectResponse);
     */
    tokenIntrospect(input: TokenIntrospectRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: TokenIntrospectResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: TokenIntrospectResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: TokenIntrospectResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[0];
        return this.makeUnaryRequest<TokenIntrospectRequest, TokenIntrospectResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: TokenIntrospectRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): TokenIntrospectResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * StartForgottenPasswordFlow function initiates the flow where systems sends a notification to DigitalTwin
     * with a link to set the new password.
     *
     * The flow checks if the DigitalTwin has primary contact information and if so it sends a message with a link.
     * By opening the link the UI SDK guides the User-Agent through the Authentication Flow where the user is
     * allowed to set a new Password credential.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: StartForgottenPasswordFlow(indykite.identity.v1beta2.StartForgottenPasswordFlowRequest) returns (indykite.identity.v1beta2.StartForgottenPasswordFlowResponse);
     */
    startForgottenPasswordFlow(input: StartForgottenPasswordFlowRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: StartForgottenPasswordFlowResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: StartForgottenPasswordFlowResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: StartForgottenPasswordFlowResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[1];
        return this.makeUnaryRequest<StartForgottenPasswordFlowRequest, StartForgottenPasswordFlowResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: StartForgottenPasswordFlowRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): StartForgottenPasswordFlowResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * ChangePassword function allows the Application to replace the Password credential of a DigitalTwin.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: ChangePassword(indykite.identity.v1beta2.ChangePasswordRequest) returns (indykite.identity.v1beta2.ChangePasswordResponse);
     */
    changePassword(input: ChangePasswordRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ChangePasswordResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ChangePasswordResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: ChangePasswordResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[2];
        return this.makeUnaryRequest<ChangePasswordRequest, ChangePasswordResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: ChangePasswordRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): ChangePasswordResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * StartDigitalTwinEmailVerification function initiates the flow where IndyKite systems sends a
     * notification to DigitalTwin with a link to verify the control over
     * the notification channel (email only for now).
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: StartDigitalTwinEmailVerification(indykite.identity.v1beta2.StartDigitalTwinEmailVerificationRequest) returns (indykite.identity.v1beta2.StartDigitalTwinEmailVerificationResponse);
     */
    startDigitalTwinEmailVerification(input: StartDigitalTwinEmailVerificationRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: StartDigitalTwinEmailVerificationResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: StartDigitalTwinEmailVerificationResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: StartDigitalTwinEmailVerificationResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[3];
        return this.makeUnaryRequest<StartDigitalTwinEmailVerificationRequest, StartDigitalTwinEmailVerificationResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: StartDigitalTwinEmailVerificationRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): StartDigitalTwinEmailVerificationResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * VerifyDigitalTwinEmail function confirms to IndyKite system that the message from
     * StartDigitalTwinEmailVerification function was sent and user visited the link.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: VerifyDigitalTwinEmail(indykite.identity.v1beta2.VerifyDigitalTwinEmailRequest) returns (indykite.identity.v1beta2.VerifyDigitalTwinEmailResponse);
     */
    verifyDigitalTwinEmail(input: VerifyDigitalTwinEmailRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: VerifyDigitalTwinEmailResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: VerifyDigitalTwinEmailResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: VerifyDigitalTwinEmailResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[4];
        return this.makeUnaryRequest<VerifyDigitalTwinEmailRequest, VerifyDigitalTwinEmailResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: VerifyDigitalTwinEmailRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): VerifyDigitalTwinEmailResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * SelfServiceTerminateSession function terminates and invalidates a login session.
     *
     * This is a protected operation and it can be accessed by both credentials,
     * with valid agent or DigitalTwin credential.
     *
     * @generated from protobuf rpc: SelfServiceTerminateSession(indykite.identity.v1beta2.SelfServiceTerminateSessionRequest) returns (indykite.identity.v1beta2.SelfServiceTerminateSessionResponse);
     */
    selfServiceTerminateSession(input: SelfServiceTerminateSessionRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: SelfServiceTerminateSessionResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: SelfServiceTerminateSessionResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: SelfServiceTerminateSessionResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[5];
        return this.makeUnaryRequest<SelfServiceTerminateSessionRequest, SelfServiceTerminateSessionResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: SelfServiceTerminateSessionRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): SelfServiceTerminateSessionResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * ImportDigitalTwins imports multiple DigitalTwin into the IndyKite database.
     *
     * No more than 1000 users can be imported in a single call.
     *
     * @generated from protobuf rpc: ImportDigitalTwins(indykite.identity.v1beta2.ImportDigitalTwinsRequest) returns (indykite.identity.v1beta2.ImportDigitalTwinsResponse);
     */
    importDigitalTwins(input: ImportDigitalTwinsRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ImportDigitalTwinsResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ImportDigitalTwinsResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: ImportDigitalTwinsResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[6];
        return this.makeUnaryRequest<ImportDigitalTwinsRequest, ImportDigitalTwinsResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: ImportDigitalTwinsRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): ImportDigitalTwinsResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetDigitalTwin gets a DigitalTwin and requested properties.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: GetDigitalTwin(indykite.identity.v1beta2.GetDigitalTwinRequest) returns (indykite.identity.v1beta2.GetDigitalTwinResponse);
     */
    getDigitalTwin(input: GetDigitalTwinRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetDigitalTwinResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetDigitalTwinResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: GetDigitalTwinResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[7];
        return this.makeUnaryRequest<GetDigitalTwinRequest, GetDigitalTwinResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: GetDigitalTwinRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): GetDigitalTwinResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * ListDigitalTwins lists DigitalTwins matching the filter.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: ListDigitalTwins(indykite.identity.v1beta2.ListDigitalTwinsRequest) returns (indykite.identity.v1beta2.ListDigitalTwinsResponse);
     */
    listDigitalTwins(input: ListDigitalTwinsRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListDigitalTwinsResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListDigitalTwinsResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: ListDigitalTwinsResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[8];
        return this.makeUnaryRequest<ListDigitalTwinsRequest, ListDigitalTwinsResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: ListDigitalTwinsRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): ListDigitalTwinsResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * RegisterDigitalTwinWithoutCredential creates a DigitalTwin without credentials, but with properties
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: RegisterDigitalTwinWithoutCredential(indykite.identity.v1beta2.RegisterDigitalTwinWithoutCredentialRequest) returns (indykite.identity.v1beta2.RegisterDigitalTwinWithoutCredentialResponse);
     */
    registerDigitalTwinWithoutCredential(input: RegisterDigitalTwinWithoutCredentialRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: RegisterDigitalTwinWithoutCredentialResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: RegisterDigitalTwinWithoutCredentialResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: RegisterDigitalTwinWithoutCredentialResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[9];
        return this.makeUnaryRequest<RegisterDigitalTwinWithoutCredentialRequest, RegisterDigitalTwinWithoutCredentialResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: RegisterDigitalTwinWithoutCredentialRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): RegisterDigitalTwinWithoutCredentialResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * PatchDigitalTwin updates the properties of a DigitalTwin.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: PatchDigitalTwin(indykite.identity.v1beta2.PatchDigitalTwinRequest) returns (indykite.identity.v1beta2.PatchDigitalTwinResponse);
     */
    patchDigitalTwin(input: PatchDigitalTwinRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: PatchDigitalTwinResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: PatchDigitalTwinResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: PatchDigitalTwinResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[10];
        return this.makeUnaryRequest<PatchDigitalTwinRequest, PatchDigitalTwinResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: PatchDigitalTwinRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): PatchDigitalTwinResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * DeleteDigitalTwin deletes the given DigitalTwin entirely from the system.
     *
     * This operation can't be restored.
     *
     * This is a protected operation and it can be accessed only with valid agent credentials!
     *
     * @generated from protobuf rpc: DeleteDigitalTwin(indykite.identity.v1beta2.DeleteDigitalTwinRequest) returns (indykite.identity.v1beta2.DeleteDigitalTwinResponse);
     */
    deleteDigitalTwin(input: DeleteDigitalTwinRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: DeleteDigitalTwinResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: DeleteDigitalTwinResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: DeleteDigitalTwinResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[11];
        return this.makeUnaryRequest<DeleteDigitalTwinRequest, DeleteDigitalTwinResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: DeleteDigitalTwinRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): DeleteDigitalTwinResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * CheckOAuth2ConsentChallenge read the Consent Challenge from DB.
     *
     * @generated from protobuf rpc: CheckOAuth2ConsentChallenge(indykite.identity.v1beta2.CheckOAuth2ConsentChallengeRequest) returns (indykite.identity.v1beta2.CheckOAuth2ConsentChallengeResponse);
     */
    checkOAuth2ConsentChallenge(input: CheckOAuth2ConsentChallengeRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CheckOAuth2ConsentChallengeResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CheckOAuth2ConsentChallengeResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: CheckOAuth2ConsentChallengeResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[12];
        return this.makeUnaryRequest<CheckOAuth2ConsentChallengeRequest, CheckOAuth2ConsentChallengeResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: CheckOAuth2ConsentChallengeRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): CheckOAuth2ConsentChallengeResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * CreateOAuth2ConsentVerifier invalidates the Consent Challenge and creates a new Consent Verifier.
     *
     * @generated from protobuf rpc: CreateOAuth2ConsentVerifier(indykite.identity.v1beta2.CreateOAuth2ConsentVerifierRequest) returns (indykite.identity.v1beta2.CreateOAuth2ConsentVerifierResponse);
     */
    createOAuth2ConsentVerifier(input: CreateOAuth2ConsentVerifierRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CreateOAuth2ConsentVerifierResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CreateOAuth2ConsentVerifierResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: CreateOAuth2ConsentVerifierResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[13];
        return this.makeUnaryRequest<CreateOAuth2ConsentVerifierRequest, CreateOAuth2ConsentVerifierResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: CreateOAuth2ConsentVerifierRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): CreateOAuth2ConsentVerifierResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * CreateInvitation will start invitation workflow
     *
     * @generated from protobuf rpc: CreateInvitation(indykite.identity.v1beta2.CreateInvitationRequest) returns (indykite.identity.v1beta2.CreateInvitationResponse);
     */
    createInvitation(input: CreateInvitationRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CreateInvitationResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CreateInvitationResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: CreateInvitationResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[14];
        return this.makeUnaryRequest<CreateInvitationRequest, CreateInvitationResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: CreateInvitationRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): CreateInvitationResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * CheckInvitationState returns state of invitation and its data
     *
     * @generated from protobuf rpc: CheckInvitationState(indykite.identity.v1beta2.CheckInvitationStateRequest) returns (indykite.identity.v1beta2.CheckInvitationStateResponse);
     */
    checkInvitationState(input: CheckInvitationStateRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CheckInvitationStateResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CheckInvitationStateResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: CheckInvitationStateResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[15];
        return this.makeUnaryRequest<CheckInvitationStateRequest, CheckInvitationStateResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: CheckInvitationStateRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): CheckInvitationStateResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * ResendInvitation expect reference ID of invitation to send email again
     *
     * @generated from protobuf rpc: ResendInvitation(indykite.identity.v1beta2.ResendInvitationRequest) returns (indykite.identity.v1beta2.ResendInvitationResponse);
     */
    resendInvitation(input: ResendInvitationRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ResendInvitationResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ResendInvitationResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: ResendInvitationResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[16];
        return this.makeUnaryRequest<ResendInvitationRequest, ResendInvitationResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: ResendInvitationRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): ResendInvitationResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * CancelInvitation expects reference ID of invitation to cancel
     *
     * @generated from protobuf rpc: CancelInvitation(indykite.identity.v1beta2.CancelInvitationRequest) returns (indykite.identity.v1beta2.CancelInvitationResponse);
     */
    cancelInvitation(input: CancelInvitationRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CancelInvitationResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CancelInvitationResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: CancelInvitationResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[17];
        return this.makeUnaryRequest<CancelInvitationRequest, CancelInvitationResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: CancelInvitationRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): CancelInvitationResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * EnrichToken allows a session and an access token to be enriched with additional data
     *
     * @generated from protobuf rpc: EnrichToken(indykite.identity.v1beta2.EnrichTokenRequest) returns (indykite.identity.v1beta2.EnrichTokenResponse);
     */
    enrichToken(input: EnrichTokenRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EnrichTokenResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EnrichTokenResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: EnrichTokenResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[18];
        return this.makeUnaryRequest<EnrichTokenRequest, EnrichTokenResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: EnrichTokenRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): EnrichTokenResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * @generated from protobuf rpc: CreateConsent(indykite.identity.v1beta2.CreateConsentRequest) returns (indykite.identity.v1beta2.CreateConsentResponse);
     */
    createConsent(input: CreateConsentRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CreateConsentResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CreateConsentResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: CreateConsentResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[19];
        return this.makeUnaryRequest<CreateConsentRequest, CreateConsentResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: CreateConsentRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): CreateConsentResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * @generated from protobuf rpc: ListConsents(indykite.identity.v1beta2.ListConsentsRequest) returns (stream indykite.identity.v1beta2.ListConsentsResponse);
     */
    listConsents(input: ListConsentsRequest, metadata?: grpc.Metadata | grpc.CallOptions, options?: grpc.CallOptions): grpc.ClientReadableStream<ListConsentsResponse> {
        const method = IdentityManagementAPI.methods[20];
        return this.makeServerStreamRequest<ListConsentsRequest, ListConsentsResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: ListConsentsRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): ListConsentsResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), options);
    }
    /**
     * @generated from protobuf rpc: RevokeConsent(indykite.identity.v1beta2.RevokeConsentRequest) returns (indykite.identity.v1beta2.RevokeConsentResponse);
     */
    revokeConsent(input: RevokeConsentRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: RevokeConsentResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: RevokeConsentResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: RevokeConsentResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[21];
        return this.makeUnaryRequest<RevokeConsentRequest, RevokeConsentResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: RevokeConsentRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): RevokeConsentResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    // Experimental functions

    /**
     * GetPasswordCredential is Experimental and not implemented yet
     *
     * @generated from protobuf rpc: GetPasswordCredential(indykite.identity.v1beta2.GetPasswordCredentialRequest) returns (indykite.identity.v1beta2.GetPasswordCredentialResponse);
     */
    getPasswordCredential(input: GetPasswordCredentialRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetPasswordCredentialResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetPasswordCredentialResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: GetPasswordCredentialResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[22];
        return this.makeUnaryRequest<GetPasswordCredentialRequest, GetPasswordCredentialResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: GetPasswordCredentialRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): GetPasswordCredentialResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetPasswordCredential is Experimental and not implemented yet
     *
     * @generated from protobuf rpc: UpdatePasswordCredential(indykite.identity.v1beta2.UpdatePasswordCredentialRequest) returns (indykite.identity.v1beta2.UpdatePasswordCredentialResponse);
     */
    updatePasswordCredential(input: UpdatePasswordCredentialRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: UpdatePasswordCredentialResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: UpdatePasswordCredentialResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: UpdatePasswordCredentialResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[23];
        return this.makeUnaryRequest<UpdatePasswordCredentialRequest, UpdatePasswordCredentialResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: UpdatePasswordCredentialRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): UpdatePasswordCredentialResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetAccessToken is Experimental and not implemented yet
     *
     * @generated from protobuf rpc: GetAccessToken(indykite.identity.v1beta2.GetAccessTokenRequest) returns (indykite.identity.v1beta2.GetAccessTokenResponse);
     */
    getAccessToken(input: GetAccessTokenRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetAccessTokenResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetAccessTokenResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: GetAccessTokenResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[24];
        return this.makeUnaryRequest<GetAccessTokenRequest, GetAccessTokenResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: GetAccessTokenRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): GetAccessTokenResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * SessionIntrospect is Experimental and not implemented yet
     *
     * @generated from protobuf rpc: SessionIntrospect(indykite.identity.v1beta2.SessionIntrospectRequest) returns (indykite.identity.v1beta2.SessionIntrospectResponse);
     */
    sessionIntrospect(input: SessionIntrospectRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: SessionIntrospectResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: SessionIntrospectResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: SessionIntrospectResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[25];
        return this.makeUnaryRequest<SessionIntrospectRequest, SessionIntrospectResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: SessionIntrospectRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): SessionIntrospectResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * CreateCustomLoginToken creates a signed custom authentication token with the specified user ID.
     *
     * The resulting JWT can be used in a IndyKite AuthN SDK to trigger an authentication flow. See
     * https://docs.indykite.com/sdk/authnn/create-custom-tokens#sign_in_using_custom_tokens_on_clients
     * for more details on how to use custom tokens for client authentication.
     *
     * @generated from protobuf rpc: CreateCustomLoginToken(indykite.identity.v1beta2.CreateCustomLoginTokenRequest) returns (indykite.identity.v1beta2.CreateCustomLoginTokenResponse);
     */
    createCustomLoginToken(input: CreateCustomLoginTokenRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CreateCustomLoginTokenResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CreateCustomLoginTokenResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: CreateCustomLoginTokenResponse) => void)): grpc.ClientUnaryCall {
        const method = IdentityManagementAPI.methods[26];
        return this.makeUnaryRequest<CreateCustomLoginTokenRequest, CreateCustomLoginTokenResponse>(`/${IdentityManagementAPI.typeName}/${method.name}`, (value: CreateCustomLoginTokenRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): CreateCustomLoginTokenResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
}
