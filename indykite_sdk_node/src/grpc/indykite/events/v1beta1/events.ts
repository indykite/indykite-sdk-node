// @generated by protobuf-ts 2.4.0 with parameter long_type_string,client_grpc1,generate_dependencies,// @generated from protobuf file "indykite/events/v1beta1/events.proto" (package "indykite.events.v1beta1", syntax proto3),// tslint:disable
//
// Copyright (c) 2020 IndyKite
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { MapValue } from "../../objects/v1beta1/struct";
import { LatLng } from "../../../google/type/latlng";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Value } from "../../objects/v1beta1/struct";
/**
 * EventContext is a generic context attached to events and holds any value.
 *
 * @generated from protobuf message indykite.events.v1beta1.EventContext
 */
export interface EventContext {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: map<string, indykite.objects.v1beta1.Value> attributes = 2;
     */
    attributes: {
        [key: string]: Value;
    };
}
/**
 * AuthenticationEvent contains the Authentication Follow lifecycle events.
 *
 * @generated from protobuf message indykite.events.v1beta1.AuthenticationEvent
 */
export interface AuthenticationEvent {
    /**
     * @generated from protobuf field: indykite.events.v1beta1.EventContext context = 1;
     */
    context?: EventContext;
    /**
     * @generated from protobuf field: indykite.events.v1beta1.LoginEventType result = 2;
     */
    result: LoginEventType;
    /**
     * @generated from protobuf field: string subject = 3;
     */
    subject: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp event_time = 4;
     */
    eventTime?: Timestamp;
    /**
     * Anonymized location of source
     *
     * @generated from protobuf field: google.type.LatLng source_position = 5;
     */
    sourcePosition?: LatLng;
}
/**
 * Email holds email name and address info.
 *
 * @generated from protobuf message indykite.events.v1beta1.Email
 */
export interface Email {
    /**
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * SendTemplateEmailEvent holds the info to send email.
 * https://sendgrid.com/docs/API_Reference/Web_API_v3/Mail/index.html
 *
 * @generated from protobuf message indykite.events.v1beta1.SendTemplateEmailEvent
 */
export interface SendTemplateEmailEvent {
    /**
     * @generated from protobuf field: string template_id = 1;
     */
    templateId: string;
    /**
     * @generated from protobuf field: indykite.events.v1beta1.Email from = 2;
     */
    from?: Email;
    /**
     * @generated from protobuf field: indykite.events.v1beta1.Email reply_to = 3;
     */
    replyTo?: Email;
    /**
     * @generated from protobuf field: repeated indykite.events.v1beta1.Email to = 4;
     */
    to: Email[];
    /**
     * @generated from protobuf field: repeated indykite.events.v1beta1.Email cc = 5;
     */
    cc: Email[];
    /**
     * @generated from protobuf field: repeated indykite.events.v1beta1.Email bcc = 6;
     */
    bcc: Email[];
    /**
     * @generated from protobuf field: string subject = 7;
     */
    subject: string;
    /**
     * @generated from protobuf field: map<string, string> headers = 8;
     */
    headers: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<string, string> custom_args = 11;
     */
    customArgs: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<string, indykite.objects.v1beta1.Value> dynamic_template_values = 12;
     */
    dynamicTemplateValues: {
        [key: string]: Value;
    };
    /**
     * @generated from protobuf field: repeated string categories = 13;
     */
    categories: string[];
    /**
     * The time of data.
     *
     * @generated from protobuf field: google.protobuf.Timestamp send_at_time = 14;
     */
    sendAtTime?: Timestamp;
    /**
     * @generated from protobuf field: string batch_id = 15;
     */
    batchId: string;
}
/**
 * SendMessageEmailEvent holds the info to send email.
 * https://sendgrid.com/docs/API_Reference/Web_API_v3/Mail/index.html
 *
 * @generated from protobuf message indykite.events.v1beta1.SendMessageEmailEvent
 */
export interface SendMessageEmailEvent {
    /**
     * @generated from protobuf field: indykite.events.v1beta1.Email from = 1;
     */
    from?: Email;
    /**
     * @generated from protobuf field: indykite.events.v1beta1.Email reply_to = 2;
     */
    replyTo?: Email;
    /**
     * @generated from protobuf field: repeated indykite.events.v1beta1.Email to = 3;
     */
    to: Email[];
    /**
     * @generated from protobuf field: repeated indykite.events.v1beta1.Email cc = 4;
     */
    cc: Email[];
    /**
     * @generated from protobuf field: repeated indykite.events.v1beta1.Email bcc = 5;
     */
    bcc: Email[];
    /**
     * @generated from protobuf field: string subject = 6;
     */
    subject: string;
    /**
     * @generated from protobuf field: string text_content = 7;
     */
    textContent: string;
    /**
     * @generated from protobuf field: string html_content = 8;
     */
    htmlContent: string;
    /**
     * @generated from protobuf field: map<string, string> headers = 9;
     */
    headers: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<string, string> custom_args = 10;
     */
    customArgs: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<string, indykite.objects.v1beta1.Value> dynamic_template_values = 11;
     */
    dynamicTemplateValues: {
        [key: string]: Value;
    };
    /**
     * @generated from protobuf field: repeated string categories = 12;
     */
    categories: string[];
    /**
     * The time of data.
     *
     * @generated from protobuf field: google.protobuf.Timestamp send_at_time = 13;
     */
    sendAtTime?: Timestamp;
    /**
     * @generated from protobuf field: string batch_id = 14;
     */
    batchId: string;
}
/**
 * OPADecisionLogEvent represents a decision log event.
 *
 * [EventV1](https://github.com/open-policy-agent/opa/blob/master/plugins/logs/plugin.go#L43)
 *
 * @generated from protobuf message indykite.events.v1beta1.OPADecisionLogEvent
 */
export interface OPADecisionLogEvent {
    /**
     * @generated from protobuf field: map<string, string> labels = 1;
     */
    labels: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: string decision_id = 2;
     */
    decisionId: string;
    /**
     * @generated from protobuf field: map<string, indykite.events.v1beta1.BundleInfoV1> bundles = 3;
     */
    bundles: {
        [key: string]: BundleInfoV1;
    };
    /**
     * @generated from protobuf field: string path = 4;
     */
    path: string;
    /**
     * @generated from protobuf field: string query = 5;
     */
    query: string;
    /**
     * @generated from protobuf field: indykite.objects.v1beta1.Value input = 6;
     */
    input?: Value;
    /**
     * @generated from protobuf field: indykite.objects.v1beta1.Value result = 7;
     */
    result?: Value;
    /**
     * @generated from protobuf field: repeated string erased = 8;
     */
    erased: string[];
    /**
     * @generated from protobuf field: repeated string masked = 9;
     */
    masked: string[];
    /**
     * @generated from protobuf field: string error = 10;
     */
    error: string;
    /**
     * @generated from protobuf field: string requested_by = 11;
     */
    requestedBy: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp at_time = 12;
     */
    atTime?: Timestamp;
    /**
     * @generated from protobuf field: indykite.objects.v1beta1.MapValue metrics = 13;
     */
    metrics?: MapValue;
}
/**
 * @generated from protobuf message indykite.events.v1beta1.BundleInfoV1
 */
export interface BundleInfoV1 {
    /**
     * @generated from protobuf field: string revision = 3;
     */
    revision: string;
}
/**
 * HTTPRequest contains data coming from the HTTP API
 *
 * @generated from protobuf message indykite.events.v1beta1.HTTPRequest
 */
export interface HTTPRequest {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
    /**
     * @generated from protobuf field: string route_key = 2;
     */
    routeKey: string;
    /**
     * @generated from protobuf field: string raw_path = 3;
     */
    rawPath: string;
    /**
     * @generated from protobuf field: string raw_query_string = 4;
     */
    rawQueryString: string;
    /**
     * @generated from protobuf field: repeated string cookies = 5;
     */
    cookies: string[];
    /**
     * @generated from protobuf field: map<string, string> headers = 6;
     */
    headers: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<string, string> query_string_parameters = 7;
     */
    queryStringParameters: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<string, string> path_parameters = 8;
     */
    pathParameters: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: indykite.events.v1beta1.HTTPRequestContext request_context = 9;
     */
    requestContext?: HTTPRequestContext;
    /**
     * @generated from protobuf field: map<string, string> stage_variables = 10;
     */
    stageVariables: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: string body = 11;
     */
    body: string;
    /**
     * @generated from protobuf field: bool is_base64_encoded = 12;
     */
    isBase64Encoded: boolean;
}
/**
 * HTTPRequestContext contains the information to identify the account and resources invoking the service.
 *
 * @generated from protobuf message indykite.events.v1beta1.HTTPRequestContext
 */
export interface HTTPRequestContext {
    /**
     * @generated from protobuf field: string route_key = 1;
     */
    routeKey: string;
    /**
     * @generated from protobuf field: string account_id = 2;
     */
    accountId: string;
    /**
     * @generated from protobuf field: string stage = 3;
     */
    stage: string;
    /**
     * @generated from protobuf field: string request_id = 4;
     */
    requestId: string;
    /**
     * @generated from protobuf field: indykite.events.v1beta1.HTTPRequestContextAuthorizerDescription authorizer = 5;
     */
    authorizer?: HTTPRequestContextAuthorizerDescription;
    /**
     * @generated from protobuf field: string domain_name = 6;
     */
    domainName: string;
    /**
     * @generated from protobuf field: string domain_prefix = 7;
     */
    domainPrefix: string;
    /**
     * @generated from protobuf field: string time = 8;
     */
    time: string;
    /**
     * @generated from protobuf field: int64 time_epoch = 9;
     */
    timeEpoch: string;
    /**
     * @generated from protobuf field: indykite.events.v1beta1.HTTPRequestContextHTTPDescription http = 10;
     */
    http?: HTTPRequestContextHTTPDescription;
}
/**
 * HTTPRequestContextAuthorizerDescription contains authorizer information for the request context.
 *
 * @generated from protobuf message indykite.events.v1beta1.HTTPRequestContextAuthorizerDescription
 */
export interface HTTPRequestContextAuthorizerDescription {
    /**
     * @generated from protobuf field: indykite.events.v1beta1.HTTPRequestContextAuthorizerJWTDescription jwt = 1;
     */
    jwt?: HTTPRequestContextAuthorizerJWTDescription;
}
/**
 * HTTPRequestContextAuthorizerJWTDescription contains JWT authorizer information for the request context.
 *
 * @generated from protobuf message indykite.events.v1beta1.HTTPRequestContextAuthorizerJWTDescription
 */
export interface HTTPRequestContextAuthorizerJWTDescription {
    /**
     * @generated from protobuf field: map<string, string> claims = 1;
     */
    claims: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: repeated string scopes = 2;
     */
    scopes: string[];
}
/**
 * HTTPRequestContextHTTPDescription contains HTTP information for the request context.
 *
 * @generated from protobuf message indykite.events.v1beta1.HTTPRequestContextHTTPDescription
 */
export interface HTTPRequestContextHTTPDescription {
    /**
     * @generated from protobuf field: indykite.events.v1beta1.HTTPMethod method = 1;
     */
    method: HTTPMethod;
    /**
     * @generated from protobuf field: string path = 2;
     */
    path: string;
    /**
     * @generated from protobuf field: indykite.events.v1beta1.HTTPProtocol protocol = 3;
     */
    protocol: HTTPProtocol;
    /**
     * @generated from protobuf field: string source_ip = 4;
     */
    sourceIp: string;
    /**
     * @generated from protobuf field: string user_agent = 5;
     */
    userAgent: string;
}
/**
 * LoginEventType defines the different login result states.
 *
 * @generated from protobuf enum indykite.events.v1beta1.LoginEventType
 */
export enum LoginEventType {
    /**
     * @generated from protobuf enum value: LOGIN_EVENT_TYPE_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: LOGIN_EVENT_TYPE_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * @generated from protobuf enum value: LOGIN_EVENT_TYPE_FAILED = 2;
     */
    FAILED = 2
}
/**
 * @generated from protobuf enum indykite.events.v1beta1.HTTPMethod
 */
export enum HTTPMethod {
    /**
     * @generated from protobuf enum value: HTTP_METHOD_INVALID = 0;
     */
    HTTP_METHOD_INVALID = 0,
    /**
     * @generated from protobuf enum value: HTTP_METHOD_GET = 1;
     */
    HTTP_METHOD_GET = 1,
    /**
     * @generated from protobuf enum value: HTTP_METHOD_HEAD = 2;
     */
    HTTP_METHOD_HEAD = 2,
    /**
     * @generated from protobuf enum value: HTTP_METHOD_POST = 3;
     */
    HTTP_METHOD_POST = 3,
    /**
     * @generated from protobuf enum value: HTTP_METHOD_PUT = 4;
     */
    HTTP_METHOD_PUT = 4,
    /**
     * @generated from protobuf enum value: HTTP_METHOD_PATCH = 5;
     */
    HTTP_METHOD_PATCH = 5,
    /**
     * @generated from protobuf enum value: HTTP_METHOD_DELETE = 6;
     */
    HTTP_METHOD_DELETE = 6,
    /**
     * @generated from protobuf enum value: HTTP_METHOD_CONNECT = 7;
     */
    HTTP_METHOD_CONNECT = 7,
    /**
     * @generated from protobuf enum value: HTTP_METHOD_OPTIONS = 8;
     */
    HTTP_METHOD_OPTIONS = 8,
    /**
     * @generated from protobuf enum value: HTTP_METHOD_TRACE = 9;
     */
    HTTP_METHOD_TRACE = 9
}
/**
 * @generated from protobuf enum indykite.events.v1beta1.HTTPProtocol
 */
export enum HTTPProtocol {
    /**
     * @generated from protobuf enum value: HTTP_PROTOCOL_INVALID = 0;
     */
    HTTP_PROTOCOL_INVALID = 0,
    /**
     * @generated from protobuf enum value: HTTP_PROTOCOL_HTTP_1_1 = 1;
     */
    HTTP_PROTOCOL_HTTP_1_1 = 1,
    /**
     * @generated from protobuf enum value: HTTP_PROTOCOL_HTTP_2_0 = 2;
     */
    HTTP_PROTOCOL_HTTP_2_0 = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class EventContext$Type extends MessageType<EventContext> {
    constructor() {
        super("indykite.events.v1beta1.EventContext", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "attributes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } }
        ]);
    }
    create(value?: PartialMessage<EventContext>): EventContext {
        const message = { id: "", attributes: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EventContext>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventContext): EventContext {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* map<string, indykite.objects.v1beta1.Value> attributes */ 2:
                    this.binaryReadMap2(message.attributes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: EventContext["attributes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EventContext["attributes"] | undefined, val: EventContext["attributes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.events.v1beta1.EventContext.attributes");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: EventContext, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* map<string, indykite.objects.v1beta1.Value> attributes = 2; */
        for (let k of Object.keys(message.attributes)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.attributes[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.events.v1beta1.EventContext
 */
export const EventContext = new EventContext$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticationEvent$Type extends MessageType<AuthenticationEvent> {
    constructor() {
        super("indykite.events.v1beta1.AuthenticationEvent", [
            { no: 1, name: "context", kind: "message", T: () => EventContext },
            { no: 2, name: "result", kind: "enum", T: () => ["indykite.events.v1beta1.LoginEventType", LoginEventType, "LOGIN_EVENT_TYPE_"] },
            { no: 3, name: "subject", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "event_time", kind: "message", T: () => Timestamp },
            { no: 5, name: "source_position", kind: "message", T: () => LatLng }
        ]);
    }
    create(value?: PartialMessage<AuthenticationEvent>): AuthenticationEvent {
        const message = { result: 0, subject: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuthenticationEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticationEvent): AuthenticationEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.events.v1beta1.EventContext context */ 1:
                    message.context = EventContext.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* indykite.events.v1beta1.LoginEventType result */ 2:
                    message.result = reader.int32();
                    break;
                case /* string subject */ 3:
                    message.subject = reader.string();
                    break;
                case /* google.protobuf.Timestamp event_time */ 4:
                    message.eventTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.eventTime);
                    break;
                case /* google.type.LatLng source_position */ 5:
                    message.sourcePosition = LatLng.internalBinaryRead(reader, reader.uint32(), options, message.sourcePosition);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticationEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.events.v1beta1.EventContext context = 1; */
        if (message.context)
            EventContext.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* indykite.events.v1beta1.LoginEventType result = 2; */
        if (message.result !== 0)
            writer.tag(2, WireType.Varint).int32(message.result);
        /* string subject = 3; */
        if (message.subject !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subject);
        /* google.protobuf.Timestamp event_time = 4; */
        if (message.eventTime)
            Timestamp.internalBinaryWrite(message.eventTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.type.LatLng source_position = 5; */
        if (message.sourcePosition)
            LatLng.internalBinaryWrite(message.sourcePosition, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.events.v1beta1.AuthenticationEvent
 */
export const AuthenticationEvent = new AuthenticationEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Email$Type extends MessageType<Email> {
    constructor() {
        super("indykite.events.v1beta1.Email", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Email>): Email {
        const message = { address: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Email>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Email): Email {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Email, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.events.v1beta1.Email
 */
export const Email = new Email$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendTemplateEmailEvent$Type extends MessageType<SendTemplateEmailEvent> {
    constructor() {
        super("indykite.events.v1beta1.SendTemplateEmailEvent", [
            { no: 1, name: "template_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from", kind: "message", T: () => Email },
            { no: 3, name: "reply_to", kind: "message", T: () => Email },
            { no: 4, name: "to", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Email },
            { no: 5, name: "cc", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Email },
            { no: 6, name: "bcc", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Email },
            { no: 7, name: "subject", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "headers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 11, name: "custom_args", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 12, name: "dynamic_template_values", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } },
            { no: 13, name: "categories", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "send_at_time", kind: "message", T: () => Timestamp },
            { no: 15, name: "batch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SendTemplateEmailEvent>): SendTemplateEmailEvent {
        const message = { templateId: "", to: [], cc: [], bcc: [], subject: "", headers: {}, customArgs: {}, dynamicTemplateValues: {}, categories: [], batchId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendTemplateEmailEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendTemplateEmailEvent): SendTemplateEmailEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string template_id */ 1:
                    message.templateId = reader.string();
                    break;
                case /* indykite.events.v1beta1.Email from */ 2:
                    message.from = Email.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* indykite.events.v1beta1.Email reply_to */ 3:
                    message.replyTo = Email.internalBinaryRead(reader, reader.uint32(), options, message.replyTo);
                    break;
                case /* repeated indykite.events.v1beta1.Email to */ 4:
                    message.to.push(Email.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated indykite.events.v1beta1.Email cc */ 5:
                    message.cc.push(Email.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated indykite.events.v1beta1.Email bcc */ 6:
                    message.bcc.push(Email.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string subject */ 7:
                    message.subject = reader.string();
                    break;
                case /* map<string, string> headers */ 8:
                    this.binaryReadMap8(message.headers, reader, options);
                    break;
                case /* map<string, string> custom_args */ 11:
                    this.binaryReadMap11(message.customArgs, reader, options);
                    break;
                case /* map<string, indykite.objects.v1beta1.Value> dynamic_template_values */ 12:
                    this.binaryReadMap12(message.dynamicTemplateValues, reader, options);
                    break;
                case /* repeated string categories */ 13:
                    message.categories.push(reader.string());
                    break;
                case /* google.protobuf.Timestamp send_at_time */ 14:
                    message.sendAtTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.sendAtTime);
                    break;
                case /* string batch_id */ 15:
                    message.batchId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: SendTemplateEmailEvent["headers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SendTemplateEmailEvent["headers"] | undefined, val: SendTemplateEmailEvent["headers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.events.v1beta1.SendTemplateEmailEvent.headers");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap11(map: SendTemplateEmailEvent["customArgs"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SendTemplateEmailEvent["customArgs"] | undefined, val: SendTemplateEmailEvent["customArgs"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.events.v1beta1.SendTemplateEmailEvent.custom_args");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap12(map: SendTemplateEmailEvent["dynamicTemplateValues"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SendTemplateEmailEvent["dynamicTemplateValues"] | undefined, val: SendTemplateEmailEvent["dynamicTemplateValues"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.events.v1beta1.SendTemplateEmailEvent.dynamic_template_values");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: SendTemplateEmailEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string template_id = 1; */
        if (message.templateId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.templateId);
        /* indykite.events.v1beta1.Email from = 2; */
        if (message.from)
            Email.internalBinaryWrite(message.from, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* indykite.events.v1beta1.Email reply_to = 3; */
        if (message.replyTo)
            Email.internalBinaryWrite(message.replyTo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated indykite.events.v1beta1.Email to = 4; */
        for (let i = 0; i < message.to.length; i++)
            Email.internalBinaryWrite(message.to[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated indykite.events.v1beta1.Email cc = 5; */
        for (let i = 0; i < message.cc.length; i++)
            Email.internalBinaryWrite(message.cc[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated indykite.events.v1beta1.Email bcc = 6; */
        for (let i = 0; i < message.bcc.length; i++)
            Email.internalBinaryWrite(message.bcc[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string subject = 7; */
        if (message.subject !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.subject);
        /* map<string, string> headers = 8; */
        for (let k of Object.keys(message.headers))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.headers[k]).join();
        /* map<string, string> custom_args = 11; */
        for (let k of Object.keys(message.customArgs))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.customArgs[k]).join();
        /* map<string, indykite.objects.v1beta1.Value> dynamic_template_values = 12; */
        for (let k of Object.keys(message.dynamicTemplateValues)) {
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.dynamicTemplateValues[k], writer, options);
            writer.join().join();
        }
        /* repeated string categories = 13; */
        for (let i = 0; i < message.categories.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.categories[i]);
        /* google.protobuf.Timestamp send_at_time = 14; */
        if (message.sendAtTime)
            Timestamp.internalBinaryWrite(message.sendAtTime, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* string batch_id = 15; */
        if (message.batchId !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.batchId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.events.v1beta1.SendTemplateEmailEvent
 */
export const SendTemplateEmailEvent = new SendTemplateEmailEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendMessageEmailEvent$Type extends MessageType<SendMessageEmailEvent> {
    constructor() {
        super("indykite.events.v1beta1.SendMessageEmailEvent", [
            { no: 1, name: "from", kind: "message", T: () => Email },
            { no: 2, name: "reply_to", kind: "message", T: () => Email },
            { no: 3, name: "to", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Email },
            { no: 4, name: "cc", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Email },
            { no: 5, name: "bcc", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Email },
            { no: 6, name: "subject", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "text_content", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "html_content", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "headers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 10, name: "custom_args", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 11, name: "dynamic_template_values", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } },
            { no: 12, name: "categories", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "send_at_time", kind: "message", T: () => Timestamp },
            { no: 14, name: "batch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SendMessageEmailEvent>): SendMessageEmailEvent {
        const message = { to: [], cc: [], bcc: [], subject: "", textContent: "", htmlContent: "", headers: {}, customArgs: {}, dynamicTemplateValues: {}, categories: [], batchId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendMessageEmailEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendMessageEmailEvent): SendMessageEmailEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.events.v1beta1.Email from */ 1:
                    message.from = Email.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* indykite.events.v1beta1.Email reply_to */ 2:
                    message.replyTo = Email.internalBinaryRead(reader, reader.uint32(), options, message.replyTo);
                    break;
                case /* repeated indykite.events.v1beta1.Email to */ 3:
                    message.to.push(Email.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated indykite.events.v1beta1.Email cc */ 4:
                    message.cc.push(Email.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated indykite.events.v1beta1.Email bcc */ 5:
                    message.bcc.push(Email.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string subject */ 6:
                    message.subject = reader.string();
                    break;
                case /* string text_content */ 7:
                    message.textContent = reader.string();
                    break;
                case /* string html_content */ 8:
                    message.htmlContent = reader.string();
                    break;
                case /* map<string, string> headers */ 9:
                    this.binaryReadMap9(message.headers, reader, options);
                    break;
                case /* map<string, string> custom_args */ 10:
                    this.binaryReadMap10(message.customArgs, reader, options);
                    break;
                case /* map<string, indykite.objects.v1beta1.Value> dynamic_template_values */ 11:
                    this.binaryReadMap11(message.dynamicTemplateValues, reader, options);
                    break;
                case /* repeated string categories */ 12:
                    message.categories.push(reader.string());
                    break;
                case /* google.protobuf.Timestamp send_at_time */ 13:
                    message.sendAtTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.sendAtTime);
                    break;
                case /* string batch_id */ 14:
                    message.batchId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: SendMessageEmailEvent["headers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SendMessageEmailEvent["headers"] | undefined, val: SendMessageEmailEvent["headers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.events.v1beta1.SendMessageEmailEvent.headers");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap10(map: SendMessageEmailEvent["customArgs"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SendMessageEmailEvent["customArgs"] | undefined, val: SendMessageEmailEvent["customArgs"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.events.v1beta1.SendMessageEmailEvent.custom_args");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap11(map: SendMessageEmailEvent["dynamicTemplateValues"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SendMessageEmailEvent["dynamicTemplateValues"] | undefined, val: SendMessageEmailEvent["dynamicTemplateValues"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.events.v1beta1.SendMessageEmailEvent.dynamic_template_values");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: SendMessageEmailEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.events.v1beta1.Email from = 1; */
        if (message.from)
            Email.internalBinaryWrite(message.from, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* indykite.events.v1beta1.Email reply_to = 2; */
        if (message.replyTo)
            Email.internalBinaryWrite(message.replyTo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated indykite.events.v1beta1.Email to = 3; */
        for (let i = 0; i < message.to.length; i++)
            Email.internalBinaryWrite(message.to[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated indykite.events.v1beta1.Email cc = 4; */
        for (let i = 0; i < message.cc.length; i++)
            Email.internalBinaryWrite(message.cc[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated indykite.events.v1beta1.Email bcc = 5; */
        for (let i = 0; i < message.bcc.length; i++)
            Email.internalBinaryWrite(message.bcc[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string subject = 6; */
        if (message.subject !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.subject);
        /* string text_content = 7; */
        if (message.textContent !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.textContent);
        /* string html_content = 8; */
        if (message.htmlContent !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.htmlContent);
        /* map<string, string> headers = 9; */
        for (let k of Object.keys(message.headers))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.headers[k]).join();
        /* map<string, string> custom_args = 10; */
        for (let k of Object.keys(message.customArgs))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.customArgs[k]).join();
        /* map<string, indykite.objects.v1beta1.Value> dynamic_template_values = 11; */
        for (let k of Object.keys(message.dynamicTemplateValues)) {
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.dynamicTemplateValues[k], writer, options);
            writer.join().join();
        }
        /* repeated string categories = 12; */
        for (let i = 0; i < message.categories.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.categories[i]);
        /* google.protobuf.Timestamp send_at_time = 13; */
        if (message.sendAtTime)
            Timestamp.internalBinaryWrite(message.sendAtTime, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* string batch_id = 14; */
        if (message.batchId !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.batchId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.events.v1beta1.SendMessageEmailEvent
 */
export const SendMessageEmailEvent = new SendMessageEmailEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OPADecisionLogEvent$Type extends MessageType<OPADecisionLogEvent> {
    constructor() {
        super("indykite.events.v1beta1.OPADecisionLogEvent", [
            { no: 1, name: "labels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 2, name: "decision_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "bundles", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => BundleInfoV1 } },
            { no: 4, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "input", kind: "message", T: () => Value },
            { no: 7, name: "result", kind: "message", T: () => Value },
            { no: 8, name: "erased", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "masked", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "requested_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "at_time", kind: "message", T: () => Timestamp },
            { no: 13, name: "metrics", kind: "message", T: () => MapValue }
        ]);
    }
    create(value?: PartialMessage<OPADecisionLogEvent>): OPADecisionLogEvent {
        const message = { labels: {}, decisionId: "", bundles: {}, path: "", query: "", erased: [], masked: [], error: "", requestedBy: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OPADecisionLogEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OPADecisionLogEvent): OPADecisionLogEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> labels */ 1:
                    this.binaryReadMap1(message.labels, reader, options);
                    break;
                case /* string decision_id */ 2:
                    message.decisionId = reader.string();
                    break;
                case /* map<string, indykite.events.v1beta1.BundleInfoV1> bundles */ 3:
                    this.binaryReadMap3(message.bundles, reader, options);
                    break;
                case /* string path */ 4:
                    message.path = reader.string();
                    break;
                case /* string query */ 5:
                    message.query = reader.string();
                    break;
                case /* indykite.objects.v1beta1.Value input */ 6:
                    message.input = Value.internalBinaryRead(reader, reader.uint32(), options, message.input);
                    break;
                case /* indykite.objects.v1beta1.Value result */ 7:
                    message.result = Value.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* repeated string erased */ 8:
                    message.erased.push(reader.string());
                    break;
                case /* repeated string masked */ 9:
                    message.masked.push(reader.string());
                    break;
                case /* string error */ 10:
                    message.error = reader.string();
                    break;
                case /* string requested_by */ 11:
                    message.requestedBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp at_time */ 12:
                    message.atTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.atTime);
                    break;
                case /* indykite.objects.v1beta1.MapValue metrics */ 13:
                    message.metrics = MapValue.internalBinaryRead(reader, reader.uint32(), options, message.metrics);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: OPADecisionLogEvent["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof OPADecisionLogEvent["labels"] | undefined, val: OPADecisionLogEvent["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.events.v1beta1.OPADecisionLogEvent.labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap3(map: OPADecisionLogEvent["bundles"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof OPADecisionLogEvent["bundles"] | undefined, val: OPADecisionLogEvent["bundles"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = BundleInfoV1.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.events.v1beta1.OPADecisionLogEvent.bundles");
            }
        }
        map[key ?? ""] = val ?? BundleInfoV1.create();
    }
    internalBinaryWrite(message: OPADecisionLogEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> labels = 1; */
        for (let k of Object.keys(message.labels))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        /* string decision_id = 2; */
        if (message.decisionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.decisionId);
        /* map<string, indykite.events.v1beta1.BundleInfoV1> bundles = 3; */
        for (let k of Object.keys(message.bundles)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            BundleInfoV1.internalBinaryWrite(message.bundles[k], writer, options);
            writer.join().join();
        }
        /* string path = 4; */
        if (message.path !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.path);
        /* string query = 5; */
        if (message.query !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.query);
        /* indykite.objects.v1beta1.Value input = 6; */
        if (message.input)
            Value.internalBinaryWrite(message.input, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* indykite.objects.v1beta1.Value result = 7; */
        if (message.result)
            Value.internalBinaryWrite(message.result, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated string erased = 8; */
        for (let i = 0; i < message.erased.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.erased[i]);
        /* repeated string masked = 9; */
        for (let i = 0; i < message.masked.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.masked[i]);
        /* string error = 10; */
        if (message.error !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.error);
        /* string requested_by = 11; */
        if (message.requestedBy !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.requestedBy);
        /* google.protobuf.Timestamp at_time = 12; */
        if (message.atTime)
            Timestamp.internalBinaryWrite(message.atTime, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* indykite.objects.v1beta1.MapValue metrics = 13; */
        if (message.metrics)
            MapValue.internalBinaryWrite(message.metrics, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.events.v1beta1.OPADecisionLogEvent
 */
export const OPADecisionLogEvent = new OPADecisionLogEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BundleInfoV1$Type extends MessageType<BundleInfoV1> {
    constructor() {
        super("indykite.events.v1beta1.BundleInfoV1", [
            { no: 3, name: "revision", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BundleInfoV1>): BundleInfoV1 {
        const message = { revision: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BundleInfoV1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BundleInfoV1): BundleInfoV1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string revision */ 3:
                    message.revision = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BundleInfoV1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string revision = 3; */
        if (message.revision !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.revision);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.events.v1beta1.BundleInfoV1
 */
export const BundleInfoV1 = new BundleInfoV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HTTPRequest$Type extends MessageType<HTTPRequest> {
    constructor() {
        super("indykite.events.v1beta1.HTTPRequest", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "route_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "raw_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "raw_query_string", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "cookies", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "headers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 7, name: "query_string_parameters", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 8, name: "path_parameters", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 9, name: "request_context", kind: "message", T: () => HTTPRequestContext },
            { no: 10, name: "stage_variables", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 11, name: "body", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "is_base64_encoded", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HTTPRequest>): HTTPRequest {
        const message = { version: "", routeKey: "", rawPath: "", rawQueryString: "", cookies: [], headers: {}, queryStringParameters: {}, pathParameters: {}, stageVariables: {}, body: "", isBase64Encoded: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HTTPRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HTTPRequest): HTTPRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* string route_key */ 2:
                    message.routeKey = reader.string();
                    break;
                case /* string raw_path */ 3:
                    message.rawPath = reader.string();
                    break;
                case /* string raw_query_string */ 4:
                    message.rawQueryString = reader.string();
                    break;
                case /* repeated string cookies */ 5:
                    message.cookies.push(reader.string());
                    break;
                case /* map<string, string> headers */ 6:
                    this.binaryReadMap6(message.headers, reader, options);
                    break;
                case /* map<string, string> query_string_parameters */ 7:
                    this.binaryReadMap7(message.queryStringParameters, reader, options);
                    break;
                case /* map<string, string> path_parameters */ 8:
                    this.binaryReadMap8(message.pathParameters, reader, options);
                    break;
                case /* indykite.events.v1beta1.HTTPRequestContext request_context */ 9:
                    message.requestContext = HTTPRequestContext.internalBinaryRead(reader, reader.uint32(), options, message.requestContext);
                    break;
                case /* map<string, string> stage_variables */ 10:
                    this.binaryReadMap10(message.stageVariables, reader, options);
                    break;
                case /* string body */ 11:
                    message.body = reader.string();
                    break;
                case /* bool is_base64_encoded */ 12:
                    message.isBase64Encoded = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: HTTPRequest["headers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof HTTPRequest["headers"] | undefined, val: HTTPRequest["headers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.events.v1beta1.HTTPRequest.headers");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap7(map: HTTPRequest["queryStringParameters"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof HTTPRequest["queryStringParameters"] | undefined, val: HTTPRequest["queryStringParameters"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.events.v1beta1.HTTPRequest.query_string_parameters");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap8(map: HTTPRequest["pathParameters"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof HTTPRequest["pathParameters"] | undefined, val: HTTPRequest["pathParameters"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.events.v1beta1.HTTPRequest.path_parameters");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap10(map: HTTPRequest["stageVariables"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof HTTPRequest["stageVariables"] | undefined, val: HTTPRequest["stageVariables"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.events.v1beta1.HTTPRequest.stage_variables");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: HTTPRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* string route_key = 2; */
        if (message.routeKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.routeKey);
        /* string raw_path = 3; */
        if (message.rawPath !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.rawPath);
        /* string raw_query_string = 4; */
        if (message.rawQueryString !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.rawQueryString);
        /* repeated string cookies = 5; */
        for (let i = 0; i < message.cookies.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.cookies[i]);
        /* map<string, string> headers = 6; */
        for (let k of Object.keys(message.headers))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.headers[k]).join();
        /* map<string, string> query_string_parameters = 7; */
        for (let k of Object.keys(message.queryStringParameters))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.queryStringParameters[k]).join();
        /* map<string, string> path_parameters = 8; */
        for (let k of Object.keys(message.pathParameters))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.pathParameters[k]).join();
        /* indykite.events.v1beta1.HTTPRequestContext request_context = 9; */
        if (message.requestContext)
            HTTPRequestContext.internalBinaryWrite(message.requestContext, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> stage_variables = 10; */
        for (let k of Object.keys(message.stageVariables))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.stageVariables[k]).join();
        /* string body = 11; */
        if (message.body !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.body);
        /* bool is_base64_encoded = 12; */
        if (message.isBase64Encoded !== false)
            writer.tag(12, WireType.Varint).bool(message.isBase64Encoded);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.events.v1beta1.HTTPRequest
 */
export const HTTPRequest = new HTTPRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HTTPRequestContext$Type extends MessageType<HTTPRequestContext> {
    constructor() {
        super("indykite.events.v1beta1.HTTPRequestContext", [
            { no: 1, name: "route_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "stage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "authorizer", kind: "message", T: () => HTTPRequestContextAuthorizerDescription },
            { no: 6, name: "domain_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "domain_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "time_epoch", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 10, name: "http", kind: "message", T: () => HTTPRequestContextHTTPDescription }
        ]);
    }
    create(value?: PartialMessage<HTTPRequestContext>): HTTPRequestContext {
        const message = { routeKey: "", accountId: "", stage: "", requestId: "", domainName: "", domainPrefix: "", time: "", timeEpoch: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HTTPRequestContext>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HTTPRequestContext): HTTPRequestContext {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string route_key */ 1:
                    message.routeKey = reader.string();
                    break;
                case /* string account_id */ 2:
                    message.accountId = reader.string();
                    break;
                case /* string stage */ 3:
                    message.stage = reader.string();
                    break;
                case /* string request_id */ 4:
                    message.requestId = reader.string();
                    break;
                case /* indykite.events.v1beta1.HTTPRequestContextAuthorizerDescription authorizer */ 5:
                    message.authorizer = HTTPRequestContextAuthorizerDescription.internalBinaryRead(reader, reader.uint32(), options, message.authorizer);
                    break;
                case /* string domain_name */ 6:
                    message.domainName = reader.string();
                    break;
                case /* string domain_prefix */ 7:
                    message.domainPrefix = reader.string();
                    break;
                case /* string time */ 8:
                    message.time = reader.string();
                    break;
                case /* int64 time_epoch */ 9:
                    message.timeEpoch = reader.int64().toString();
                    break;
                case /* indykite.events.v1beta1.HTTPRequestContextHTTPDescription http */ 10:
                    message.http = HTTPRequestContextHTTPDescription.internalBinaryRead(reader, reader.uint32(), options, message.http);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HTTPRequestContext, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string route_key = 1; */
        if (message.routeKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.routeKey);
        /* string account_id = 2; */
        if (message.accountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountId);
        /* string stage = 3; */
        if (message.stage !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.stage);
        /* string request_id = 4; */
        if (message.requestId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.requestId);
        /* indykite.events.v1beta1.HTTPRequestContextAuthorizerDescription authorizer = 5; */
        if (message.authorizer)
            HTTPRequestContextAuthorizerDescription.internalBinaryWrite(message.authorizer, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string domain_name = 6; */
        if (message.domainName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.domainName);
        /* string domain_prefix = 7; */
        if (message.domainPrefix !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.domainPrefix);
        /* string time = 8; */
        if (message.time !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.time);
        /* int64 time_epoch = 9; */
        if (message.timeEpoch !== "0")
            writer.tag(9, WireType.Varint).int64(message.timeEpoch);
        /* indykite.events.v1beta1.HTTPRequestContextHTTPDescription http = 10; */
        if (message.http)
            HTTPRequestContextHTTPDescription.internalBinaryWrite(message.http, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.events.v1beta1.HTTPRequestContext
 */
export const HTTPRequestContext = new HTTPRequestContext$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HTTPRequestContextAuthorizerDescription$Type extends MessageType<HTTPRequestContextAuthorizerDescription> {
    constructor() {
        super("indykite.events.v1beta1.HTTPRequestContextAuthorizerDescription", [
            { no: 1, name: "jwt", kind: "message", T: () => HTTPRequestContextAuthorizerJWTDescription }
        ]);
    }
    create(value?: PartialMessage<HTTPRequestContextAuthorizerDescription>): HTTPRequestContextAuthorizerDescription {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HTTPRequestContextAuthorizerDescription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HTTPRequestContextAuthorizerDescription): HTTPRequestContextAuthorizerDescription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.events.v1beta1.HTTPRequestContextAuthorizerJWTDescription jwt */ 1:
                    message.jwt = HTTPRequestContextAuthorizerJWTDescription.internalBinaryRead(reader, reader.uint32(), options, message.jwt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HTTPRequestContextAuthorizerDescription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.events.v1beta1.HTTPRequestContextAuthorizerJWTDescription jwt = 1; */
        if (message.jwt)
            HTTPRequestContextAuthorizerJWTDescription.internalBinaryWrite(message.jwt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.events.v1beta1.HTTPRequestContextAuthorizerDescription
 */
export const HTTPRequestContextAuthorizerDescription = new HTTPRequestContextAuthorizerDescription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HTTPRequestContextAuthorizerJWTDescription$Type extends MessageType<HTTPRequestContextAuthorizerJWTDescription> {
    constructor() {
        super("indykite.events.v1beta1.HTTPRequestContextAuthorizerJWTDescription", [
            { no: 1, name: "claims", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 2, name: "scopes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HTTPRequestContextAuthorizerJWTDescription>): HTTPRequestContextAuthorizerJWTDescription {
        const message = { claims: {}, scopes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HTTPRequestContextAuthorizerJWTDescription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HTTPRequestContextAuthorizerJWTDescription): HTTPRequestContextAuthorizerJWTDescription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> claims */ 1:
                    this.binaryReadMap1(message.claims, reader, options);
                    break;
                case /* repeated string scopes */ 2:
                    message.scopes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: HTTPRequestContextAuthorizerJWTDescription["claims"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof HTTPRequestContextAuthorizerJWTDescription["claims"] | undefined, val: HTTPRequestContextAuthorizerJWTDescription["claims"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field indykite.events.v1beta1.HTTPRequestContextAuthorizerJWTDescription.claims");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: HTTPRequestContextAuthorizerJWTDescription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> claims = 1; */
        for (let k of Object.keys(message.claims))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.claims[k]).join();
        /* repeated string scopes = 2; */
        for (let i = 0; i < message.scopes.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.scopes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.events.v1beta1.HTTPRequestContextAuthorizerJWTDescription
 */
export const HTTPRequestContextAuthorizerJWTDescription = new HTTPRequestContextAuthorizerJWTDescription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HTTPRequestContextHTTPDescription$Type extends MessageType<HTTPRequestContextHTTPDescription> {
    constructor() {
        super("indykite.events.v1beta1.HTTPRequestContextHTTPDescription", [
            { no: 1, name: "method", kind: "enum", T: () => ["indykite.events.v1beta1.HTTPMethod", HTTPMethod] },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "protocol", kind: "enum", T: () => ["indykite.events.v1beta1.HTTPProtocol", HTTPProtocol] },
            { no: 4, name: "source_ip", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "user_agent", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HTTPRequestContextHTTPDescription>): HTTPRequestContextHTTPDescription {
        const message = { method: 0, path: "", protocol: 0, sourceIp: "", userAgent: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HTTPRequestContextHTTPDescription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HTTPRequestContextHTTPDescription): HTTPRequestContextHTTPDescription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* indykite.events.v1beta1.HTTPMethod method */ 1:
                    message.method = reader.int32();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* indykite.events.v1beta1.HTTPProtocol protocol */ 3:
                    message.protocol = reader.int32();
                    break;
                case /* string source_ip */ 4:
                    message.sourceIp = reader.string();
                    break;
                case /* string user_agent */ 5:
                    message.userAgent = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HTTPRequestContextHTTPDescription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* indykite.events.v1beta1.HTTPMethod method = 1; */
        if (message.method !== 0)
            writer.tag(1, WireType.Varint).int32(message.method);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* indykite.events.v1beta1.HTTPProtocol protocol = 3; */
        if (message.protocol !== 0)
            writer.tag(3, WireType.Varint).int32(message.protocol);
        /* string source_ip = 4; */
        if (message.sourceIp !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.sourceIp);
        /* string user_agent = 5; */
        if (message.userAgent !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.userAgent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message indykite.events.v1beta1.HTTPRequestContextHTTPDescription
 */
export const HTTPRequestContextHTTPDescription = new HTTPRequestContextHTTPDescription$Type();
