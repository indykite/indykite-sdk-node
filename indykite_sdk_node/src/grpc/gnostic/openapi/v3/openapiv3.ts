// @generated by protobuf-ts 2.9.0 with parameter long_type_string,client_grpc1,generate_dependencies
// @generated from protobuf file "gnostic/openapi/v3/openapiv3.proto" (package "gnostic.openapi.v3", syntax proto3)
// tslint:disable
//
// Copyright 2020 Google LLC. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// THIS FILE IS AUTOMATICALLY GENERATED.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Any as Any$ } from "../../../google/protobuf/any";
/**
 * @generated from protobuf message gnostic.openapi.v3.AdditionalPropertiesItem
 */
export interface AdditionalPropertiesItem {
    /**
     * @generated from protobuf oneof: oneof
     */
    oneof: {
        oneofKind: "schemaOrReference";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1;
         */
        schemaOrReference: SchemaOrReference;
    } | {
        oneofKind: "boolean";
        /**
         * @generated from protobuf field: bool boolean = 2;
         */
        boolean: boolean;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message gnostic.openapi.v3.Any
 */
export interface Any {
    /**
     * @generated from protobuf field: google.protobuf.Any value = 1;
     */
    value?: Any$;
    /**
     * @generated from protobuf field: string yaml = 2;
     */
    yaml: string;
}
/**
 * @generated from protobuf message gnostic.openapi.v3.AnyOrExpression
 */
export interface AnyOrExpression {
    /**
     * @generated from protobuf oneof: oneof
     */
    oneof: {
        oneofKind: "any";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Any any = 1;
         */
        any: Any;
    } | {
        oneofKind: "expression";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Expression expression = 2;
         */
        expression: Expression;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A map of possible out-of band callbacks related to the parent operation. Each value in the map is a Path Item Object that describes a set of requests that may be initiated by the API provider and the expected responses. The key value used to identify the callback object is an expression, evaluated at runtime, that identifies a URL to use for the callback operation.
 *
 * @generated from protobuf message gnostic.openapi.v3.Callback
 */
export interface Callback {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedPathItem path = 1;
     */
    path: NamedPathItem[];
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 2;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.CallbackOrReference
 */
export interface CallbackOrReference {
    /**
     * @generated from protobuf oneof: oneof
     */
    oneof: {
        oneofKind: "callback";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Callback callback = 1;
         */
        callback: Callback;
    } | {
        oneofKind: "reference";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Reference reference = 2;
         */
        reference: Reference;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message gnostic.openapi.v3.CallbacksOrReferences
 */
export interface CallbacksOrReferences {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedCallbackOrReference additional_properties = 1;
     */
    additionalProperties: NamedCallbackOrReference[];
}
/**
 * Holds a set of reusable objects for different aspects of the OAS. All objects defined within the components object will have no effect on the API unless they are explicitly referenced from properties outside the components object.
 *
 * @generated from protobuf message gnostic.openapi.v3.Components
 */
export interface Components {
    /**
     * @generated from protobuf field: gnostic.openapi.v3.SchemasOrReferences schemas = 1;
     */
    schemas?: SchemasOrReferences;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.ResponsesOrReferences responses = 2;
     */
    responses?: ResponsesOrReferences;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.ParametersOrReferences parameters = 3;
     */
    parameters?: ParametersOrReferences;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.ExamplesOrReferences examples = 4;
     */
    examples?: ExamplesOrReferences;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.RequestBodiesOrReferences request_bodies = 5;
     */
    requestBodies?: RequestBodiesOrReferences;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.HeadersOrReferences headers = 6;
     */
    headers?: HeadersOrReferences;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.SecuritySchemesOrReferences security_schemes = 7;
     */
    securitySchemes?: SecuritySchemesOrReferences;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.LinksOrReferences links = 8;
     */
    links?: LinksOrReferences;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.CallbacksOrReferences callbacks = 9;
     */
    callbacks?: CallbacksOrReferences;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 10;
     */
    specificationExtension: NamedAny[];
}
/**
 * Contact information for the exposed API.
 *
 * @generated from protobuf message gnostic.openapi.v3.Contact
 */
export interface Contact {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string url = 2;
     */
    url: string;
    /**
     * @generated from protobuf field: string email = 3;
     */
    email: string;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 4;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.DefaultType
 */
export interface DefaultType {
    /**
     * @generated from protobuf oneof: oneof
     */
    oneof: {
        oneofKind: "number";
        /**
         * @generated from protobuf field: double number = 1;
         */
        number: number;
    } | {
        oneofKind: "boolean";
        /**
         * @generated from protobuf field: bool boolean = 2;
         */
        boolean: boolean;
    } | {
        oneofKind: "string";
        /**
         * @generated from protobuf field: string string = 3;
         */
        string: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * When request bodies or response payloads may be one of a number of different schemas, a `discriminator` object can be used to aid in serialization, deserialization, and validation.  The discriminator is a specific object in a schema which is used to inform the consumer of the specification of an alternative schema based on the value associated with it.  When using the discriminator, _inline_ schemas will not be considered.
 *
 * @generated from protobuf message gnostic.openapi.v3.Discriminator
 */
export interface Discriminator {
    /**
     * @generated from protobuf field: string property_name = 1;
     */
    propertyName: string;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Strings mapping = 2;
     */
    mapping?: Strings;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 3;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.Document
 */
export interface Document {
    /**
     * @generated from protobuf field: string openapi = 1;
     */
    openapi: string;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Info info = 2;
     */
    info?: Info;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.Server servers = 3;
     */
    servers: Server[];
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Paths paths = 4;
     */
    paths?: Paths;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Components components = 5;
     */
    components?: Components;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.SecurityRequirement security = 6;
     */
    security: SecurityRequirement[];
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.Tag tags = 7;
     */
    tags: Tag[];
    /**
     * @generated from protobuf field: gnostic.openapi.v3.ExternalDocs external_docs = 8;
     */
    externalDocs?: ExternalDocs;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 9;
     */
    specificationExtension: NamedAny[];
}
/**
 * A single encoding definition applied to a single schema property.
 *
 * @generated from protobuf message gnostic.openapi.v3.Encoding
 */
export interface Encoding {
    /**
     * @generated from protobuf field: string content_type = 1;
     */
    contentType: string;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.HeadersOrReferences headers = 2;
     */
    headers?: HeadersOrReferences;
    /**
     * @generated from protobuf field: string style = 3;
     */
    style: string;
    /**
     * @generated from protobuf field: bool explode = 4;
     */
    explode: boolean;
    /**
     * @generated from protobuf field: bool allow_reserved = 5;
     */
    allowReserved: boolean;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 6;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.Encodings
 */
export interface Encodings {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedEncoding additional_properties = 1;
     */
    additionalProperties: NamedEncoding[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.Example
 */
export interface Example {
    /**
     * @generated from protobuf field: string summary = 1;
     */
    summary: string;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Any value = 3;
     */
    value?: Any;
    /**
     * @generated from protobuf field: string external_value = 4;
     */
    externalValue: string;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 5;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.ExampleOrReference
 */
export interface ExampleOrReference {
    /**
     * @generated from protobuf oneof: oneof
     */
    oneof: {
        oneofKind: "example";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Example example = 1;
         */
        example: Example;
    } | {
        oneofKind: "reference";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Reference reference = 2;
         */
        reference: Reference;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message gnostic.openapi.v3.ExamplesOrReferences
 */
export interface ExamplesOrReferences {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedExampleOrReference additional_properties = 1;
     */
    additionalProperties: NamedExampleOrReference[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.Expression
 */
export interface Expression {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny additional_properties = 1;
     */
    additionalProperties: NamedAny[];
}
/**
 * Allows referencing an external resource for extended documentation.
 *
 * @generated from protobuf message gnostic.openapi.v3.ExternalDocs
 */
export interface ExternalDocs {
    /**
     * @generated from protobuf field: string description = 1;
     */
    description: string;
    /**
     * @generated from protobuf field: string url = 2;
     */
    url: string;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 3;
     */
    specificationExtension: NamedAny[];
}
/**
 * The Header Object follows the structure of the Parameter Object with the following changes:  1. `name` MUST NOT be specified, it is given in the corresponding `headers` map. 1. `in` MUST NOT be specified, it is implicitly in `header`. 1. All traits that are affected by the location MUST be applicable to a location of `header` (for example, `style`).
 *
 * @generated from protobuf message gnostic.openapi.v3.Header
 */
export interface Header {
    /**
     * @generated from protobuf field: string description = 1;
     */
    description: string;
    /**
     * @generated from protobuf field: bool required = 2;
     */
    required: boolean;
    /**
     * @generated from protobuf field: bool deprecated = 3;
     */
    deprecated: boolean;
    /**
     * @generated from protobuf field: bool allow_empty_value = 4;
     */
    allowEmptyValue: boolean;
    /**
     * @generated from protobuf field: string style = 5;
     */
    style: string;
    /**
     * @generated from protobuf field: bool explode = 6;
     */
    explode: boolean;
    /**
     * @generated from protobuf field: bool allow_reserved = 7;
     */
    allowReserved: boolean;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.SchemaOrReference schema = 8;
     */
    schema?: SchemaOrReference;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Any example = 9;
     */
    example?: Any;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.ExamplesOrReferences examples = 10;
     */
    examples?: ExamplesOrReferences;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.MediaTypes content = 11;
     */
    content?: MediaTypes;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 12;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.HeaderOrReference
 */
export interface HeaderOrReference {
    /**
     * @generated from protobuf oneof: oneof
     */
    oneof: {
        oneofKind: "header";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Header header = 1;
         */
        header: Header;
    } | {
        oneofKind: "reference";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Reference reference = 2;
         */
        reference: Reference;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message gnostic.openapi.v3.HeadersOrReferences
 */
export interface HeadersOrReferences {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedHeaderOrReference additional_properties = 1;
     */
    additionalProperties: NamedHeaderOrReference[];
}
/**
 * The object provides metadata about the API. The metadata MAY be used by the clients if needed, and MAY be presented in editing or documentation generation tools for convenience.
 *
 * @generated from protobuf message gnostic.openapi.v3.Info
 */
export interface Info {
    /**
     * @generated from protobuf field: string title = 1;
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * @generated from protobuf field: string terms_of_service = 3;
     */
    termsOfService: string;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Contact contact = 4;
     */
    contact?: Contact;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.License license = 5;
     */
    license?: License;
    /**
     * @generated from protobuf field: string version = 6;
     */
    version: string;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 7;
     */
    specificationExtension: NamedAny[];
    /**
     * @generated from protobuf field: string summary = 8;
     */
    summary: string;
}
/**
 * @generated from protobuf message gnostic.openapi.v3.ItemsItem
 */
export interface ItemsItem {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1;
     */
    schemaOrReference: SchemaOrReference[];
}
/**
 * License information for the exposed API.
 *
 * @generated from protobuf message gnostic.openapi.v3.License
 */
export interface License {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string url = 2;
     */
    url: string;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 3;
     */
    specificationExtension: NamedAny[];
}
/**
 * The `Link object` represents a possible design-time link for a response. The presence of a link does not guarantee the caller's ability to successfully invoke it, rather it provides a known relationship and traversal mechanism between responses and other operations.  Unlike _dynamic_ links (i.e. links provided **in** the response payload), the OAS linking mechanism does not require link information in the runtime response.  For computing links, and providing instructions to execute them, a runtime expression is used for accessing values in an operation and using them as parameters while invoking the linked operation.
 *
 * @generated from protobuf message gnostic.openapi.v3.Link
 */
export interface Link {
    /**
     * @generated from protobuf field: string operation_ref = 1;
     */
    operationRef: string;
    /**
     * @generated from protobuf field: string operation_id = 2;
     */
    operationId: string;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.AnyOrExpression parameters = 3;
     */
    parameters?: AnyOrExpression;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.AnyOrExpression request_body = 4;
     */
    requestBody?: AnyOrExpression;
    /**
     * @generated from protobuf field: string description = 5;
     */
    description: string;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Server server = 6;
     */
    server?: Server;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 7;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.LinkOrReference
 */
export interface LinkOrReference {
    /**
     * @generated from protobuf oneof: oneof
     */
    oneof: {
        oneofKind: "link";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Link link = 1;
         */
        link: Link;
    } | {
        oneofKind: "reference";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Reference reference = 2;
         */
        reference: Reference;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message gnostic.openapi.v3.LinksOrReferences
 */
export interface LinksOrReferences {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedLinkOrReference additional_properties = 1;
     */
    additionalProperties: NamedLinkOrReference[];
}
/**
 * Each Media Type Object provides schema and examples for the media type identified by its key.
 *
 * @generated from protobuf message gnostic.openapi.v3.MediaType
 */
export interface MediaType {
    /**
     * @generated from protobuf field: gnostic.openapi.v3.SchemaOrReference schema = 1;
     */
    schema?: SchemaOrReference;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Any example = 2;
     */
    example?: Any;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.ExamplesOrReferences examples = 3;
     */
    examples?: ExamplesOrReferences;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Encodings encoding = 4;
     */
    encoding?: Encodings;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 5;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.MediaTypes
 */
export interface MediaTypes {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedMediaType additional_properties = 1;
     */
    additionalProperties: NamedMediaType[];
}
/**
 * Automatically-generated message used to represent maps of Any as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedAny
 */
export interface NamedAny {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: gnostic.openapi.v3.Any value = 2;
     */
    value?: Any;
}
/**
 * Automatically-generated message used to represent maps of CallbackOrReference as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedCallbackOrReference
 */
export interface NamedCallbackOrReference {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: gnostic.openapi.v3.CallbackOrReference value = 2;
     */
    value?: CallbackOrReference;
}
/**
 * Automatically-generated message used to represent maps of Encoding as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedEncoding
 */
export interface NamedEncoding {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: gnostic.openapi.v3.Encoding value = 2;
     */
    value?: Encoding;
}
/**
 * Automatically-generated message used to represent maps of ExampleOrReference as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedExampleOrReference
 */
export interface NamedExampleOrReference {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: gnostic.openapi.v3.ExampleOrReference value = 2;
     */
    value?: ExampleOrReference;
}
/**
 * Automatically-generated message used to represent maps of HeaderOrReference as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedHeaderOrReference
 */
export interface NamedHeaderOrReference {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: gnostic.openapi.v3.HeaderOrReference value = 2;
     */
    value?: HeaderOrReference;
}
/**
 * Automatically-generated message used to represent maps of LinkOrReference as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedLinkOrReference
 */
export interface NamedLinkOrReference {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: gnostic.openapi.v3.LinkOrReference value = 2;
     */
    value?: LinkOrReference;
}
/**
 * Automatically-generated message used to represent maps of MediaType as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedMediaType
 */
export interface NamedMediaType {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: gnostic.openapi.v3.MediaType value = 2;
     */
    value?: MediaType;
}
/**
 * Automatically-generated message used to represent maps of ParameterOrReference as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedParameterOrReference
 */
export interface NamedParameterOrReference {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: gnostic.openapi.v3.ParameterOrReference value = 2;
     */
    value?: ParameterOrReference;
}
/**
 * Automatically-generated message used to represent maps of PathItem as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedPathItem
 */
export interface NamedPathItem {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: gnostic.openapi.v3.PathItem value = 2;
     */
    value?: PathItem;
}
/**
 * Automatically-generated message used to represent maps of RequestBodyOrReference as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedRequestBodyOrReference
 */
export interface NamedRequestBodyOrReference {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: gnostic.openapi.v3.RequestBodyOrReference value = 2;
     */
    value?: RequestBodyOrReference;
}
/**
 * Automatically-generated message used to represent maps of ResponseOrReference as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedResponseOrReference
 */
export interface NamedResponseOrReference {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: gnostic.openapi.v3.ResponseOrReference value = 2;
     */
    value?: ResponseOrReference;
}
/**
 * Automatically-generated message used to represent maps of SchemaOrReference as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedSchemaOrReference
 */
export interface NamedSchemaOrReference {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: gnostic.openapi.v3.SchemaOrReference value = 2;
     */
    value?: SchemaOrReference;
}
/**
 * Automatically-generated message used to represent maps of SecuritySchemeOrReference as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedSecuritySchemeOrReference
 */
export interface NamedSecuritySchemeOrReference {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: gnostic.openapi.v3.SecuritySchemeOrReference value = 2;
     */
    value?: SecuritySchemeOrReference;
}
/**
 * Automatically-generated message used to represent maps of ServerVariable as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedServerVariable
 */
export interface NamedServerVariable {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: gnostic.openapi.v3.ServerVariable value = 2;
     */
    value?: ServerVariable;
}
/**
 * Automatically-generated message used to represent maps of string as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedString
 */
export interface NamedString {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * Automatically-generated message used to represent maps of StringArray as ordered (name,value) pairs.
 *
 * @generated from protobuf message gnostic.openapi.v3.NamedStringArray
 */
export interface NamedStringArray {
    /**
     * Map key
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Mapped value
     *
     * @generated from protobuf field: gnostic.openapi.v3.StringArray value = 2;
     */
    value?: StringArray;
}
/**
 * Configuration details for a supported OAuth Flow
 *
 * @generated from protobuf message gnostic.openapi.v3.OauthFlow
 */
export interface OauthFlow {
    /**
     * @generated from protobuf field: string authorization_url = 1;
     */
    authorizationUrl: string;
    /**
     * @generated from protobuf field: string token_url = 2;
     */
    tokenUrl: string;
    /**
     * @generated from protobuf field: string refresh_url = 3;
     */
    refreshUrl: string;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Strings scopes = 4;
     */
    scopes?: Strings;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 5;
     */
    specificationExtension: NamedAny[];
}
/**
 * Allows configuration of the supported OAuth Flows.
 *
 * @generated from protobuf message gnostic.openapi.v3.OauthFlows
 */
export interface OauthFlows {
    /**
     * @generated from protobuf field: gnostic.openapi.v3.OauthFlow implicit = 1;
     */
    implicit?: OauthFlow;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.OauthFlow password = 2;
     */
    password?: OauthFlow;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.OauthFlow client_credentials = 3;
     */
    clientCredentials?: OauthFlow;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.OauthFlow authorization_code = 4;
     */
    authorizationCode?: OauthFlow;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 5;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.Object
 */
export interface Object {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny additional_properties = 1;
     */
    additionalProperties: NamedAny[];
}
/**
 * Describes a single API operation on a path.
 *
 * @generated from protobuf message gnostic.openapi.v3.Operation
 */
export interface Operation {
    /**
     * @generated from protobuf field: repeated string tags = 1;
     */
    tags: string[];
    /**
     * @generated from protobuf field: string summary = 2;
     */
    summary: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.ExternalDocs external_docs = 4;
     */
    externalDocs?: ExternalDocs;
    /**
     * @generated from protobuf field: string operation_id = 5;
     */
    operationId: string;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.ParameterOrReference parameters = 6;
     */
    parameters: ParameterOrReference[];
    /**
     * @generated from protobuf field: gnostic.openapi.v3.RequestBodyOrReference request_body = 7;
     */
    requestBody?: RequestBodyOrReference;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Responses responses = 8;
     */
    responses?: Responses;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.CallbacksOrReferences callbacks = 9;
     */
    callbacks?: CallbacksOrReferences;
    /**
     * @generated from protobuf field: bool deprecated = 10;
     */
    deprecated: boolean;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.SecurityRequirement security = 11;
     */
    security: SecurityRequirement[];
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.Server servers = 12;
     */
    servers: Server[];
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 13;
     */
    specificationExtension: NamedAny[];
}
/**
 * Describes a single operation parameter.  A unique parameter is defined by a combination of a name and location.
 *
 * @generated from protobuf message gnostic.openapi.v3.Parameter
 */
export interface Parameter {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string in = 2;
     */
    in: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * @generated from protobuf field: bool required = 4;
     */
    required: boolean;
    /**
     * @generated from protobuf field: bool deprecated = 5;
     */
    deprecated: boolean;
    /**
     * @generated from protobuf field: bool allow_empty_value = 6;
     */
    allowEmptyValue: boolean;
    /**
     * @generated from protobuf field: string style = 7;
     */
    style: string;
    /**
     * @generated from protobuf field: bool explode = 8;
     */
    explode: boolean;
    /**
     * @generated from protobuf field: bool allow_reserved = 9;
     */
    allowReserved: boolean;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.SchemaOrReference schema = 10;
     */
    schema?: SchemaOrReference;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Any example = 11;
     */
    example?: Any;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.ExamplesOrReferences examples = 12;
     */
    examples?: ExamplesOrReferences;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.MediaTypes content = 13;
     */
    content?: MediaTypes;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 14;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.ParameterOrReference
 */
export interface ParameterOrReference {
    /**
     * @generated from protobuf oneof: oneof
     */
    oneof: {
        oneofKind: "parameter";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Parameter parameter = 1;
         */
        parameter: Parameter;
    } | {
        oneofKind: "reference";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Reference reference = 2;
         */
        reference: Reference;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message gnostic.openapi.v3.ParametersOrReferences
 */
export interface ParametersOrReferences {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedParameterOrReference additional_properties = 1;
     */
    additionalProperties: NamedParameterOrReference[];
}
/**
 * Describes the operations available on a single path. A Path Item MAY be empty, due to ACL constraints. The path itself is still exposed to the documentation viewer but they will not know which operations and parameters are available.
 *
 * @generated from protobuf message gnostic.openapi.v3.PathItem
 */
export interface PathItem {
    /**
     * @generated from protobuf field: string _ref = 1;
     */
    Ref: string;
    /**
     * @generated from protobuf field: string summary = 2;
     */
    summary: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Operation get = 4;
     */
    get?: Operation;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Operation put = 5;
     */
    put?: Operation;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Operation post = 6;
     */
    post?: Operation;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Operation delete = 7;
     */
    delete?: Operation;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Operation options = 8;
     */
    options?: Operation;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Operation head = 9;
     */
    head?: Operation;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Operation patch = 10;
     */
    patch?: Operation;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Operation trace = 11;
     */
    trace?: Operation;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.Server servers = 12;
     */
    servers: Server[];
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.ParameterOrReference parameters = 13;
     */
    parameters: ParameterOrReference[];
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 14;
     */
    specificationExtension: NamedAny[];
}
/**
 * Holds the relative paths to the individual endpoints and their operations. The path is appended to the URL from the `Server Object` in order to construct the full URL.  The Paths MAY be empty, due to ACL constraints.
 *
 * @generated from protobuf message gnostic.openapi.v3.Paths
 */
export interface Paths {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedPathItem path = 1;
     */
    path: NamedPathItem[];
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 2;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.Properties
 */
export interface Properties {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1;
     */
    additionalProperties: NamedSchemaOrReference[];
}
/**
 * A simple object to allow referencing other components in the specification, internally and externally.  The Reference Object is defined by JSON Reference and follows the same structure, behavior and rules.   For this specification, reference resolution is accomplished as defined by the JSON Reference specification and not by the JSON Schema specification.
 *
 * @generated from protobuf message gnostic.openapi.v3.Reference
 */
export interface Reference {
    /**
     * @generated from protobuf field: string _ref = 1;
     */
    Ref: string;
    /**
     * @generated from protobuf field: string summary = 2;
     */
    summary: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
}
/**
 * @generated from protobuf message gnostic.openapi.v3.RequestBodiesOrReferences
 */
export interface RequestBodiesOrReferences {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedRequestBodyOrReference additional_properties = 1;
     */
    additionalProperties: NamedRequestBodyOrReference[];
}
/**
 * Describes a single request body.
 *
 * @generated from protobuf message gnostic.openapi.v3.RequestBody
 */
export interface RequestBody {
    /**
     * @generated from protobuf field: string description = 1;
     */
    description: string;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.MediaTypes content = 2;
     */
    content?: MediaTypes;
    /**
     * @generated from protobuf field: bool required = 3;
     */
    required: boolean;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 4;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.RequestBodyOrReference
 */
export interface RequestBodyOrReference {
    /**
     * @generated from protobuf oneof: oneof
     */
    oneof: {
        oneofKind: "requestBody";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.RequestBody request_body = 1;
         */
        requestBody: RequestBody;
    } | {
        oneofKind: "reference";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Reference reference = 2;
         */
        reference: Reference;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Describes a single response from an API Operation, including design-time, static  `links` to operations based on the response.
 *
 * @generated from protobuf message gnostic.openapi.v3.Response
 */
export interface Response {
    /**
     * @generated from protobuf field: string description = 1;
     */
    description: string;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.HeadersOrReferences headers = 2;
     */
    headers?: HeadersOrReferences;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.MediaTypes content = 3;
     */
    content?: MediaTypes;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.LinksOrReferences links = 4;
     */
    links?: LinksOrReferences;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 5;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.ResponseOrReference
 */
export interface ResponseOrReference {
    /**
     * @generated from protobuf oneof: oneof
     */
    oneof: {
        oneofKind: "response";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Response response = 1;
         */
        response: Response;
    } | {
        oneofKind: "reference";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Reference reference = 2;
         */
        reference: Reference;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A container for the expected responses of an operation. The container maps a HTTP response code to the expected response.  The documentation is not necessarily expected to cover all possible HTTP response codes because they may not be known in advance. However, documentation is expected to cover a successful operation response and any known errors.  The `default` MAY be used as a default response object for all HTTP codes  that are not covered individually by the specification.  The `Responses Object` MUST contain at least one response code, and it  SHOULD be the response for a successful operation call.
 *
 * @generated from protobuf message gnostic.openapi.v3.Responses
 */
export interface Responses {
    /**
     * @generated from protobuf field: gnostic.openapi.v3.ResponseOrReference default = 1;
     */
    default?: ResponseOrReference;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedResponseOrReference response_or_reference = 2;
     */
    responseOrReference: NamedResponseOrReference[];
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 3;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.ResponsesOrReferences
 */
export interface ResponsesOrReferences {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedResponseOrReference additional_properties = 1;
     */
    additionalProperties: NamedResponseOrReference[];
}
/**
 * The Schema Object allows the definition of input and output data types. These types can be objects, but also primitives and arrays. This object is an extended subset of the JSON Schema Specification Wright Draft 00.  For more information about the properties, see JSON Schema Core and JSON Schema Validation. Unless stated otherwise, the property definitions follow the JSON Schema.
 *
 * @generated from protobuf message gnostic.openapi.v3.Schema
 */
export interface Schema {
    /**
     * @generated from protobuf field: bool nullable = 1;
     */
    nullable: boolean;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Discriminator discriminator = 2;
     */
    discriminator?: Discriminator;
    /**
     * @generated from protobuf field: bool read_only = 3;
     */
    readOnly: boolean;
    /**
     * @generated from protobuf field: bool write_only = 4;
     */
    writeOnly: boolean;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Xml xml = 5;
     */
    xml?: Xml;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.ExternalDocs external_docs = 6;
     */
    externalDocs?: ExternalDocs;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Any example = 7;
     */
    example?: Any;
    /**
     * @generated from protobuf field: bool deprecated = 8;
     */
    deprecated: boolean;
    /**
     * @generated from protobuf field: string title = 9;
     */
    title: string;
    /**
     * @generated from protobuf field: double multiple_of = 10;
     */
    multipleOf: number;
    /**
     * @generated from protobuf field: double maximum = 11;
     */
    maximum: number;
    /**
     * @generated from protobuf field: bool exclusive_maximum = 12;
     */
    exclusiveMaximum: boolean;
    /**
     * @generated from protobuf field: double minimum = 13;
     */
    minimum: number;
    /**
     * @generated from protobuf field: bool exclusive_minimum = 14;
     */
    exclusiveMinimum: boolean;
    /**
     * @generated from protobuf field: int64 max_length = 15;
     */
    maxLength: string;
    /**
     * @generated from protobuf field: int64 min_length = 16;
     */
    minLength: string;
    /**
     * @generated from protobuf field: string pattern = 17;
     */
    pattern: string;
    /**
     * @generated from protobuf field: int64 max_items = 18;
     */
    maxItems: string;
    /**
     * @generated from protobuf field: int64 min_items = 19;
     */
    minItems: string;
    /**
     * @generated from protobuf field: bool unique_items = 20;
     */
    uniqueItems: boolean;
    /**
     * @generated from protobuf field: int64 max_properties = 21;
     */
    maxProperties: string;
    /**
     * @generated from protobuf field: int64 min_properties = 22;
     */
    minProperties: string;
    /**
     * @generated from protobuf field: repeated string required = 23;
     */
    required: string[];
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.Any enum = 24;
     */
    enum: Any[];
    /**
     * @generated from protobuf field: string type = 25;
     */
    type: string;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.SchemaOrReference all_of = 26;
     */
    allOf: SchemaOrReference[];
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.SchemaOrReference one_of = 27;
     */
    oneOf: SchemaOrReference[];
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.SchemaOrReference any_of = 28;
     */
    anyOf: SchemaOrReference[];
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Schema not = 29;
     */
    not?: Schema;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.ItemsItem items = 30;
     */
    items?: ItemsItem;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.Properties properties = 31;
     */
    properties?: Properties;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.AdditionalPropertiesItem additional_properties = 32;
     */
    additionalProperties?: AdditionalPropertiesItem;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.DefaultType default = 33;
     */
    default?: DefaultType;
    /**
     * @generated from protobuf field: string description = 34;
     */
    description: string;
    /**
     * @generated from protobuf field: string format = 35;
     */
    format: string;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 36;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.SchemaOrReference
 */
export interface SchemaOrReference {
    /**
     * @generated from protobuf oneof: oneof
     */
    oneof: {
        oneofKind: "schema";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Schema schema = 1;
         */
        schema: Schema;
    } | {
        oneofKind: "reference";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Reference reference = 2;
         */
        reference: Reference;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message gnostic.openapi.v3.SchemasOrReferences
 */
export interface SchemasOrReferences {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1;
     */
    additionalProperties: NamedSchemaOrReference[];
}
/**
 * Lists the required security schemes to execute this operation. The name used for each property MUST correspond to a security scheme declared in the Security Schemes under the Components Object.  Security Requirement Objects that contain multiple schemes require that all schemes MUST be satisfied for a request to be authorized. This enables support for scenarios where multiple query parameters or HTTP headers are required to convey security information.  When a list of Security Requirement Objects is defined on the OpenAPI Object or Operation Object, only one of the Security Requirement Objects in the list needs to be satisfied to authorize the request.
 *
 * @generated from protobuf message gnostic.openapi.v3.SecurityRequirement
 */
export interface SecurityRequirement {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedStringArray additional_properties = 1;
     */
    additionalProperties: NamedStringArray[];
}
/**
 * Defines a security scheme that can be used by the operations. Supported schemes are HTTP authentication, an API key (either as a header, a cookie parameter or as a query parameter), mutual TLS (use of a client certificate), OAuth2's common flows (implicit, password, application and access code) as defined in RFC6749, and OpenID Connect.   Please note that currently (2019) the implicit flow is about to be deprecated OAuth 2.0 Security Best Current Practice. Recommended for most use case is Authorization Code Grant flow with PKCE.
 *
 * @generated from protobuf message gnostic.openapi.v3.SecurityScheme
 */
export interface SecurityScheme {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string in = 4;
     */
    in: string;
    /**
     * @generated from protobuf field: string scheme = 5;
     */
    scheme: string;
    /**
     * @generated from protobuf field: string bearer_format = 6;
     */
    bearerFormat: string;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.OauthFlows flows = 7;
     */
    flows?: OauthFlows;
    /**
     * @generated from protobuf field: string open_id_connect_url = 8;
     */
    openIdConnectUrl: string;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 9;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.SecuritySchemeOrReference
 */
export interface SecuritySchemeOrReference {
    /**
     * @generated from protobuf oneof: oneof
     */
    oneof: {
        oneofKind: "securityScheme";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.SecurityScheme security_scheme = 1;
         */
        securityScheme: SecurityScheme;
    } | {
        oneofKind: "reference";
        /**
         * @generated from protobuf field: gnostic.openapi.v3.Reference reference = 2;
         */
        reference: Reference;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message gnostic.openapi.v3.SecuritySchemesOrReferences
 */
export interface SecuritySchemesOrReferences {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedSecuritySchemeOrReference additional_properties = 1;
     */
    additionalProperties: NamedSecuritySchemeOrReference[];
}
/**
 * An object representing a Server.
 *
 * @generated from protobuf message gnostic.openapi.v3.Server
 */
export interface Server {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.ServerVariables variables = 3;
     */
    variables?: ServerVariables;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 4;
     */
    specificationExtension: NamedAny[];
}
/**
 * An object representing a Server Variable for server URL template substitution.
 *
 * @generated from protobuf message gnostic.openapi.v3.ServerVariable
 */
export interface ServerVariable {
    /**
     * @generated from protobuf field: repeated string enum = 1;
     */
    enum: string[];
    /**
     * @generated from protobuf field: string default = 2;
     */
    default: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 4;
     */
    specificationExtension: NamedAny[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.ServerVariables
 */
export interface ServerVariables {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedServerVariable additional_properties = 1;
     */
    additionalProperties: NamedServerVariable[];
}
/**
 * Any property starting with x- is valid.
 *
 * @generated from protobuf message gnostic.openapi.v3.SpecificationExtension
 */
export interface SpecificationExtension {
    /**
     * @generated from protobuf oneof: oneof
     */
    oneof: {
        oneofKind: "number";
        /**
         * @generated from protobuf field: double number = 1;
         */
        number: number;
    } | {
        oneofKind: "boolean";
        /**
         * @generated from protobuf field: bool boolean = 2;
         */
        boolean: boolean;
    } | {
        oneofKind: "string";
        /**
         * @generated from protobuf field: string string = 3;
         */
        string: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message gnostic.openapi.v3.StringArray
 */
export interface StringArray {
    /**
     * @generated from protobuf field: repeated string value = 1;
     */
    value: string[];
}
/**
 * @generated from protobuf message gnostic.openapi.v3.Strings
 */
export interface Strings {
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedString additional_properties = 1;
     */
    additionalProperties: NamedString[];
}
/**
 * Adds metadata to a single tag that is used by the Operation Object. It is not mandatory to have a Tag Object per tag defined in the Operation Object instances.
 *
 * @generated from protobuf message gnostic.openapi.v3.Tag
 */
export interface Tag {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * @generated from protobuf field: gnostic.openapi.v3.ExternalDocs external_docs = 3;
     */
    externalDocs?: ExternalDocs;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 4;
     */
    specificationExtension: NamedAny[];
}
/**
 * A metadata object that allows for more fine-tuned XML model definitions.  When using arrays, XML element names are *not* inferred (for singular/plural forms) and the `name` property SHOULD be used to add that information. See examples for expected behavior.
 *
 * @generated from protobuf message gnostic.openapi.v3.Xml
 */
export interface Xml {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string namespace = 2;
     */
    namespace: string;
    /**
     * @generated from protobuf field: string prefix = 3;
     */
    prefix: string;
    /**
     * @generated from protobuf field: bool attribute = 4;
     */
    attribute: boolean;
    /**
     * @generated from protobuf field: bool wrapped = 5;
     */
    wrapped: boolean;
    /**
     * @generated from protobuf field: repeated gnostic.openapi.v3.NamedAny specification_extension = 6;
     */
    specificationExtension: NamedAny[];
}
// @generated message type with reflection information, may provide speed optimized methods
class AdditionalPropertiesItem$Type extends MessageType<AdditionalPropertiesItem> {
    constructor() {
        super("gnostic.openapi.v3.AdditionalPropertiesItem", [
            { no: 1, name: "schema_or_reference", kind: "message", oneof: "oneof", T: () => SchemaOrReference },
            { no: 2, name: "boolean", kind: "scalar", oneof: "oneof", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AdditionalPropertiesItem>): AdditionalPropertiesItem {
        const message = { oneof: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdditionalPropertiesItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdditionalPropertiesItem): AdditionalPropertiesItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gnostic.openapi.v3.SchemaOrReference schema_or_reference */ 1:
                    message.oneof = {
                        oneofKind: "schemaOrReference",
                        schemaOrReference: SchemaOrReference.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).schemaOrReference)
                    };
                    break;
                case /* bool boolean */ 2:
                    message.oneof = {
                        oneofKind: "boolean",
                        boolean: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdditionalPropertiesItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1; */
        if (message.oneof.oneofKind === "schemaOrReference")
            SchemaOrReference.internalBinaryWrite(message.oneof.schemaOrReference, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool boolean = 2; */
        if (message.oneof.oneofKind === "boolean")
            writer.tag(2, WireType.Varint).bool(message.oneof.boolean);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.AdditionalPropertiesItem
 */
export const AdditionalPropertiesItem = new AdditionalPropertiesItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Any$Type extends MessageType<Any> {
    constructor() {
        super("gnostic.openapi.v3.Any", [
            { no: 1, name: "value", kind: "message", T: () => Any$ },
            { no: 2, name: "yaml", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Any>): Any {
        const message = { yaml: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Any>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Any): Any {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any value */ 1:
                    message.value = Any$.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* string yaml */ 2:
                    message.yaml = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Any, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any value = 1; */
        if (message.value)
            Any$.internalBinaryWrite(message.value, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string yaml = 2; */
        if (message.yaml !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.yaml);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Any
 */
export const Any = new Any$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnyOrExpression$Type extends MessageType<AnyOrExpression> {
    constructor() {
        super("gnostic.openapi.v3.AnyOrExpression", [
            { no: 1, name: "any", kind: "message", oneof: "oneof", T: () => Any },
            { no: 2, name: "expression", kind: "message", oneof: "oneof", T: () => Expression }
        ]);
    }
    create(value?: PartialMessage<AnyOrExpression>): AnyOrExpression {
        const message = { oneof: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AnyOrExpression>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnyOrExpression): AnyOrExpression {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gnostic.openapi.v3.Any any */ 1:
                    message.oneof = {
                        oneofKind: "any",
                        any: Any.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).any)
                    };
                    break;
                case /* gnostic.openapi.v3.Expression expression */ 2:
                    message.oneof = {
                        oneofKind: "expression",
                        expression: Expression.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).expression)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnyOrExpression, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gnostic.openapi.v3.Any any = 1; */
        if (message.oneof.oneofKind === "any")
            Any.internalBinaryWrite(message.oneof.any, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Expression expression = 2; */
        if (message.oneof.oneofKind === "expression")
            Expression.internalBinaryWrite(message.oneof.expression, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.AnyOrExpression
 */
export const AnyOrExpression = new AnyOrExpression$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Callback$Type extends MessageType<Callback> {
    constructor() {
        super("gnostic.openapi.v3.Callback", [
            { no: 1, name: "path", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedPathItem },
            { no: 2, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Callback>): Callback {
        const message = { path: [], specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Callback>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Callback): Callback {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedPathItem path */ 1:
                    message.path.push(NamedPathItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 2:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Callback, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedPathItem path = 1; */
        for (let i = 0; i < message.path.length; i++)
            NamedPathItem.internalBinaryWrite(message.path[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 2; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Callback
 */
export const Callback = new Callback$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CallbackOrReference$Type extends MessageType<CallbackOrReference> {
    constructor() {
        super("gnostic.openapi.v3.CallbackOrReference", [
            { no: 1, name: "callback", kind: "message", oneof: "oneof", T: () => Callback },
            { no: 2, name: "reference", kind: "message", oneof: "oneof", T: () => Reference }
        ]);
    }
    create(value?: PartialMessage<CallbackOrReference>): CallbackOrReference {
        const message = { oneof: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CallbackOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CallbackOrReference): CallbackOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gnostic.openapi.v3.Callback callback */ 1:
                    message.oneof = {
                        oneofKind: "callback",
                        callback: Callback.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).callback)
                    };
                    break;
                case /* gnostic.openapi.v3.Reference reference */ 2:
                    message.oneof = {
                        oneofKind: "reference",
                        reference: Reference.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).reference)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CallbackOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gnostic.openapi.v3.Callback callback = 1; */
        if (message.oneof.oneofKind === "callback")
            Callback.internalBinaryWrite(message.oneof.callback, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Reference reference = 2; */
        if (message.oneof.oneofKind === "reference")
            Reference.internalBinaryWrite(message.oneof.reference, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.CallbackOrReference
 */
export const CallbackOrReference = new CallbackOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CallbacksOrReferences$Type extends MessageType<CallbacksOrReferences> {
    constructor() {
        super("gnostic.openapi.v3.CallbacksOrReferences", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedCallbackOrReference }
        ]);
    }
    create(value?: PartialMessage<CallbacksOrReferences>): CallbacksOrReferences {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CallbacksOrReferences>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CallbacksOrReferences): CallbacksOrReferences {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedCallbackOrReference additional_properties */ 1:
                    message.additionalProperties.push(NamedCallbackOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CallbacksOrReferences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedCallbackOrReference additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedCallbackOrReference.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.CallbacksOrReferences
 */
export const CallbacksOrReferences = new CallbacksOrReferences$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Components$Type extends MessageType<Components> {
    constructor() {
        super("gnostic.openapi.v3.Components", [
            { no: 1, name: "schemas", kind: "message", T: () => SchemasOrReferences },
            { no: 2, name: "responses", kind: "message", T: () => ResponsesOrReferences },
            { no: 3, name: "parameters", kind: "message", T: () => ParametersOrReferences },
            { no: 4, name: "examples", kind: "message", T: () => ExamplesOrReferences },
            { no: 5, name: "request_bodies", kind: "message", T: () => RequestBodiesOrReferences },
            { no: 6, name: "headers", kind: "message", T: () => HeadersOrReferences },
            { no: 7, name: "security_schemes", kind: "message", T: () => SecuritySchemesOrReferences },
            { no: 8, name: "links", kind: "message", T: () => LinksOrReferences },
            { no: 9, name: "callbacks", kind: "message", T: () => CallbacksOrReferences },
            { no: 10, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Components>): Components {
        const message = { specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Components>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Components): Components {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gnostic.openapi.v3.SchemasOrReferences schemas */ 1:
                    message.schemas = SchemasOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.schemas);
                    break;
                case /* gnostic.openapi.v3.ResponsesOrReferences responses */ 2:
                    message.responses = ResponsesOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.responses);
                    break;
                case /* gnostic.openapi.v3.ParametersOrReferences parameters */ 3:
                    message.parameters = ParametersOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.parameters);
                    break;
                case /* gnostic.openapi.v3.ExamplesOrReferences examples */ 4:
                    message.examples = ExamplesOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.examples);
                    break;
                case /* gnostic.openapi.v3.RequestBodiesOrReferences request_bodies */ 5:
                    message.requestBodies = RequestBodiesOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.requestBodies);
                    break;
                case /* gnostic.openapi.v3.HeadersOrReferences headers */ 6:
                    message.headers = HeadersOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.headers);
                    break;
                case /* gnostic.openapi.v3.SecuritySchemesOrReferences security_schemes */ 7:
                    message.securitySchemes = SecuritySchemesOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.securitySchemes);
                    break;
                case /* gnostic.openapi.v3.LinksOrReferences links */ 8:
                    message.links = LinksOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.links);
                    break;
                case /* gnostic.openapi.v3.CallbacksOrReferences callbacks */ 9:
                    message.callbacks = CallbacksOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.callbacks);
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 10:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Components, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gnostic.openapi.v3.SchemasOrReferences schemas = 1; */
        if (message.schemas)
            SchemasOrReferences.internalBinaryWrite(message.schemas, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.ResponsesOrReferences responses = 2; */
        if (message.responses)
            ResponsesOrReferences.internalBinaryWrite(message.responses, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.ParametersOrReferences parameters = 3; */
        if (message.parameters)
            ParametersOrReferences.internalBinaryWrite(message.parameters, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.ExamplesOrReferences examples = 4; */
        if (message.examples)
            ExamplesOrReferences.internalBinaryWrite(message.examples, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.RequestBodiesOrReferences request_bodies = 5; */
        if (message.requestBodies)
            RequestBodiesOrReferences.internalBinaryWrite(message.requestBodies, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.HeadersOrReferences headers = 6; */
        if (message.headers)
            HeadersOrReferences.internalBinaryWrite(message.headers, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.SecuritySchemesOrReferences security_schemes = 7; */
        if (message.securitySchemes)
            SecuritySchemesOrReferences.internalBinaryWrite(message.securitySchemes, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.LinksOrReferences links = 8; */
        if (message.links)
            LinksOrReferences.internalBinaryWrite(message.links, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.CallbacksOrReferences callbacks = 9; */
        if (message.callbacks)
            CallbacksOrReferences.internalBinaryWrite(message.callbacks, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 10; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Components
 */
export const Components = new Components$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Contact$Type extends MessageType<Contact> {
    constructor() {
        super("gnostic.openapi.v3.Contact", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Contact>): Contact {
        const message = { name: "", url: "", email: "", specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Contact>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Contact): Contact {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                case /* string email */ 3:
                    message.email = reader.string();
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 4:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Contact, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        /* string email = 3; */
        if (message.email !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 4; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Contact
 */
export const Contact = new Contact$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DefaultType$Type extends MessageType<DefaultType> {
    constructor() {
        super("gnostic.openapi.v3.DefaultType", [
            { no: 1, name: "number", kind: "scalar", oneof: "oneof", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "boolean", kind: "scalar", oneof: "oneof", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "string", kind: "scalar", oneof: "oneof", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DefaultType>): DefaultType {
        const message = { oneof: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DefaultType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DefaultType): DefaultType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double number */ 1:
                    message.oneof = {
                        oneofKind: "number",
                        number: reader.double()
                    };
                    break;
                case /* bool boolean */ 2:
                    message.oneof = {
                        oneofKind: "boolean",
                        boolean: reader.bool()
                    };
                    break;
                case /* string string */ 3:
                    message.oneof = {
                        oneofKind: "string",
                        string: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DefaultType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double number = 1; */
        if (message.oneof.oneofKind === "number")
            writer.tag(1, WireType.Bit64).double(message.oneof.number);
        /* bool boolean = 2; */
        if (message.oneof.oneofKind === "boolean")
            writer.tag(2, WireType.Varint).bool(message.oneof.boolean);
        /* string string = 3; */
        if (message.oneof.oneofKind === "string")
            writer.tag(3, WireType.LengthDelimited).string(message.oneof.string);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.DefaultType
 */
export const DefaultType = new DefaultType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Discriminator$Type extends MessageType<Discriminator> {
    constructor() {
        super("gnostic.openapi.v3.Discriminator", [
            { no: 1, name: "property_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "mapping", kind: "message", T: () => Strings },
            { no: 3, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Discriminator>): Discriminator {
        const message = { propertyName: "", specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Discriminator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Discriminator): Discriminator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string property_name */ 1:
                    message.propertyName = reader.string();
                    break;
                case /* gnostic.openapi.v3.Strings mapping */ 2:
                    message.mapping = Strings.internalBinaryRead(reader, reader.uint32(), options, message.mapping);
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 3:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Discriminator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string property_name = 1; */
        if (message.propertyName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.propertyName);
        /* gnostic.openapi.v3.Strings mapping = 2; */
        if (message.mapping)
            Strings.internalBinaryWrite(message.mapping, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 3; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Discriminator
 */
export const Discriminator = new Discriminator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Document$Type extends MessageType<Document> {
    constructor() {
        super("gnostic.openapi.v3.Document", [
            { no: 1, name: "openapi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "info", kind: "message", T: () => Info },
            { no: 3, name: "servers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Server },
            { no: 4, name: "paths", kind: "message", T: () => Paths },
            { no: 5, name: "components", kind: "message", T: () => Components },
            { no: 6, name: "security", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SecurityRequirement },
            { no: 7, name: "tags", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tag },
            { no: 8, name: "external_docs", kind: "message", T: () => ExternalDocs },
            { no: 9, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Document>): Document {
        const message = { openapi: "", servers: [], security: [], tags: [], specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Document>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Document): Document {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string openapi */ 1:
                    message.openapi = reader.string();
                    break;
                case /* gnostic.openapi.v3.Info info */ 2:
                    message.info = Info.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                case /* repeated gnostic.openapi.v3.Server servers */ 3:
                    message.servers.push(Server.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* gnostic.openapi.v3.Paths paths */ 4:
                    message.paths = Paths.internalBinaryRead(reader, reader.uint32(), options, message.paths);
                    break;
                case /* gnostic.openapi.v3.Components components */ 5:
                    message.components = Components.internalBinaryRead(reader, reader.uint32(), options, message.components);
                    break;
                case /* repeated gnostic.openapi.v3.SecurityRequirement security */ 6:
                    message.security.push(SecurityRequirement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated gnostic.openapi.v3.Tag tags */ 7:
                    message.tags.push(Tag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* gnostic.openapi.v3.ExternalDocs external_docs */ 8:
                    message.externalDocs = ExternalDocs.internalBinaryRead(reader, reader.uint32(), options, message.externalDocs);
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 9:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Document, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string openapi = 1; */
        if (message.openapi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.openapi);
        /* gnostic.openapi.v3.Info info = 2; */
        if (message.info)
            Info.internalBinaryWrite(message.info, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.Server servers = 3; */
        for (let i = 0; i < message.servers.length; i++)
            Server.internalBinaryWrite(message.servers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Paths paths = 4; */
        if (message.paths)
            Paths.internalBinaryWrite(message.paths, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Components components = 5; */
        if (message.components)
            Components.internalBinaryWrite(message.components, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.SecurityRequirement security = 6; */
        for (let i = 0; i < message.security.length; i++)
            SecurityRequirement.internalBinaryWrite(message.security[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.Tag tags = 7; */
        for (let i = 0; i < message.tags.length; i++)
            Tag.internalBinaryWrite(message.tags[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.ExternalDocs external_docs = 8; */
        if (message.externalDocs)
            ExternalDocs.internalBinaryWrite(message.externalDocs, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 9; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Document
 */
export const Document = new Document$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Encoding$Type extends MessageType<Encoding> {
    constructor() {
        super("gnostic.openapi.v3.Encoding", [
            { no: 1, name: "content_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "headers", kind: "message", T: () => HeadersOrReferences },
            { no: 3, name: "style", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "explode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "allow_reserved", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Encoding>): Encoding {
        const message = { contentType: "", style: "", explode: false, allowReserved: false, specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Encoding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Encoding): Encoding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string content_type */ 1:
                    message.contentType = reader.string();
                    break;
                case /* gnostic.openapi.v3.HeadersOrReferences headers */ 2:
                    message.headers = HeadersOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.headers);
                    break;
                case /* string style */ 3:
                    message.style = reader.string();
                    break;
                case /* bool explode */ 4:
                    message.explode = reader.bool();
                    break;
                case /* bool allow_reserved */ 5:
                    message.allowReserved = reader.bool();
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 6:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Encoding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string content_type = 1; */
        if (message.contentType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contentType);
        /* gnostic.openapi.v3.HeadersOrReferences headers = 2; */
        if (message.headers)
            HeadersOrReferences.internalBinaryWrite(message.headers, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string style = 3; */
        if (message.style !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.style);
        /* bool explode = 4; */
        if (message.explode !== false)
            writer.tag(4, WireType.Varint).bool(message.explode);
        /* bool allow_reserved = 5; */
        if (message.allowReserved !== false)
            writer.tag(5, WireType.Varint).bool(message.allowReserved);
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 6; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Encoding
 */
export const Encoding = new Encoding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Encodings$Type extends MessageType<Encodings> {
    constructor() {
        super("gnostic.openapi.v3.Encodings", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedEncoding }
        ]);
    }
    create(value?: PartialMessage<Encodings>): Encodings {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Encodings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Encodings): Encodings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedEncoding additional_properties */ 1:
                    message.additionalProperties.push(NamedEncoding.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Encodings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedEncoding additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedEncoding.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Encodings
 */
export const Encodings = new Encodings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Example$Type extends MessageType<Example> {
    constructor() {
        super("gnostic.openapi.v3.Example", [
            { no: 1, name: "summary", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "message", T: () => Any },
            { no: 4, name: "external_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Example>): Example {
        const message = { summary: "", description: "", externalValue: "", specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Example>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Example): Example {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string summary */ 1:
                    message.summary = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* gnostic.openapi.v3.Any value */ 3:
                    message.value = Any.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* string external_value */ 4:
                    message.externalValue = reader.string();
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 5:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Example, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string summary = 1; */
        if (message.summary !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.summary);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* gnostic.openapi.v3.Any value = 3; */
        if (message.value)
            Any.internalBinaryWrite(message.value, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string external_value = 4; */
        if (message.externalValue !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.externalValue);
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 5; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Example
 */
export const Example = new Example$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExampleOrReference$Type extends MessageType<ExampleOrReference> {
    constructor() {
        super("gnostic.openapi.v3.ExampleOrReference", [
            { no: 1, name: "example", kind: "message", oneof: "oneof", T: () => Example },
            { no: 2, name: "reference", kind: "message", oneof: "oneof", T: () => Reference }
        ]);
    }
    create(value?: PartialMessage<ExampleOrReference>): ExampleOrReference {
        const message = { oneof: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExampleOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExampleOrReference): ExampleOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gnostic.openapi.v3.Example example */ 1:
                    message.oneof = {
                        oneofKind: "example",
                        example: Example.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).example)
                    };
                    break;
                case /* gnostic.openapi.v3.Reference reference */ 2:
                    message.oneof = {
                        oneofKind: "reference",
                        reference: Reference.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).reference)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExampleOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gnostic.openapi.v3.Example example = 1; */
        if (message.oneof.oneofKind === "example")
            Example.internalBinaryWrite(message.oneof.example, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Reference reference = 2; */
        if (message.oneof.oneofKind === "reference")
            Reference.internalBinaryWrite(message.oneof.reference, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.ExampleOrReference
 */
export const ExampleOrReference = new ExampleOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExamplesOrReferences$Type extends MessageType<ExamplesOrReferences> {
    constructor() {
        super("gnostic.openapi.v3.ExamplesOrReferences", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedExampleOrReference }
        ]);
    }
    create(value?: PartialMessage<ExamplesOrReferences>): ExamplesOrReferences {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExamplesOrReferences>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExamplesOrReferences): ExamplesOrReferences {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedExampleOrReference additional_properties */ 1:
                    message.additionalProperties.push(NamedExampleOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExamplesOrReferences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedExampleOrReference additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedExampleOrReference.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.ExamplesOrReferences
 */
export const ExamplesOrReferences = new ExamplesOrReferences$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression$Type extends MessageType<Expression> {
    constructor() {
        super("gnostic.openapi.v3.Expression", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Expression>): Expression {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression): Expression {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedAny additional_properties */ 1:
                    message.additionalProperties.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedAny additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedAny.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Expression
 */
export const Expression = new Expression$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExternalDocs$Type extends MessageType<ExternalDocs> {
    constructor() {
        super("gnostic.openapi.v3.ExternalDocs", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<ExternalDocs>): ExternalDocs {
        const message = { description: "", url: "", specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExternalDocs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExternalDocs): ExternalDocs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 3:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExternalDocs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 3; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.ExternalDocs
 */
export const ExternalDocs = new ExternalDocs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Header$Type extends MessageType<Header> {
    constructor() {
        super("gnostic.openapi.v3.Header", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "deprecated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "allow_empty_value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "style", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "explode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "allow_reserved", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "schema", kind: "message", T: () => SchemaOrReference },
            { no: 9, name: "example", kind: "message", T: () => Any },
            { no: 10, name: "examples", kind: "message", T: () => ExamplesOrReferences },
            { no: 11, name: "content", kind: "message", T: () => MediaTypes },
            { no: 12, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Header>): Header {
        const message = { description: "", required: false, deprecated: false, allowEmptyValue: false, style: "", explode: false, allowReserved: false, specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Header>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Header): Header {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* bool required */ 2:
                    message.required = reader.bool();
                    break;
                case /* bool deprecated */ 3:
                    message.deprecated = reader.bool();
                    break;
                case /* bool allow_empty_value */ 4:
                    message.allowEmptyValue = reader.bool();
                    break;
                case /* string style */ 5:
                    message.style = reader.string();
                    break;
                case /* bool explode */ 6:
                    message.explode = reader.bool();
                    break;
                case /* bool allow_reserved */ 7:
                    message.allowReserved = reader.bool();
                    break;
                case /* gnostic.openapi.v3.SchemaOrReference schema */ 8:
                    message.schema = SchemaOrReference.internalBinaryRead(reader, reader.uint32(), options, message.schema);
                    break;
                case /* gnostic.openapi.v3.Any example */ 9:
                    message.example = Any.internalBinaryRead(reader, reader.uint32(), options, message.example);
                    break;
                case /* gnostic.openapi.v3.ExamplesOrReferences examples */ 10:
                    message.examples = ExamplesOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.examples);
                    break;
                case /* gnostic.openapi.v3.MediaTypes content */ 11:
                    message.content = MediaTypes.internalBinaryRead(reader, reader.uint32(), options, message.content);
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 12:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Header, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* bool required = 2; */
        if (message.required !== false)
            writer.tag(2, WireType.Varint).bool(message.required);
        /* bool deprecated = 3; */
        if (message.deprecated !== false)
            writer.tag(3, WireType.Varint).bool(message.deprecated);
        /* bool allow_empty_value = 4; */
        if (message.allowEmptyValue !== false)
            writer.tag(4, WireType.Varint).bool(message.allowEmptyValue);
        /* string style = 5; */
        if (message.style !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.style);
        /* bool explode = 6; */
        if (message.explode !== false)
            writer.tag(6, WireType.Varint).bool(message.explode);
        /* bool allow_reserved = 7; */
        if (message.allowReserved !== false)
            writer.tag(7, WireType.Varint).bool(message.allowReserved);
        /* gnostic.openapi.v3.SchemaOrReference schema = 8; */
        if (message.schema)
            SchemaOrReference.internalBinaryWrite(message.schema, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Any example = 9; */
        if (message.example)
            Any.internalBinaryWrite(message.example, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.ExamplesOrReferences examples = 10; */
        if (message.examples)
            ExamplesOrReferences.internalBinaryWrite(message.examples, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.MediaTypes content = 11; */
        if (message.content)
            MediaTypes.internalBinaryWrite(message.content, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 12; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Header
 */
export const Header = new Header$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderOrReference$Type extends MessageType<HeaderOrReference> {
    constructor() {
        super("gnostic.openapi.v3.HeaderOrReference", [
            { no: 1, name: "header", kind: "message", oneof: "oneof", T: () => Header },
            { no: 2, name: "reference", kind: "message", oneof: "oneof", T: () => Reference }
        ]);
    }
    create(value?: PartialMessage<HeaderOrReference>): HeaderOrReference {
        const message = { oneof: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeaderOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaderOrReference): HeaderOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gnostic.openapi.v3.Header header */ 1:
                    message.oneof = {
                        oneofKind: "header",
                        header: Header.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).header)
                    };
                    break;
                case /* gnostic.openapi.v3.Reference reference */ 2:
                    message.oneof = {
                        oneofKind: "reference",
                        reference: Reference.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).reference)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaderOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gnostic.openapi.v3.Header header = 1; */
        if (message.oneof.oneofKind === "header")
            Header.internalBinaryWrite(message.oneof.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Reference reference = 2; */
        if (message.oneof.oneofKind === "reference")
            Reference.internalBinaryWrite(message.oneof.reference, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.HeaderOrReference
 */
export const HeaderOrReference = new HeaderOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeadersOrReferences$Type extends MessageType<HeadersOrReferences> {
    constructor() {
        super("gnostic.openapi.v3.HeadersOrReferences", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedHeaderOrReference }
        ]);
    }
    create(value?: PartialMessage<HeadersOrReferences>): HeadersOrReferences {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeadersOrReferences>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeadersOrReferences): HeadersOrReferences {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedHeaderOrReference additional_properties */ 1:
                    message.additionalProperties.push(NamedHeaderOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeadersOrReferences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedHeaderOrReference additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedHeaderOrReference.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.HeadersOrReferences
 */
export const HeadersOrReferences = new HeadersOrReferences$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info$Type extends MessageType<Info> {
    constructor() {
        super("gnostic.openapi.v3.Info", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "terms_of_service", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "contact", kind: "message", T: () => Contact },
            { no: 5, name: "license", kind: "message", T: () => License },
            { no: 6, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny },
            { no: 8, name: "summary", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Info>): Info {
        const message = { title: "", description: "", termsOfService: "", version: "", specificationExtension: [], summary: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Info>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info): Info {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string terms_of_service */ 3:
                    message.termsOfService = reader.string();
                    break;
                case /* gnostic.openapi.v3.Contact contact */ 4:
                    message.contact = Contact.internalBinaryRead(reader, reader.uint32(), options, message.contact);
                    break;
                case /* gnostic.openapi.v3.License license */ 5:
                    message.license = License.internalBinaryRead(reader, reader.uint32(), options, message.license);
                    break;
                case /* string version */ 6:
                    message.version = reader.string();
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 7:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string summary */ 8:
                    message.summary = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Info, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string terms_of_service = 3; */
        if (message.termsOfService !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.termsOfService);
        /* gnostic.openapi.v3.Contact contact = 4; */
        if (message.contact)
            Contact.internalBinaryWrite(message.contact, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.License license = 5; */
        if (message.license)
            License.internalBinaryWrite(message.license, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string version = 6; */
        if (message.version !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.version);
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 7; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string summary = 8; */
        if (message.summary !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.summary);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Info
 */
export const Info = new Info$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ItemsItem$Type extends MessageType<ItemsItem> {
    constructor() {
        super("gnostic.openapi.v3.ItemsItem", [
            { no: 1, name: "schema_or_reference", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SchemaOrReference }
        ]);
    }
    create(value?: PartialMessage<ItemsItem>): ItemsItem {
        const message = { schemaOrReference: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ItemsItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ItemsItem): ItemsItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.SchemaOrReference schema_or_reference */ 1:
                    message.schemaOrReference.push(SchemaOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ItemsItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1; */
        for (let i = 0; i < message.schemaOrReference.length; i++)
            SchemaOrReference.internalBinaryWrite(message.schemaOrReference[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.ItemsItem
 */
export const ItemsItem = new ItemsItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class License$Type extends MessageType<License> {
    constructor() {
        super("gnostic.openapi.v3.License", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<License>): License {
        const message = { name: "", url: "", specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<License>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: License): License {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 3:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: License, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 3; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.License
 */
export const License = new License$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Link$Type extends MessageType<Link> {
    constructor() {
        super("gnostic.openapi.v3.Link", [
            { no: 1, name: "operation_ref", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "operation_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "parameters", kind: "message", T: () => AnyOrExpression },
            { no: 4, name: "request_body", kind: "message", T: () => AnyOrExpression },
            { no: 5, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "server", kind: "message", T: () => Server },
            { no: 7, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Link>): Link {
        const message = { operationRef: "", operationId: "", description: "", specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Link>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Link): Link {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string operation_ref */ 1:
                    message.operationRef = reader.string();
                    break;
                case /* string operation_id */ 2:
                    message.operationId = reader.string();
                    break;
                case /* gnostic.openapi.v3.AnyOrExpression parameters */ 3:
                    message.parameters = AnyOrExpression.internalBinaryRead(reader, reader.uint32(), options, message.parameters);
                    break;
                case /* gnostic.openapi.v3.AnyOrExpression request_body */ 4:
                    message.requestBody = AnyOrExpression.internalBinaryRead(reader, reader.uint32(), options, message.requestBody);
                    break;
                case /* string description */ 5:
                    message.description = reader.string();
                    break;
                case /* gnostic.openapi.v3.Server server */ 6:
                    message.server = Server.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 7:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Link, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string operation_ref = 1; */
        if (message.operationRef !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.operationRef);
        /* string operation_id = 2; */
        if (message.operationId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operationId);
        /* gnostic.openapi.v3.AnyOrExpression parameters = 3; */
        if (message.parameters)
            AnyOrExpression.internalBinaryWrite(message.parameters, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.AnyOrExpression request_body = 4; */
        if (message.requestBody)
            AnyOrExpression.internalBinaryWrite(message.requestBody, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string description = 5; */
        if (message.description !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.description);
        /* gnostic.openapi.v3.Server server = 6; */
        if (message.server)
            Server.internalBinaryWrite(message.server, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 7; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Link
 */
export const Link = new Link$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LinkOrReference$Type extends MessageType<LinkOrReference> {
    constructor() {
        super("gnostic.openapi.v3.LinkOrReference", [
            { no: 1, name: "link", kind: "message", oneof: "oneof", T: () => Link },
            { no: 2, name: "reference", kind: "message", oneof: "oneof", T: () => Reference }
        ]);
    }
    create(value?: PartialMessage<LinkOrReference>): LinkOrReference {
        const message = { oneof: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LinkOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LinkOrReference): LinkOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gnostic.openapi.v3.Link link */ 1:
                    message.oneof = {
                        oneofKind: "link",
                        link: Link.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).link)
                    };
                    break;
                case /* gnostic.openapi.v3.Reference reference */ 2:
                    message.oneof = {
                        oneofKind: "reference",
                        reference: Reference.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).reference)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LinkOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gnostic.openapi.v3.Link link = 1; */
        if (message.oneof.oneofKind === "link")
            Link.internalBinaryWrite(message.oneof.link, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Reference reference = 2; */
        if (message.oneof.oneofKind === "reference")
            Reference.internalBinaryWrite(message.oneof.reference, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.LinkOrReference
 */
export const LinkOrReference = new LinkOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LinksOrReferences$Type extends MessageType<LinksOrReferences> {
    constructor() {
        super("gnostic.openapi.v3.LinksOrReferences", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedLinkOrReference }
        ]);
    }
    create(value?: PartialMessage<LinksOrReferences>): LinksOrReferences {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LinksOrReferences>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LinksOrReferences): LinksOrReferences {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedLinkOrReference additional_properties */ 1:
                    message.additionalProperties.push(NamedLinkOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LinksOrReferences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedLinkOrReference additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedLinkOrReference.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.LinksOrReferences
 */
export const LinksOrReferences = new LinksOrReferences$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MediaType$Type extends MessageType<MediaType> {
    constructor() {
        super("gnostic.openapi.v3.MediaType", [
            { no: 1, name: "schema", kind: "message", T: () => SchemaOrReference },
            { no: 2, name: "example", kind: "message", T: () => Any },
            { no: 3, name: "examples", kind: "message", T: () => ExamplesOrReferences },
            { no: 4, name: "encoding", kind: "message", T: () => Encodings },
            { no: 5, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<MediaType>): MediaType {
        const message = { specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MediaType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MediaType): MediaType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gnostic.openapi.v3.SchemaOrReference schema */ 1:
                    message.schema = SchemaOrReference.internalBinaryRead(reader, reader.uint32(), options, message.schema);
                    break;
                case /* gnostic.openapi.v3.Any example */ 2:
                    message.example = Any.internalBinaryRead(reader, reader.uint32(), options, message.example);
                    break;
                case /* gnostic.openapi.v3.ExamplesOrReferences examples */ 3:
                    message.examples = ExamplesOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.examples);
                    break;
                case /* gnostic.openapi.v3.Encodings encoding */ 4:
                    message.encoding = Encodings.internalBinaryRead(reader, reader.uint32(), options, message.encoding);
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 5:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MediaType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gnostic.openapi.v3.SchemaOrReference schema = 1; */
        if (message.schema)
            SchemaOrReference.internalBinaryWrite(message.schema, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Any example = 2; */
        if (message.example)
            Any.internalBinaryWrite(message.example, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.ExamplesOrReferences examples = 3; */
        if (message.examples)
            ExamplesOrReferences.internalBinaryWrite(message.examples, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Encodings encoding = 4; */
        if (message.encoding)
            Encodings.internalBinaryWrite(message.encoding, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 5; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.MediaType
 */
export const MediaType = new MediaType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MediaTypes$Type extends MessageType<MediaTypes> {
    constructor() {
        super("gnostic.openapi.v3.MediaTypes", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedMediaType }
        ]);
    }
    create(value?: PartialMessage<MediaTypes>): MediaTypes {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MediaTypes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MediaTypes): MediaTypes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedMediaType additional_properties */ 1:
                    message.additionalProperties.push(NamedMediaType.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MediaTypes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedMediaType additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedMediaType.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.MediaTypes
 */
export const MediaTypes = new MediaTypes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedAny$Type extends MessageType<NamedAny> {
    constructor() {
        super("gnostic.openapi.v3.NamedAny", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<NamedAny>): NamedAny {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedAny>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedAny): NamedAny {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* gnostic.openapi.v3.Any value */ 2:
                    message.value = Any.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedAny, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* gnostic.openapi.v3.Any value = 2; */
        if (message.value)
            Any.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedAny
 */
export const NamedAny = new NamedAny$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedCallbackOrReference$Type extends MessageType<NamedCallbackOrReference> {
    constructor() {
        super("gnostic.openapi.v3.NamedCallbackOrReference", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => CallbackOrReference }
        ]);
    }
    create(value?: PartialMessage<NamedCallbackOrReference>): NamedCallbackOrReference {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedCallbackOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedCallbackOrReference): NamedCallbackOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* gnostic.openapi.v3.CallbackOrReference value */ 2:
                    message.value = CallbackOrReference.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedCallbackOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* gnostic.openapi.v3.CallbackOrReference value = 2; */
        if (message.value)
            CallbackOrReference.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedCallbackOrReference
 */
export const NamedCallbackOrReference = new NamedCallbackOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedEncoding$Type extends MessageType<NamedEncoding> {
    constructor() {
        super("gnostic.openapi.v3.NamedEncoding", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => Encoding }
        ]);
    }
    create(value?: PartialMessage<NamedEncoding>): NamedEncoding {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedEncoding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedEncoding): NamedEncoding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* gnostic.openapi.v3.Encoding value */ 2:
                    message.value = Encoding.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedEncoding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* gnostic.openapi.v3.Encoding value = 2; */
        if (message.value)
            Encoding.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedEncoding
 */
export const NamedEncoding = new NamedEncoding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedExampleOrReference$Type extends MessageType<NamedExampleOrReference> {
    constructor() {
        super("gnostic.openapi.v3.NamedExampleOrReference", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => ExampleOrReference }
        ]);
    }
    create(value?: PartialMessage<NamedExampleOrReference>): NamedExampleOrReference {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedExampleOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedExampleOrReference): NamedExampleOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* gnostic.openapi.v3.ExampleOrReference value */ 2:
                    message.value = ExampleOrReference.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedExampleOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* gnostic.openapi.v3.ExampleOrReference value = 2; */
        if (message.value)
            ExampleOrReference.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedExampleOrReference
 */
export const NamedExampleOrReference = new NamedExampleOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedHeaderOrReference$Type extends MessageType<NamedHeaderOrReference> {
    constructor() {
        super("gnostic.openapi.v3.NamedHeaderOrReference", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => HeaderOrReference }
        ]);
    }
    create(value?: PartialMessage<NamedHeaderOrReference>): NamedHeaderOrReference {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedHeaderOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedHeaderOrReference): NamedHeaderOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* gnostic.openapi.v3.HeaderOrReference value */ 2:
                    message.value = HeaderOrReference.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedHeaderOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* gnostic.openapi.v3.HeaderOrReference value = 2; */
        if (message.value)
            HeaderOrReference.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedHeaderOrReference
 */
export const NamedHeaderOrReference = new NamedHeaderOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedLinkOrReference$Type extends MessageType<NamedLinkOrReference> {
    constructor() {
        super("gnostic.openapi.v3.NamedLinkOrReference", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => LinkOrReference }
        ]);
    }
    create(value?: PartialMessage<NamedLinkOrReference>): NamedLinkOrReference {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedLinkOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedLinkOrReference): NamedLinkOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* gnostic.openapi.v3.LinkOrReference value */ 2:
                    message.value = LinkOrReference.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedLinkOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* gnostic.openapi.v3.LinkOrReference value = 2; */
        if (message.value)
            LinkOrReference.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedLinkOrReference
 */
export const NamedLinkOrReference = new NamedLinkOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedMediaType$Type extends MessageType<NamedMediaType> {
    constructor() {
        super("gnostic.openapi.v3.NamedMediaType", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => MediaType }
        ]);
    }
    create(value?: PartialMessage<NamedMediaType>): NamedMediaType {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedMediaType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedMediaType): NamedMediaType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* gnostic.openapi.v3.MediaType value */ 2:
                    message.value = MediaType.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedMediaType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* gnostic.openapi.v3.MediaType value = 2; */
        if (message.value)
            MediaType.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedMediaType
 */
export const NamedMediaType = new NamedMediaType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedParameterOrReference$Type extends MessageType<NamedParameterOrReference> {
    constructor() {
        super("gnostic.openapi.v3.NamedParameterOrReference", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => ParameterOrReference }
        ]);
    }
    create(value?: PartialMessage<NamedParameterOrReference>): NamedParameterOrReference {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedParameterOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedParameterOrReference): NamedParameterOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* gnostic.openapi.v3.ParameterOrReference value */ 2:
                    message.value = ParameterOrReference.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedParameterOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* gnostic.openapi.v3.ParameterOrReference value = 2; */
        if (message.value)
            ParameterOrReference.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedParameterOrReference
 */
export const NamedParameterOrReference = new NamedParameterOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedPathItem$Type extends MessageType<NamedPathItem> {
    constructor() {
        super("gnostic.openapi.v3.NamedPathItem", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => PathItem }
        ]);
    }
    create(value?: PartialMessage<NamedPathItem>): NamedPathItem {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedPathItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedPathItem): NamedPathItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* gnostic.openapi.v3.PathItem value */ 2:
                    message.value = PathItem.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedPathItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* gnostic.openapi.v3.PathItem value = 2; */
        if (message.value)
            PathItem.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedPathItem
 */
export const NamedPathItem = new NamedPathItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedRequestBodyOrReference$Type extends MessageType<NamedRequestBodyOrReference> {
    constructor() {
        super("gnostic.openapi.v3.NamedRequestBodyOrReference", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => RequestBodyOrReference }
        ]);
    }
    create(value?: PartialMessage<NamedRequestBodyOrReference>): NamedRequestBodyOrReference {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedRequestBodyOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedRequestBodyOrReference): NamedRequestBodyOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* gnostic.openapi.v3.RequestBodyOrReference value */ 2:
                    message.value = RequestBodyOrReference.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedRequestBodyOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* gnostic.openapi.v3.RequestBodyOrReference value = 2; */
        if (message.value)
            RequestBodyOrReference.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedRequestBodyOrReference
 */
export const NamedRequestBodyOrReference = new NamedRequestBodyOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedResponseOrReference$Type extends MessageType<NamedResponseOrReference> {
    constructor() {
        super("gnostic.openapi.v3.NamedResponseOrReference", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => ResponseOrReference }
        ]);
    }
    create(value?: PartialMessage<NamedResponseOrReference>): NamedResponseOrReference {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedResponseOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedResponseOrReference): NamedResponseOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* gnostic.openapi.v3.ResponseOrReference value */ 2:
                    message.value = ResponseOrReference.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedResponseOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* gnostic.openapi.v3.ResponseOrReference value = 2; */
        if (message.value)
            ResponseOrReference.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedResponseOrReference
 */
export const NamedResponseOrReference = new NamedResponseOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedSchemaOrReference$Type extends MessageType<NamedSchemaOrReference> {
    constructor() {
        super("gnostic.openapi.v3.NamedSchemaOrReference", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => SchemaOrReference }
        ]);
    }
    create(value?: PartialMessage<NamedSchemaOrReference>): NamedSchemaOrReference {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedSchemaOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedSchemaOrReference): NamedSchemaOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* gnostic.openapi.v3.SchemaOrReference value */ 2:
                    message.value = SchemaOrReference.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedSchemaOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* gnostic.openapi.v3.SchemaOrReference value = 2; */
        if (message.value)
            SchemaOrReference.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedSchemaOrReference
 */
export const NamedSchemaOrReference = new NamedSchemaOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedSecuritySchemeOrReference$Type extends MessageType<NamedSecuritySchemeOrReference> {
    constructor() {
        super("gnostic.openapi.v3.NamedSecuritySchemeOrReference", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => SecuritySchemeOrReference }
        ]);
    }
    create(value?: PartialMessage<NamedSecuritySchemeOrReference>): NamedSecuritySchemeOrReference {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedSecuritySchemeOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedSecuritySchemeOrReference): NamedSecuritySchemeOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* gnostic.openapi.v3.SecuritySchemeOrReference value */ 2:
                    message.value = SecuritySchemeOrReference.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedSecuritySchemeOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* gnostic.openapi.v3.SecuritySchemeOrReference value = 2; */
        if (message.value)
            SecuritySchemeOrReference.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedSecuritySchemeOrReference
 */
export const NamedSecuritySchemeOrReference = new NamedSecuritySchemeOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedServerVariable$Type extends MessageType<NamedServerVariable> {
    constructor() {
        super("gnostic.openapi.v3.NamedServerVariable", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => ServerVariable }
        ]);
    }
    create(value?: PartialMessage<NamedServerVariable>): NamedServerVariable {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedServerVariable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedServerVariable): NamedServerVariable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* gnostic.openapi.v3.ServerVariable value */ 2:
                    message.value = ServerVariable.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedServerVariable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* gnostic.openapi.v3.ServerVariable value = 2; */
        if (message.value)
            ServerVariable.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedServerVariable
 */
export const NamedServerVariable = new NamedServerVariable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedString$Type extends MessageType<NamedString> {
    constructor() {
        super("gnostic.openapi.v3.NamedString", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NamedString>): NamedString {
        const message = { name: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedString>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedString): NamedString {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedString
 */
export const NamedString = new NamedString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedStringArray$Type extends MessageType<NamedStringArray> {
    constructor() {
        super("gnostic.openapi.v3.NamedStringArray", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => StringArray }
        ]);
    }
    create(value?: PartialMessage<NamedStringArray>): NamedStringArray {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedStringArray>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedStringArray): NamedStringArray {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* gnostic.openapi.v3.StringArray value */ 2:
                    message.value = StringArray.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedStringArray, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* gnostic.openapi.v3.StringArray value = 2; */
        if (message.value)
            StringArray.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.NamedStringArray
 */
export const NamedStringArray = new NamedStringArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OauthFlow$Type extends MessageType<OauthFlow> {
    constructor() {
        super("gnostic.openapi.v3.OauthFlow", [
            { no: 1, name: "authorization_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "refresh_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "scopes", kind: "message", T: () => Strings },
            { no: 5, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<OauthFlow>): OauthFlow {
        const message = { authorizationUrl: "", tokenUrl: "", refreshUrl: "", specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OauthFlow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OauthFlow): OauthFlow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authorization_url */ 1:
                    message.authorizationUrl = reader.string();
                    break;
                case /* string token_url */ 2:
                    message.tokenUrl = reader.string();
                    break;
                case /* string refresh_url */ 3:
                    message.refreshUrl = reader.string();
                    break;
                case /* gnostic.openapi.v3.Strings scopes */ 4:
                    message.scopes = Strings.internalBinaryRead(reader, reader.uint32(), options, message.scopes);
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 5:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OauthFlow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authorization_url = 1; */
        if (message.authorizationUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authorizationUrl);
        /* string token_url = 2; */
        if (message.tokenUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tokenUrl);
        /* string refresh_url = 3; */
        if (message.refreshUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.refreshUrl);
        /* gnostic.openapi.v3.Strings scopes = 4; */
        if (message.scopes)
            Strings.internalBinaryWrite(message.scopes, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 5; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.OauthFlow
 */
export const OauthFlow = new OauthFlow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OauthFlows$Type extends MessageType<OauthFlows> {
    constructor() {
        super("gnostic.openapi.v3.OauthFlows", [
            { no: 1, name: "implicit", kind: "message", T: () => OauthFlow },
            { no: 2, name: "password", kind: "message", T: () => OauthFlow },
            { no: 3, name: "client_credentials", kind: "message", T: () => OauthFlow },
            { no: 4, name: "authorization_code", kind: "message", T: () => OauthFlow },
            { no: 5, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<OauthFlows>): OauthFlows {
        const message = { specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OauthFlows>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OauthFlows): OauthFlows {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gnostic.openapi.v3.OauthFlow implicit */ 1:
                    message.implicit = OauthFlow.internalBinaryRead(reader, reader.uint32(), options, message.implicit);
                    break;
                case /* gnostic.openapi.v3.OauthFlow password */ 2:
                    message.password = OauthFlow.internalBinaryRead(reader, reader.uint32(), options, message.password);
                    break;
                case /* gnostic.openapi.v3.OauthFlow client_credentials */ 3:
                    message.clientCredentials = OauthFlow.internalBinaryRead(reader, reader.uint32(), options, message.clientCredentials);
                    break;
                case /* gnostic.openapi.v3.OauthFlow authorization_code */ 4:
                    message.authorizationCode = OauthFlow.internalBinaryRead(reader, reader.uint32(), options, message.authorizationCode);
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 5:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OauthFlows, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gnostic.openapi.v3.OauthFlow implicit = 1; */
        if (message.implicit)
            OauthFlow.internalBinaryWrite(message.implicit, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.OauthFlow password = 2; */
        if (message.password)
            OauthFlow.internalBinaryWrite(message.password, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.OauthFlow client_credentials = 3; */
        if (message.clientCredentials)
            OauthFlow.internalBinaryWrite(message.clientCredentials, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.OauthFlow authorization_code = 4; */
        if (message.authorizationCode)
            OauthFlow.internalBinaryWrite(message.authorizationCode, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 5; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.OauthFlows
 */
export const OauthFlows = new OauthFlows$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object$Type extends MessageType<Object> {
    constructor() {
        super("gnostic.openapi.v3.Object", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Object>): Object {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Object>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object): Object {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedAny additional_properties */ 1:
                    message.additionalProperties.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedAny additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedAny.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Object
 */
export const Object = new Object$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Operation$Type extends MessageType<Operation> {
    constructor() {
        super("gnostic.openapi.v3.Operation", [
            { no: 1, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "summary", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "external_docs", kind: "message", T: () => ExternalDocs },
            { no: 5, name: "operation_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ParameterOrReference },
            { no: 7, name: "request_body", kind: "message", T: () => RequestBodyOrReference },
            { no: 8, name: "responses", kind: "message", T: () => Responses },
            { no: 9, name: "callbacks", kind: "message", T: () => CallbacksOrReferences },
            { no: 10, name: "deprecated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "security", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SecurityRequirement },
            { no: 12, name: "servers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Server },
            { no: 13, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Operation>): Operation {
        const message = { tags: [], summary: "", description: "", operationId: "", parameters: [], deprecated: false, security: [], servers: [], specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Operation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Operation): Operation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string tags */ 1:
                    message.tags.push(reader.string());
                    break;
                case /* string summary */ 2:
                    message.summary = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* gnostic.openapi.v3.ExternalDocs external_docs */ 4:
                    message.externalDocs = ExternalDocs.internalBinaryRead(reader, reader.uint32(), options, message.externalDocs);
                    break;
                case /* string operation_id */ 5:
                    message.operationId = reader.string();
                    break;
                case /* repeated gnostic.openapi.v3.ParameterOrReference parameters */ 6:
                    message.parameters.push(ParameterOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* gnostic.openapi.v3.RequestBodyOrReference request_body */ 7:
                    message.requestBody = RequestBodyOrReference.internalBinaryRead(reader, reader.uint32(), options, message.requestBody);
                    break;
                case /* gnostic.openapi.v3.Responses responses */ 8:
                    message.responses = Responses.internalBinaryRead(reader, reader.uint32(), options, message.responses);
                    break;
                case /* gnostic.openapi.v3.CallbacksOrReferences callbacks */ 9:
                    message.callbacks = CallbacksOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.callbacks);
                    break;
                case /* bool deprecated */ 10:
                    message.deprecated = reader.bool();
                    break;
                case /* repeated gnostic.openapi.v3.SecurityRequirement security */ 11:
                    message.security.push(SecurityRequirement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated gnostic.openapi.v3.Server servers */ 12:
                    message.servers.push(Server.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 13:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Operation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string tags = 1; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.tags[i]);
        /* string summary = 2; */
        if (message.summary !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.summary);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* gnostic.openapi.v3.ExternalDocs external_docs = 4; */
        if (message.externalDocs)
            ExternalDocs.internalBinaryWrite(message.externalDocs, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string operation_id = 5; */
        if (message.operationId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.operationId);
        /* repeated gnostic.openapi.v3.ParameterOrReference parameters = 6; */
        for (let i = 0; i < message.parameters.length; i++)
            ParameterOrReference.internalBinaryWrite(message.parameters[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.RequestBodyOrReference request_body = 7; */
        if (message.requestBody)
            RequestBodyOrReference.internalBinaryWrite(message.requestBody, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Responses responses = 8; */
        if (message.responses)
            Responses.internalBinaryWrite(message.responses, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.CallbacksOrReferences callbacks = 9; */
        if (message.callbacks)
            CallbacksOrReferences.internalBinaryWrite(message.callbacks, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* bool deprecated = 10; */
        if (message.deprecated !== false)
            writer.tag(10, WireType.Varint).bool(message.deprecated);
        /* repeated gnostic.openapi.v3.SecurityRequirement security = 11; */
        for (let i = 0; i < message.security.length; i++)
            SecurityRequirement.internalBinaryWrite(message.security[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.Server servers = 12; */
        for (let i = 0; i < message.servers.length; i++)
            Server.internalBinaryWrite(message.servers[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 13; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Operation
 */
export const Operation = new Operation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Parameter$Type extends MessageType<Parameter> {
    constructor() {
        super("gnostic.openapi.v3.Parameter", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "in", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "deprecated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "allow_empty_value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "style", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "explode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "allow_reserved", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "schema", kind: "message", T: () => SchemaOrReference },
            { no: 11, name: "example", kind: "message", T: () => Any },
            { no: 12, name: "examples", kind: "message", T: () => ExamplesOrReferences },
            { no: 13, name: "content", kind: "message", T: () => MediaTypes },
            { no: 14, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Parameter>): Parameter {
        const message = { name: "", in: "", description: "", required: false, deprecated: false, allowEmptyValue: false, style: "", explode: false, allowReserved: false, specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Parameter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Parameter): Parameter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string in */ 2:
                    message.in = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* bool required */ 4:
                    message.required = reader.bool();
                    break;
                case /* bool deprecated */ 5:
                    message.deprecated = reader.bool();
                    break;
                case /* bool allow_empty_value */ 6:
                    message.allowEmptyValue = reader.bool();
                    break;
                case /* string style */ 7:
                    message.style = reader.string();
                    break;
                case /* bool explode */ 8:
                    message.explode = reader.bool();
                    break;
                case /* bool allow_reserved */ 9:
                    message.allowReserved = reader.bool();
                    break;
                case /* gnostic.openapi.v3.SchemaOrReference schema */ 10:
                    message.schema = SchemaOrReference.internalBinaryRead(reader, reader.uint32(), options, message.schema);
                    break;
                case /* gnostic.openapi.v3.Any example */ 11:
                    message.example = Any.internalBinaryRead(reader, reader.uint32(), options, message.example);
                    break;
                case /* gnostic.openapi.v3.ExamplesOrReferences examples */ 12:
                    message.examples = ExamplesOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.examples);
                    break;
                case /* gnostic.openapi.v3.MediaTypes content */ 13:
                    message.content = MediaTypes.internalBinaryRead(reader, reader.uint32(), options, message.content);
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 14:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Parameter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string in = 2; */
        if (message.in !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.in);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* bool required = 4; */
        if (message.required !== false)
            writer.tag(4, WireType.Varint).bool(message.required);
        /* bool deprecated = 5; */
        if (message.deprecated !== false)
            writer.tag(5, WireType.Varint).bool(message.deprecated);
        /* bool allow_empty_value = 6; */
        if (message.allowEmptyValue !== false)
            writer.tag(6, WireType.Varint).bool(message.allowEmptyValue);
        /* string style = 7; */
        if (message.style !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.style);
        /* bool explode = 8; */
        if (message.explode !== false)
            writer.tag(8, WireType.Varint).bool(message.explode);
        /* bool allow_reserved = 9; */
        if (message.allowReserved !== false)
            writer.tag(9, WireType.Varint).bool(message.allowReserved);
        /* gnostic.openapi.v3.SchemaOrReference schema = 10; */
        if (message.schema)
            SchemaOrReference.internalBinaryWrite(message.schema, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Any example = 11; */
        if (message.example)
            Any.internalBinaryWrite(message.example, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.ExamplesOrReferences examples = 12; */
        if (message.examples)
            ExamplesOrReferences.internalBinaryWrite(message.examples, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.MediaTypes content = 13; */
        if (message.content)
            MediaTypes.internalBinaryWrite(message.content, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 14; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Parameter
 */
export const Parameter = new Parameter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParameterOrReference$Type extends MessageType<ParameterOrReference> {
    constructor() {
        super("gnostic.openapi.v3.ParameterOrReference", [
            { no: 1, name: "parameter", kind: "message", oneof: "oneof", T: () => Parameter },
            { no: 2, name: "reference", kind: "message", oneof: "oneof", T: () => Reference }
        ]);
    }
    create(value?: PartialMessage<ParameterOrReference>): ParameterOrReference {
        const message = { oneof: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ParameterOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParameterOrReference): ParameterOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gnostic.openapi.v3.Parameter parameter */ 1:
                    message.oneof = {
                        oneofKind: "parameter",
                        parameter: Parameter.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).parameter)
                    };
                    break;
                case /* gnostic.openapi.v3.Reference reference */ 2:
                    message.oneof = {
                        oneofKind: "reference",
                        reference: Reference.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).reference)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParameterOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gnostic.openapi.v3.Parameter parameter = 1; */
        if (message.oneof.oneofKind === "parameter")
            Parameter.internalBinaryWrite(message.oneof.parameter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Reference reference = 2; */
        if (message.oneof.oneofKind === "reference")
            Reference.internalBinaryWrite(message.oneof.reference, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.ParameterOrReference
 */
export const ParameterOrReference = new ParameterOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParametersOrReferences$Type extends MessageType<ParametersOrReferences> {
    constructor() {
        super("gnostic.openapi.v3.ParametersOrReferences", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedParameterOrReference }
        ]);
    }
    create(value?: PartialMessage<ParametersOrReferences>): ParametersOrReferences {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ParametersOrReferences>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParametersOrReferences): ParametersOrReferences {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedParameterOrReference additional_properties */ 1:
                    message.additionalProperties.push(NamedParameterOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParametersOrReferences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedParameterOrReference additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedParameterOrReference.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.ParametersOrReferences
 */
export const ParametersOrReferences = new ParametersOrReferences$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PathItem$Type extends MessageType<PathItem> {
    constructor() {
        super("gnostic.openapi.v3.PathItem", [
            { no: 1, name: "_ref", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "summary", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "get", kind: "message", T: () => Operation },
            { no: 5, name: "put", kind: "message", T: () => Operation },
            { no: 6, name: "post", kind: "message", T: () => Operation },
            { no: 7, name: "delete", kind: "message", T: () => Operation },
            { no: 8, name: "options", kind: "message", T: () => Operation },
            { no: 9, name: "head", kind: "message", T: () => Operation },
            { no: 10, name: "patch", kind: "message", T: () => Operation },
            { no: 11, name: "trace", kind: "message", T: () => Operation },
            { no: 12, name: "servers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Server },
            { no: 13, name: "parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ParameterOrReference },
            { no: 14, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<PathItem>): PathItem {
        const message = { Ref: "", summary: "", description: "", servers: [], parameters: [], specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PathItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PathItem): PathItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string _ref */ 1:
                    message.Ref = reader.string();
                    break;
                case /* string summary */ 2:
                    message.summary = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* gnostic.openapi.v3.Operation get */ 4:
                    message.get = Operation.internalBinaryRead(reader, reader.uint32(), options, message.get);
                    break;
                case /* gnostic.openapi.v3.Operation put */ 5:
                    message.put = Operation.internalBinaryRead(reader, reader.uint32(), options, message.put);
                    break;
                case /* gnostic.openapi.v3.Operation post */ 6:
                    message.post = Operation.internalBinaryRead(reader, reader.uint32(), options, message.post);
                    break;
                case /* gnostic.openapi.v3.Operation delete */ 7:
                    message.delete = Operation.internalBinaryRead(reader, reader.uint32(), options, message.delete);
                    break;
                case /* gnostic.openapi.v3.Operation options */ 8:
                    message.options = Operation.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                case /* gnostic.openapi.v3.Operation head */ 9:
                    message.head = Operation.internalBinaryRead(reader, reader.uint32(), options, message.head);
                    break;
                case /* gnostic.openapi.v3.Operation patch */ 10:
                    message.patch = Operation.internalBinaryRead(reader, reader.uint32(), options, message.patch);
                    break;
                case /* gnostic.openapi.v3.Operation trace */ 11:
                    message.trace = Operation.internalBinaryRead(reader, reader.uint32(), options, message.trace);
                    break;
                case /* repeated gnostic.openapi.v3.Server servers */ 12:
                    message.servers.push(Server.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated gnostic.openapi.v3.ParameterOrReference parameters */ 13:
                    message.parameters.push(ParameterOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 14:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PathItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string _ref = 1; */
        if (message.Ref !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.Ref);
        /* string summary = 2; */
        if (message.summary !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.summary);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* gnostic.openapi.v3.Operation get = 4; */
        if (message.get)
            Operation.internalBinaryWrite(message.get, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Operation put = 5; */
        if (message.put)
            Operation.internalBinaryWrite(message.put, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Operation post = 6; */
        if (message.post)
            Operation.internalBinaryWrite(message.post, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Operation delete = 7; */
        if (message.delete)
            Operation.internalBinaryWrite(message.delete, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Operation options = 8; */
        if (message.options)
            Operation.internalBinaryWrite(message.options, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Operation head = 9; */
        if (message.head)
            Operation.internalBinaryWrite(message.head, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Operation patch = 10; */
        if (message.patch)
            Operation.internalBinaryWrite(message.patch, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Operation trace = 11; */
        if (message.trace)
            Operation.internalBinaryWrite(message.trace, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.Server servers = 12; */
        for (let i = 0; i < message.servers.length; i++)
            Server.internalBinaryWrite(message.servers[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.ParameterOrReference parameters = 13; */
        for (let i = 0; i < message.parameters.length; i++)
            ParameterOrReference.internalBinaryWrite(message.parameters[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 14; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.PathItem
 */
export const PathItem = new PathItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Paths$Type extends MessageType<Paths> {
    constructor() {
        super("gnostic.openapi.v3.Paths", [
            { no: 1, name: "path", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedPathItem },
            { no: 2, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Paths>): Paths {
        const message = { path: [], specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Paths>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Paths): Paths {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedPathItem path */ 1:
                    message.path.push(NamedPathItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 2:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Paths, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedPathItem path = 1; */
        for (let i = 0; i < message.path.length; i++)
            NamedPathItem.internalBinaryWrite(message.path[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 2; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Paths
 */
export const Paths = new Paths$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Properties$Type extends MessageType<Properties> {
    constructor() {
        super("gnostic.openapi.v3.Properties", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedSchemaOrReference }
        ]);
    }
    create(value?: PartialMessage<Properties>): Properties {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Properties>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Properties): Properties {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedSchemaOrReference additional_properties */ 1:
                    message.additionalProperties.push(NamedSchemaOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Properties, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedSchemaOrReference.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Properties
 */
export const Properties = new Properties$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Reference$Type extends MessageType<Reference> {
    constructor() {
        super("gnostic.openapi.v3.Reference", [
            { no: 1, name: "_ref", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "summary", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Reference>): Reference {
        const message = { Ref: "", summary: "", description: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Reference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Reference): Reference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string _ref */ 1:
                    message.Ref = reader.string();
                    break;
                case /* string summary */ 2:
                    message.summary = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Reference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string _ref = 1; */
        if (message.Ref !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.Ref);
        /* string summary = 2; */
        if (message.summary !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.summary);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Reference
 */
export const Reference = new Reference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestBodiesOrReferences$Type extends MessageType<RequestBodiesOrReferences> {
    constructor() {
        super("gnostic.openapi.v3.RequestBodiesOrReferences", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedRequestBodyOrReference }
        ]);
    }
    create(value?: PartialMessage<RequestBodiesOrReferences>): RequestBodiesOrReferences {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestBodiesOrReferences>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestBodiesOrReferences): RequestBodiesOrReferences {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedRequestBodyOrReference additional_properties */ 1:
                    message.additionalProperties.push(NamedRequestBodyOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestBodiesOrReferences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedRequestBodyOrReference additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedRequestBodyOrReference.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.RequestBodiesOrReferences
 */
export const RequestBodiesOrReferences = new RequestBodiesOrReferences$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestBody$Type extends MessageType<RequestBody> {
    constructor() {
        super("gnostic.openapi.v3.RequestBody", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "content", kind: "message", T: () => MediaTypes },
            { no: 3, name: "required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<RequestBody>): RequestBody {
        const message = { description: "", required: false, specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestBody): RequestBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* gnostic.openapi.v3.MediaTypes content */ 2:
                    message.content = MediaTypes.internalBinaryRead(reader, reader.uint32(), options, message.content);
                    break;
                case /* bool required */ 3:
                    message.required = reader.bool();
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 4:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* gnostic.openapi.v3.MediaTypes content = 2; */
        if (message.content)
            MediaTypes.internalBinaryWrite(message.content, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool required = 3; */
        if (message.required !== false)
            writer.tag(3, WireType.Varint).bool(message.required);
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 4; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.RequestBody
 */
export const RequestBody = new RequestBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestBodyOrReference$Type extends MessageType<RequestBodyOrReference> {
    constructor() {
        super("gnostic.openapi.v3.RequestBodyOrReference", [
            { no: 1, name: "request_body", kind: "message", oneof: "oneof", T: () => RequestBody },
            { no: 2, name: "reference", kind: "message", oneof: "oneof", T: () => Reference }
        ]);
    }
    create(value?: PartialMessage<RequestBodyOrReference>): RequestBodyOrReference {
        const message = { oneof: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestBodyOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestBodyOrReference): RequestBodyOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gnostic.openapi.v3.RequestBody request_body */ 1:
                    message.oneof = {
                        oneofKind: "requestBody",
                        requestBody: RequestBody.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).requestBody)
                    };
                    break;
                case /* gnostic.openapi.v3.Reference reference */ 2:
                    message.oneof = {
                        oneofKind: "reference",
                        reference: Reference.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).reference)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestBodyOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gnostic.openapi.v3.RequestBody request_body = 1; */
        if (message.oneof.oneofKind === "requestBody")
            RequestBody.internalBinaryWrite(message.oneof.requestBody, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Reference reference = 2; */
        if (message.oneof.oneofKind === "reference")
            Reference.internalBinaryWrite(message.oneof.reference, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.RequestBodyOrReference
 */
export const RequestBodyOrReference = new RequestBodyOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Response$Type extends MessageType<Response> {
    constructor() {
        super("gnostic.openapi.v3.Response", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "headers", kind: "message", T: () => HeadersOrReferences },
            { no: 3, name: "content", kind: "message", T: () => MediaTypes },
            { no: 4, name: "links", kind: "message", T: () => LinksOrReferences },
            { no: 5, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Response>): Response {
        const message = { description: "", specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Response): Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* gnostic.openapi.v3.HeadersOrReferences headers */ 2:
                    message.headers = HeadersOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.headers);
                    break;
                case /* gnostic.openapi.v3.MediaTypes content */ 3:
                    message.content = MediaTypes.internalBinaryRead(reader, reader.uint32(), options, message.content);
                    break;
                case /* gnostic.openapi.v3.LinksOrReferences links */ 4:
                    message.links = LinksOrReferences.internalBinaryRead(reader, reader.uint32(), options, message.links);
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 5:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* gnostic.openapi.v3.HeadersOrReferences headers = 2; */
        if (message.headers)
            HeadersOrReferences.internalBinaryWrite(message.headers, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.MediaTypes content = 3; */
        if (message.content)
            MediaTypes.internalBinaryWrite(message.content, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.LinksOrReferences links = 4; */
        if (message.links)
            LinksOrReferences.internalBinaryWrite(message.links, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 5; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Response
 */
export const Response = new Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseOrReference$Type extends MessageType<ResponseOrReference> {
    constructor() {
        super("gnostic.openapi.v3.ResponseOrReference", [
            { no: 1, name: "response", kind: "message", oneof: "oneof", T: () => Response },
            { no: 2, name: "reference", kind: "message", oneof: "oneof", T: () => Reference }
        ]);
    }
    create(value?: PartialMessage<ResponseOrReference>): ResponseOrReference {
        const message = { oneof: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseOrReference): ResponseOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gnostic.openapi.v3.Response response */ 1:
                    message.oneof = {
                        oneofKind: "response",
                        response: Response.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).response)
                    };
                    break;
                case /* gnostic.openapi.v3.Reference reference */ 2:
                    message.oneof = {
                        oneofKind: "reference",
                        reference: Reference.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).reference)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gnostic.openapi.v3.Response response = 1; */
        if (message.oneof.oneofKind === "response")
            Response.internalBinaryWrite(message.oneof.response, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Reference reference = 2; */
        if (message.oneof.oneofKind === "reference")
            Reference.internalBinaryWrite(message.oneof.reference, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.ResponseOrReference
 */
export const ResponseOrReference = new ResponseOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Responses$Type extends MessageType<Responses> {
    constructor() {
        super("gnostic.openapi.v3.Responses", [
            { no: 1, name: "default", kind: "message", T: () => ResponseOrReference },
            { no: 2, name: "response_or_reference", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedResponseOrReference },
            { no: 3, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Responses>): Responses {
        const message = { responseOrReference: [], specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Responses>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Responses): Responses {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gnostic.openapi.v3.ResponseOrReference default */ 1:
                    message.default = ResponseOrReference.internalBinaryRead(reader, reader.uint32(), options, message.default);
                    break;
                case /* repeated gnostic.openapi.v3.NamedResponseOrReference response_or_reference */ 2:
                    message.responseOrReference.push(NamedResponseOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 3:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Responses, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gnostic.openapi.v3.ResponseOrReference default = 1; */
        if (message.default)
            ResponseOrReference.internalBinaryWrite(message.default, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedResponseOrReference response_or_reference = 2; */
        for (let i = 0; i < message.responseOrReference.length; i++)
            NamedResponseOrReference.internalBinaryWrite(message.responseOrReference[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 3; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Responses
 */
export const Responses = new Responses$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponsesOrReferences$Type extends MessageType<ResponsesOrReferences> {
    constructor() {
        super("gnostic.openapi.v3.ResponsesOrReferences", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedResponseOrReference }
        ]);
    }
    create(value?: PartialMessage<ResponsesOrReferences>): ResponsesOrReferences {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponsesOrReferences>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponsesOrReferences): ResponsesOrReferences {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedResponseOrReference additional_properties */ 1:
                    message.additionalProperties.push(NamedResponseOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponsesOrReferences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedResponseOrReference additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedResponseOrReference.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.ResponsesOrReferences
 */
export const ResponsesOrReferences = new ResponsesOrReferences$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Schema$Type extends MessageType<Schema> {
    constructor() {
        super("gnostic.openapi.v3.Schema", [
            { no: 1, name: "nullable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "discriminator", kind: "message", T: () => Discriminator },
            { no: 3, name: "read_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "write_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "xml", kind: "message", T: () => Xml },
            { no: 6, name: "external_docs", kind: "message", T: () => ExternalDocs },
            { no: 7, name: "example", kind: "message", T: () => Any },
            { no: 8, name: "deprecated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "multiple_of", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 11, name: "maximum", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "exclusive_maximum", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "minimum", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 14, name: "exclusive_minimum", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "max_length", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 16, name: "min_length", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 17, name: "pattern", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "max_items", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 19, name: "min_items", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 20, name: "unique_items", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "max_properties", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 22, name: "min_properties", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 23, name: "required", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "enum", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any },
            { no: 25, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "all_of", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SchemaOrReference },
            { no: 27, name: "one_of", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SchemaOrReference },
            { no: 28, name: "any_of", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SchemaOrReference },
            { no: 29, name: "not", kind: "message", T: () => Schema },
            { no: 30, name: "items", kind: "message", T: () => ItemsItem },
            { no: 31, name: "properties", kind: "message", T: () => Properties },
            { no: 32, name: "additional_properties", kind: "message", T: () => AdditionalPropertiesItem },
            { no: 33, name: "default", kind: "message", T: () => DefaultType },
            { no: 34, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 35, name: "format", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 36, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Schema>): Schema {
        const message = { nullable: false, readOnly: false, writeOnly: false, deprecated: false, title: "", multipleOf: 0, maximum: 0, exclusiveMaximum: false, minimum: 0, exclusiveMinimum: false, maxLength: "0", minLength: "0", pattern: "", maxItems: "0", minItems: "0", uniqueItems: false, maxProperties: "0", minProperties: "0", required: [], enum: [], type: "", allOf: [], oneOf: [], anyOf: [], description: "", format: "", specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Schema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Schema): Schema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool nullable */ 1:
                    message.nullable = reader.bool();
                    break;
                case /* gnostic.openapi.v3.Discriminator discriminator */ 2:
                    message.discriminator = Discriminator.internalBinaryRead(reader, reader.uint32(), options, message.discriminator);
                    break;
                case /* bool read_only */ 3:
                    message.readOnly = reader.bool();
                    break;
                case /* bool write_only */ 4:
                    message.writeOnly = reader.bool();
                    break;
                case /* gnostic.openapi.v3.Xml xml */ 5:
                    message.xml = Xml.internalBinaryRead(reader, reader.uint32(), options, message.xml);
                    break;
                case /* gnostic.openapi.v3.ExternalDocs external_docs */ 6:
                    message.externalDocs = ExternalDocs.internalBinaryRead(reader, reader.uint32(), options, message.externalDocs);
                    break;
                case /* gnostic.openapi.v3.Any example */ 7:
                    message.example = Any.internalBinaryRead(reader, reader.uint32(), options, message.example);
                    break;
                case /* bool deprecated */ 8:
                    message.deprecated = reader.bool();
                    break;
                case /* string title */ 9:
                    message.title = reader.string();
                    break;
                case /* double multiple_of */ 10:
                    message.multipleOf = reader.double();
                    break;
                case /* double maximum */ 11:
                    message.maximum = reader.double();
                    break;
                case /* bool exclusive_maximum */ 12:
                    message.exclusiveMaximum = reader.bool();
                    break;
                case /* double minimum */ 13:
                    message.minimum = reader.double();
                    break;
                case /* bool exclusive_minimum */ 14:
                    message.exclusiveMinimum = reader.bool();
                    break;
                case /* int64 max_length */ 15:
                    message.maxLength = reader.int64().toString();
                    break;
                case /* int64 min_length */ 16:
                    message.minLength = reader.int64().toString();
                    break;
                case /* string pattern */ 17:
                    message.pattern = reader.string();
                    break;
                case /* int64 max_items */ 18:
                    message.maxItems = reader.int64().toString();
                    break;
                case /* int64 min_items */ 19:
                    message.minItems = reader.int64().toString();
                    break;
                case /* bool unique_items */ 20:
                    message.uniqueItems = reader.bool();
                    break;
                case /* int64 max_properties */ 21:
                    message.maxProperties = reader.int64().toString();
                    break;
                case /* int64 min_properties */ 22:
                    message.minProperties = reader.int64().toString();
                    break;
                case /* repeated string required */ 23:
                    message.required.push(reader.string());
                    break;
                case /* repeated gnostic.openapi.v3.Any enum */ 24:
                    message.enum.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string type */ 25:
                    message.type = reader.string();
                    break;
                case /* repeated gnostic.openapi.v3.SchemaOrReference all_of */ 26:
                    message.allOf.push(SchemaOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated gnostic.openapi.v3.SchemaOrReference one_of */ 27:
                    message.oneOf.push(SchemaOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated gnostic.openapi.v3.SchemaOrReference any_of */ 28:
                    message.anyOf.push(SchemaOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* gnostic.openapi.v3.Schema not */ 29:
                    message.not = Schema.internalBinaryRead(reader, reader.uint32(), options, message.not);
                    break;
                case /* gnostic.openapi.v3.ItemsItem items */ 30:
                    message.items = ItemsItem.internalBinaryRead(reader, reader.uint32(), options, message.items);
                    break;
                case /* gnostic.openapi.v3.Properties properties */ 31:
                    message.properties = Properties.internalBinaryRead(reader, reader.uint32(), options, message.properties);
                    break;
                case /* gnostic.openapi.v3.AdditionalPropertiesItem additional_properties */ 32:
                    message.additionalProperties = AdditionalPropertiesItem.internalBinaryRead(reader, reader.uint32(), options, message.additionalProperties);
                    break;
                case /* gnostic.openapi.v3.DefaultType default */ 33:
                    message.default = DefaultType.internalBinaryRead(reader, reader.uint32(), options, message.default);
                    break;
                case /* string description */ 34:
                    message.description = reader.string();
                    break;
                case /* string format */ 35:
                    message.format = reader.string();
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 36:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Schema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool nullable = 1; */
        if (message.nullable !== false)
            writer.tag(1, WireType.Varint).bool(message.nullable);
        /* gnostic.openapi.v3.Discriminator discriminator = 2; */
        if (message.discriminator)
            Discriminator.internalBinaryWrite(message.discriminator, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool read_only = 3; */
        if (message.readOnly !== false)
            writer.tag(3, WireType.Varint).bool(message.readOnly);
        /* bool write_only = 4; */
        if (message.writeOnly !== false)
            writer.tag(4, WireType.Varint).bool(message.writeOnly);
        /* gnostic.openapi.v3.Xml xml = 5; */
        if (message.xml)
            Xml.internalBinaryWrite(message.xml, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.ExternalDocs external_docs = 6; */
        if (message.externalDocs)
            ExternalDocs.internalBinaryWrite(message.externalDocs, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Any example = 7; */
        if (message.example)
            Any.internalBinaryWrite(message.example, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* bool deprecated = 8; */
        if (message.deprecated !== false)
            writer.tag(8, WireType.Varint).bool(message.deprecated);
        /* string title = 9; */
        if (message.title !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.title);
        /* double multiple_of = 10; */
        if (message.multipleOf !== 0)
            writer.tag(10, WireType.Bit64).double(message.multipleOf);
        /* double maximum = 11; */
        if (message.maximum !== 0)
            writer.tag(11, WireType.Bit64).double(message.maximum);
        /* bool exclusive_maximum = 12; */
        if (message.exclusiveMaximum !== false)
            writer.tag(12, WireType.Varint).bool(message.exclusiveMaximum);
        /* double minimum = 13; */
        if (message.minimum !== 0)
            writer.tag(13, WireType.Bit64).double(message.minimum);
        /* bool exclusive_minimum = 14; */
        if (message.exclusiveMinimum !== false)
            writer.tag(14, WireType.Varint).bool(message.exclusiveMinimum);
        /* int64 max_length = 15; */
        if (message.maxLength !== "0")
            writer.tag(15, WireType.Varint).int64(message.maxLength);
        /* int64 min_length = 16; */
        if (message.minLength !== "0")
            writer.tag(16, WireType.Varint).int64(message.minLength);
        /* string pattern = 17; */
        if (message.pattern !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.pattern);
        /* int64 max_items = 18; */
        if (message.maxItems !== "0")
            writer.tag(18, WireType.Varint).int64(message.maxItems);
        /* int64 min_items = 19; */
        if (message.minItems !== "0")
            writer.tag(19, WireType.Varint).int64(message.minItems);
        /* bool unique_items = 20; */
        if (message.uniqueItems !== false)
            writer.tag(20, WireType.Varint).bool(message.uniqueItems);
        /* int64 max_properties = 21; */
        if (message.maxProperties !== "0")
            writer.tag(21, WireType.Varint).int64(message.maxProperties);
        /* int64 min_properties = 22; */
        if (message.minProperties !== "0")
            writer.tag(22, WireType.Varint).int64(message.minProperties);
        /* repeated string required = 23; */
        for (let i = 0; i < message.required.length; i++)
            writer.tag(23, WireType.LengthDelimited).string(message.required[i]);
        /* repeated gnostic.openapi.v3.Any enum = 24; */
        for (let i = 0; i < message.enum.length; i++)
            Any.internalBinaryWrite(message.enum[i], writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* string type = 25; */
        if (message.type !== "")
            writer.tag(25, WireType.LengthDelimited).string(message.type);
        /* repeated gnostic.openapi.v3.SchemaOrReference all_of = 26; */
        for (let i = 0; i < message.allOf.length; i++)
            SchemaOrReference.internalBinaryWrite(message.allOf[i], writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.SchemaOrReference one_of = 27; */
        for (let i = 0; i < message.oneOf.length; i++)
            SchemaOrReference.internalBinaryWrite(message.oneOf[i], writer.tag(27, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.SchemaOrReference any_of = 28; */
        for (let i = 0; i < message.anyOf.length; i++)
            SchemaOrReference.internalBinaryWrite(message.anyOf[i], writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Schema not = 29; */
        if (message.not)
            Schema.internalBinaryWrite(message.not, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.ItemsItem items = 30; */
        if (message.items)
            ItemsItem.internalBinaryWrite(message.items, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Properties properties = 31; */
        if (message.properties)
            Properties.internalBinaryWrite(message.properties, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.AdditionalPropertiesItem additional_properties = 32; */
        if (message.additionalProperties)
            AdditionalPropertiesItem.internalBinaryWrite(message.additionalProperties, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.DefaultType default = 33; */
        if (message.default)
            DefaultType.internalBinaryWrite(message.default, writer.tag(33, WireType.LengthDelimited).fork(), options).join();
        /* string description = 34; */
        if (message.description !== "")
            writer.tag(34, WireType.LengthDelimited).string(message.description);
        /* string format = 35; */
        if (message.format !== "")
            writer.tag(35, WireType.LengthDelimited).string(message.format);
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 36; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(36, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Schema
 */
export const Schema = new Schema$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaOrReference$Type extends MessageType<SchemaOrReference> {
    constructor() {
        super("gnostic.openapi.v3.SchemaOrReference", [
            { no: 1, name: "schema", kind: "message", oneof: "oneof", T: () => Schema },
            { no: 2, name: "reference", kind: "message", oneof: "oneof", T: () => Reference }
        ]);
    }
    create(value?: PartialMessage<SchemaOrReference>): SchemaOrReference {
        const message = { oneof: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SchemaOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaOrReference): SchemaOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gnostic.openapi.v3.Schema schema */ 1:
                    message.oneof = {
                        oneofKind: "schema",
                        schema: Schema.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).schema)
                    };
                    break;
                case /* gnostic.openapi.v3.Reference reference */ 2:
                    message.oneof = {
                        oneofKind: "reference",
                        reference: Reference.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).reference)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SchemaOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gnostic.openapi.v3.Schema schema = 1; */
        if (message.oneof.oneofKind === "schema")
            Schema.internalBinaryWrite(message.oneof.schema, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Reference reference = 2; */
        if (message.oneof.oneofKind === "reference")
            Reference.internalBinaryWrite(message.oneof.reference, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.SchemaOrReference
 */
export const SchemaOrReference = new SchemaOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemasOrReferences$Type extends MessageType<SchemasOrReferences> {
    constructor() {
        super("gnostic.openapi.v3.SchemasOrReferences", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedSchemaOrReference }
        ]);
    }
    create(value?: PartialMessage<SchemasOrReferences>): SchemasOrReferences {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SchemasOrReferences>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemasOrReferences): SchemasOrReferences {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedSchemaOrReference additional_properties */ 1:
                    message.additionalProperties.push(NamedSchemaOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SchemasOrReferences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedSchemaOrReference.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.SchemasOrReferences
 */
export const SchemasOrReferences = new SchemasOrReferences$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityRequirement$Type extends MessageType<SecurityRequirement> {
    constructor() {
        super("gnostic.openapi.v3.SecurityRequirement", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedStringArray }
        ]);
    }
    create(value?: PartialMessage<SecurityRequirement>): SecurityRequirement {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SecurityRequirement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecurityRequirement): SecurityRequirement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedStringArray additional_properties */ 1:
                    message.additionalProperties.push(NamedStringArray.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecurityRequirement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedStringArray additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedStringArray.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.SecurityRequirement
 */
export const SecurityRequirement = new SecurityRequirement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityScheme$Type extends MessageType<SecurityScheme> {
    constructor() {
        super("gnostic.openapi.v3.SecurityScheme", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "in", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "scheme", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "bearer_format", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "flows", kind: "message", T: () => OauthFlows },
            { no: 8, name: "open_id_connect_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<SecurityScheme>): SecurityScheme {
        const message = { type: "", description: "", name: "", in: "", scheme: "", bearerFormat: "", openIdConnectUrl: "", specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SecurityScheme>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecurityScheme): SecurityScheme {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string in */ 4:
                    message.in = reader.string();
                    break;
                case /* string scheme */ 5:
                    message.scheme = reader.string();
                    break;
                case /* string bearer_format */ 6:
                    message.bearerFormat = reader.string();
                    break;
                case /* gnostic.openapi.v3.OauthFlows flows */ 7:
                    message.flows = OauthFlows.internalBinaryRead(reader, reader.uint32(), options, message.flows);
                    break;
                case /* string open_id_connect_url */ 8:
                    message.openIdConnectUrl = reader.string();
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 9:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecurityScheme, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string in = 4; */
        if (message.in !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.in);
        /* string scheme = 5; */
        if (message.scheme !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.scheme);
        /* string bearer_format = 6; */
        if (message.bearerFormat !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.bearerFormat);
        /* gnostic.openapi.v3.OauthFlows flows = 7; */
        if (message.flows)
            OauthFlows.internalBinaryWrite(message.flows, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string open_id_connect_url = 8; */
        if (message.openIdConnectUrl !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.openIdConnectUrl);
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 9; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.SecurityScheme
 */
export const SecurityScheme = new SecurityScheme$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecuritySchemeOrReference$Type extends MessageType<SecuritySchemeOrReference> {
    constructor() {
        super("gnostic.openapi.v3.SecuritySchemeOrReference", [
            { no: 1, name: "security_scheme", kind: "message", oneof: "oneof", T: () => SecurityScheme },
            { no: 2, name: "reference", kind: "message", oneof: "oneof", T: () => Reference }
        ]);
    }
    create(value?: PartialMessage<SecuritySchemeOrReference>): SecuritySchemeOrReference {
        const message = { oneof: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SecuritySchemeOrReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecuritySchemeOrReference): SecuritySchemeOrReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gnostic.openapi.v3.SecurityScheme security_scheme */ 1:
                    message.oneof = {
                        oneofKind: "securityScheme",
                        securityScheme: SecurityScheme.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).securityScheme)
                    };
                    break;
                case /* gnostic.openapi.v3.Reference reference */ 2:
                    message.oneof = {
                        oneofKind: "reference",
                        reference: Reference.internalBinaryRead(reader, reader.uint32(), options, (message.oneof as any).reference)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecuritySchemeOrReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gnostic.openapi.v3.SecurityScheme security_scheme = 1; */
        if (message.oneof.oneofKind === "securityScheme")
            SecurityScheme.internalBinaryWrite(message.oneof.securityScheme, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gnostic.openapi.v3.Reference reference = 2; */
        if (message.oneof.oneofKind === "reference")
            Reference.internalBinaryWrite(message.oneof.reference, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.SecuritySchemeOrReference
 */
export const SecuritySchemeOrReference = new SecuritySchemeOrReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecuritySchemesOrReferences$Type extends MessageType<SecuritySchemesOrReferences> {
    constructor() {
        super("gnostic.openapi.v3.SecuritySchemesOrReferences", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedSecuritySchemeOrReference }
        ]);
    }
    create(value?: PartialMessage<SecuritySchemesOrReferences>): SecuritySchemesOrReferences {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SecuritySchemesOrReferences>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecuritySchemesOrReferences): SecuritySchemesOrReferences {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedSecuritySchemeOrReference additional_properties */ 1:
                    message.additionalProperties.push(NamedSecuritySchemeOrReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecuritySchemesOrReferences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedSecuritySchemeOrReference additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedSecuritySchemeOrReference.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.SecuritySchemesOrReferences
 */
export const SecuritySchemesOrReferences = new SecuritySchemesOrReferences$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Server$Type extends MessageType<Server> {
    constructor() {
        super("gnostic.openapi.v3.Server", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "variables", kind: "message", T: () => ServerVariables },
            { no: 4, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Server>): Server {
        const message = { url: "", description: "", specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Server>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Server): Server {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* gnostic.openapi.v3.ServerVariables variables */ 3:
                    message.variables = ServerVariables.internalBinaryRead(reader, reader.uint32(), options, message.variables);
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 4:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Server, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* gnostic.openapi.v3.ServerVariables variables = 3; */
        if (message.variables)
            ServerVariables.internalBinaryWrite(message.variables, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 4; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Server
 */
export const Server = new Server$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerVariable$Type extends MessageType<ServerVariable> {
    constructor() {
        super("gnostic.openapi.v3.ServerVariable", [
            { no: 1, name: "enum", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "default", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<ServerVariable>): ServerVariable {
        const message = { enum: [], default: "", description: "", specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServerVariable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerVariable): ServerVariable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string enum */ 1:
                    message.enum.push(reader.string());
                    break;
                case /* string default */ 2:
                    message.default = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 4:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerVariable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string enum = 1; */
        for (let i = 0; i < message.enum.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.enum[i]);
        /* string default = 2; */
        if (message.default !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.default);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 4; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.ServerVariable
 */
export const ServerVariable = new ServerVariable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerVariables$Type extends MessageType<ServerVariables> {
    constructor() {
        super("gnostic.openapi.v3.ServerVariables", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedServerVariable }
        ]);
    }
    create(value?: PartialMessage<ServerVariables>): ServerVariables {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServerVariables>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerVariables): ServerVariables {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedServerVariable additional_properties */ 1:
                    message.additionalProperties.push(NamedServerVariable.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerVariables, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedServerVariable additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedServerVariable.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.ServerVariables
 */
export const ServerVariables = new ServerVariables$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecificationExtension$Type extends MessageType<SpecificationExtension> {
    constructor() {
        super("gnostic.openapi.v3.SpecificationExtension", [
            { no: 1, name: "number", kind: "scalar", oneof: "oneof", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "boolean", kind: "scalar", oneof: "oneof", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "string", kind: "scalar", oneof: "oneof", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SpecificationExtension>): SpecificationExtension {
        const message = { oneof: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SpecificationExtension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpecificationExtension): SpecificationExtension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double number */ 1:
                    message.oneof = {
                        oneofKind: "number",
                        number: reader.double()
                    };
                    break;
                case /* bool boolean */ 2:
                    message.oneof = {
                        oneofKind: "boolean",
                        boolean: reader.bool()
                    };
                    break;
                case /* string string */ 3:
                    message.oneof = {
                        oneofKind: "string",
                        string: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpecificationExtension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double number = 1; */
        if (message.oneof.oneofKind === "number")
            writer.tag(1, WireType.Bit64).double(message.oneof.number);
        /* bool boolean = 2; */
        if (message.oneof.oneofKind === "boolean")
            writer.tag(2, WireType.Varint).bool(message.oneof.boolean);
        /* string string = 3; */
        if (message.oneof.oneofKind === "string")
            writer.tag(3, WireType.LengthDelimited).string(message.oneof.string);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.SpecificationExtension
 */
export const SpecificationExtension = new SpecificationExtension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringArray$Type extends MessageType<StringArray> {
    constructor() {
        super("gnostic.openapi.v3.StringArray", [
            { no: 1, name: "value", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StringArray>): StringArray {
        const message = { value: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StringArray>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StringArray): StringArray {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string value */ 1:
                    message.value.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StringArray, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string value = 1; */
        for (let i = 0; i < message.value.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.value[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.StringArray
 */
export const StringArray = new StringArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Strings$Type extends MessageType<Strings> {
    constructor() {
        super("gnostic.openapi.v3.Strings", [
            { no: 1, name: "additional_properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedString }
        ]);
    }
    create(value?: PartialMessage<Strings>): Strings {
        const message = { additionalProperties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Strings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Strings): Strings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gnostic.openapi.v3.NamedString additional_properties */ 1:
                    message.additionalProperties.push(NamedString.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Strings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gnostic.openapi.v3.NamedString additional_properties = 1; */
        for (let i = 0; i < message.additionalProperties.length; i++)
            NamedString.internalBinaryWrite(message.additionalProperties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Strings
 */
export const Strings = new Strings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tag$Type extends MessageType<Tag> {
    constructor() {
        super("gnostic.openapi.v3.Tag", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "external_docs", kind: "message", T: () => ExternalDocs },
            { no: 4, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Tag>): Tag {
        const message = { name: "", description: "", specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Tag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tag): Tag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* gnostic.openapi.v3.ExternalDocs external_docs */ 3:
                    message.externalDocs = ExternalDocs.internalBinaryRead(reader, reader.uint32(), options, message.externalDocs);
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 4:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* gnostic.openapi.v3.ExternalDocs external_docs = 3; */
        if (message.externalDocs)
            ExternalDocs.internalBinaryWrite(message.externalDocs, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 4; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Tag
 */
export const Tag = new Tag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Xml$Type extends MessageType<Xml> {
    constructor() {
        super("gnostic.openapi.v3.Xml", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "attribute", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "wrapped", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "specification_extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NamedAny }
        ]);
    }
    create(value?: PartialMessage<Xml>): Xml {
        const message = { name: "", namespace: "", prefix: "", attribute: false, wrapped: false, specificationExtension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Xml>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Xml): Xml {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string namespace */ 2:
                    message.namespace = reader.string();
                    break;
                case /* string prefix */ 3:
                    message.prefix = reader.string();
                    break;
                case /* bool attribute */ 4:
                    message.attribute = reader.bool();
                    break;
                case /* bool wrapped */ 5:
                    message.wrapped = reader.bool();
                    break;
                case /* repeated gnostic.openapi.v3.NamedAny specification_extension */ 6:
                    message.specificationExtension.push(NamedAny.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Xml, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string namespace = 2; */
        if (message.namespace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.namespace);
        /* string prefix = 3; */
        if (message.prefix !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.prefix);
        /* bool attribute = 4; */
        if (message.attribute !== false)
            writer.tag(4, WireType.Varint).bool(message.attribute);
        /* bool wrapped = 5; */
        if (message.wrapped !== false)
            writer.tag(5, WireType.Varint).bool(message.wrapped);
        /* repeated gnostic.openapi.v3.NamedAny specification_extension = 6; */
        for (let i = 0; i < message.specificationExtension.length; i++)
            NamedAny.internalBinaryWrite(message.specificationExtension[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gnostic.openapi.v3.Xml
 */
export const Xml = new Xml$Type();
